{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _declaration = require('./declaration');\n\nvar _declaration2 = _interopRequireDefault(_declaration);\n\nvar _tokenize = require('./tokenize');\n\nvar _tokenize2 = _interopRequireDefault(_tokenize);\n\nvar _comment = require('./comment');\n\nvar _comment2 = _interopRequireDefault(_comment);\n\nvar _atRule = require('./at-rule');\n\nvar _atRule2 = _interopRequireDefault(_atRule);\n\nvar _root = require('./root');\n\nvar _root2 = _interopRequireDefault(_root);\n\nvar _rule = require('./rule');\n\nvar _rule2 = _interopRequireDefault(_rule);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar Parser = function () {\n  function Parser(input) {\n    _classCallCheck(this, Parser);\n\n    this.input = input;\n    this.root = new _root2.default();\n    this.current = this.root;\n    this.spaces = '';\n    this.semicolon = false;\n    this.createTokenizer();\n    this.root.source = {\n      input: input,\n      start: {\n        line: 1,\n        column: 1\n      }\n    };\n  }\n\n  Parser.prototype.createTokenizer = function createTokenizer() {\n    this.tokenizer = (0, _tokenize2.default)(this.input);\n  };\n\n  Parser.prototype.parse = function parse() {\n    var token = void 0;\n\n    while (!this.tokenizer.endOfFile()) {\n      token = this.tokenizer.nextToken();\n\n      switch (token[0]) {\n        case 'space':\n          this.spaces += token[1];\n          break;\n\n        case ';':\n          this.freeSemicolon(token);\n          break;\n\n        case '}':\n          this.end(token);\n          break;\n\n        case 'comment':\n          this.comment(token);\n          break;\n\n        case 'at-word':\n          this.atrule(token);\n          break;\n\n        case '{':\n          this.emptyRule(token);\n          break;\n\n        default:\n          this.other(token);\n          break;\n      }\n    }\n\n    this.endFile();\n  };\n\n  Parser.prototype.comment = function comment(token) {\n    var node = new _comment2.default();\n    this.init(node, token[2], token[3]);\n    node.source.end = {\n      line: token[4],\n      column: token[5]\n    };\n    var text = token[1].slice(2, -2);\n\n    if (/^\\s*$/.test(text)) {\n      node.text = '';\n      node.raws.left = text;\n      node.raws.right = '';\n    } else {\n      var match = text.match(/^(\\s*)([^]*[^\\s])(\\s*)$/);\n      node.text = match[2];\n      node.raws.left = match[1];\n      node.raws.right = match[3];\n    }\n  };\n\n  Parser.prototype.emptyRule = function emptyRule(token) {\n    var node = new _rule2.default();\n    this.init(node, token[2], token[3]);\n    node.selector = '';\n    node.raws.between = '';\n    this.current = node;\n  };\n\n  Parser.prototype.other = function other(start) {\n    var end = false;\n    var type = null;\n    var colon = false;\n    var bracket = null;\n    var brackets = [];\n    var tokens = [];\n    var token = start;\n\n    while (token) {\n      type = token[0];\n      tokens.push(token);\n\n      if (type === '(' || type === '[') {\n        if (!bracket) bracket = token;\n        brackets.push(type === '(' ? ')' : ']');\n      } else if (brackets.length === 0) {\n        if (type === ';') {\n          if (colon) {\n            this.decl(tokens);\n            return;\n          } else {\n            break;\n          }\n        } else if (type === '{') {\n          this.rule(tokens);\n          return;\n        } else if (type === '}') {\n          this.tokenizer.back(tokens.pop());\n          end = true;\n          break;\n        } else if (type === ':') {\n          colon = true;\n        }\n      } else if (type === brackets[brackets.length - 1]) {\n        brackets.pop();\n        if (brackets.length === 0) bracket = null;\n      }\n\n      token = this.tokenizer.nextToken();\n    }\n\n    if (this.tokenizer.endOfFile()) end = true;\n    if (brackets.length > 0) this.unclosedBracket(bracket);\n\n    if (end && colon) {\n      while (tokens.length) {\n        token = tokens[tokens.length - 1][0];\n        if (token !== 'space' && token !== 'comment') break;\n        this.tokenizer.back(tokens.pop());\n      }\n\n      this.decl(tokens);\n      return;\n    } else {\n      this.unknownWord(tokens);\n    }\n  };\n\n  Parser.prototype.rule = function rule(tokens) {\n    tokens.pop();\n    var node = new _rule2.default();\n    this.init(node, tokens[0][2], tokens[0][3]);\n    node.raws.between = this.spacesAndCommentsFromEnd(tokens);\n    this.raw(node, 'selector', tokens);\n    this.current = node;\n  };\n\n  Parser.prototype.decl = function decl(tokens) {\n    var node = new _declaration2.default();\n    this.init(node);\n    var last = tokens[tokens.length - 1];\n\n    if (last[0] === ';') {\n      this.semicolon = true;\n      tokens.pop();\n    }\n\n    if (last[4]) {\n      node.source.end = {\n        line: last[4],\n        column: last[5]\n      };\n    } else {\n      node.source.end = {\n        line: last[2],\n        column: last[3]\n      };\n    }\n\n    while (tokens[0][0] !== 'word') {\n      if (tokens.length === 1) this.unknownWord(tokens);\n      node.raws.before += tokens.shift()[1];\n    }\n\n    node.source.start = {\n      line: tokens[0][2],\n      column: tokens[0][3]\n    };\n    node.prop = '';\n\n    while (tokens.length) {\n      var type = tokens[0][0];\n\n      if (type === ':' || type === 'space' || type === 'comment') {\n        break;\n      }\n\n      node.prop += tokens.shift()[1];\n    }\n\n    node.raws.between = '';\n    var token = void 0;\n\n    while (tokens.length) {\n      token = tokens.shift();\n\n      if (token[0] === ':') {\n        node.raws.between += token[1];\n        break;\n      } else {\n        node.raws.between += token[1];\n      }\n    }\n\n    if (node.prop[0] === '_' || node.prop[0] === '*') {\n      node.raws.before += node.prop[0];\n      node.prop = node.prop.slice(1);\n    }\n\n    node.raws.between += this.spacesAndCommentsFromStart(tokens);\n    this.precheckMissedSemicolon(tokens);\n\n    for (var i = tokens.length - 1; i > 0; i--) {\n      token = tokens[i];\n\n      if (token[1].toLowerCase() === '!important') {\n        node.important = true;\n        var string = this.stringFrom(tokens, i);\n        string = this.spacesFromEnd(tokens) + string;\n        if (string !== ' !important') node.raws.important = string;\n        break;\n      } else if (token[1].toLowerCase() === 'important') {\n        var cache = tokens.slice(0);\n        var str = '';\n\n        for (var j = i; j > 0; j--) {\n          var _type = cache[j][0];\n\n          if (str.trim().indexOf('!') === 0 && _type !== 'space') {\n            break;\n          }\n\n          str = cache.pop()[1] + str;\n        }\n\n        if (str.trim().indexOf('!') === 0) {\n          node.important = true;\n          node.raws.important = str;\n          tokens = cache;\n        }\n      }\n\n      if (token[0] !== 'space' && token[0] !== 'comment') {\n        break;\n      }\n    }\n\n    this.raw(node, 'value', tokens);\n    if (node.value.indexOf(':') !== -1) this.checkMissedSemicolon(tokens);\n  };\n\n  Parser.prototype.atrule = function atrule(token) {\n    var node = new _atRule2.default();\n    node.name = token[1].slice(1);\n\n    if (node.name === '') {\n      this.unnamedAtrule(node, token);\n    }\n\n    this.init(node, token[2], token[3]);\n    var prev = void 0;\n    var shift = void 0;\n    var last = false;\n    var open = false;\n    var params = [];\n\n    while (!this.tokenizer.endOfFile()) {\n      token = this.tokenizer.nextToken();\n\n      if (token[0] === ';') {\n        node.source.end = {\n          line: token[2],\n          column: token[3]\n        };\n        this.semicolon = true;\n        break;\n      } else if (token[0] === '{') {\n        open = true;\n        break;\n      } else if (token[0] === '}') {\n        if (params.length > 0) {\n          shift = params.length - 1;\n          prev = params[shift];\n\n          while (prev && prev[0] === 'space') {\n            prev = params[--shift];\n          }\n\n          if (prev) {\n            node.source.end = {\n              line: prev[4],\n              column: prev[5]\n            };\n          }\n        }\n\n        this.end(token);\n        break;\n      } else {\n        params.push(token);\n      }\n\n      if (this.tokenizer.endOfFile()) {\n        last = true;\n        break;\n      }\n    }\n\n    node.raws.between = this.spacesAndCommentsFromEnd(params);\n\n    if (params.length) {\n      node.raws.afterName = this.spacesAndCommentsFromStart(params);\n      this.raw(node, 'params', params);\n\n      if (last) {\n        token = params[params.length - 1];\n        node.source.end = {\n          line: token[4],\n          column: token[5]\n        };\n        this.spaces = node.raws.between;\n        node.raws.between = '';\n      }\n    } else {\n      node.raws.afterName = '';\n      node.params = '';\n    }\n\n    if (open) {\n      node.nodes = [];\n      this.current = node;\n    }\n  };\n\n  Parser.prototype.end = function end(token) {\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon;\n    }\n\n    this.semicolon = false;\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces;\n    this.spaces = '';\n\n    if (this.current.parent) {\n      this.current.source.end = {\n        line: token[2],\n        column: token[3]\n      };\n      this.current = this.current.parent;\n    } else {\n      this.unexpectedClose(token);\n    }\n  };\n\n  Parser.prototype.endFile = function endFile() {\n    if (this.current.parent) this.unclosedBlock();\n\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon;\n    }\n\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces;\n  };\n\n  Parser.prototype.freeSemicolon = function freeSemicolon(token) {\n    this.spaces += token[1];\n\n    if (this.current.nodes) {\n      var prev = this.current.nodes[this.current.nodes.length - 1];\n\n      if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {\n        prev.raws.ownSemicolon = this.spaces;\n        this.spaces = '';\n      }\n    }\n  }; // Helpers\n\n\n  Parser.prototype.init = function init(node, line, column) {\n    this.current.push(node);\n    node.source = {\n      start: {\n        line: line,\n        column: column\n      },\n      input: this.input\n    };\n    node.raws.before = this.spaces;\n    this.spaces = '';\n    if (node.type !== 'comment') this.semicolon = false;\n  };\n\n  Parser.prototype.raw = function raw(node, prop, tokens) {\n    var token = void 0,\n        type = void 0;\n    var length = tokens.length;\n    var value = '';\n    var clean = true;\n    var next = void 0,\n        prev = void 0;\n    var pattern = /^([.|#])?([\\w])+/i;\n\n    for (var i = 0; i < length; i += 1) {\n      token = tokens[i];\n      type = token[0];\n\n      if (type === 'comment' && node.type === 'rule') {\n        prev = tokens[i - 1];\n        next = tokens[i + 1];\n\n        if (prev[0] !== 'space' && next[0] !== 'space' && pattern.test(prev[1]) && pattern.test(next[1])) {\n          value += token[1];\n        } else {\n          clean = false;\n        }\n\n        continue;\n      }\n\n      if (type === 'comment' || type === 'space' && i === length - 1) {\n        clean = false;\n      } else {\n        value += token[1];\n      }\n    }\n\n    if (!clean) {\n      var raw = tokens.reduce(function (all, i) {\n        return all + i[1];\n      }, '');\n      node.raws[prop] = {\n        value: value,\n        raw: raw\n      };\n    }\n\n    node[prop] = value;\n  };\n\n  Parser.prototype.spacesAndCommentsFromEnd = function spacesAndCommentsFromEnd(tokens) {\n    var lastTokenType = void 0;\n    var spaces = '';\n\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0];\n      if (lastTokenType !== 'space' && lastTokenType !== 'comment') break;\n      spaces = tokens.pop()[1] + spaces;\n    }\n\n    return spaces;\n  };\n\n  Parser.prototype.spacesAndCommentsFromStart = function spacesAndCommentsFromStart(tokens) {\n    var next = void 0;\n    var spaces = '';\n\n    while (tokens.length) {\n      next = tokens[0][0];\n      if (next !== 'space' && next !== 'comment') break;\n      spaces += tokens.shift()[1];\n    }\n\n    return spaces;\n  };\n\n  Parser.prototype.spacesFromEnd = function spacesFromEnd(tokens) {\n    var lastTokenType = void 0;\n    var spaces = '';\n\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0];\n      if (lastTokenType !== 'space') break;\n      spaces = tokens.pop()[1] + spaces;\n    }\n\n    return spaces;\n  };\n\n  Parser.prototype.stringFrom = function stringFrom(tokens, from) {\n    var result = '';\n\n    for (var i = from; i < tokens.length; i++) {\n      result += tokens[i][1];\n    }\n\n    tokens.splice(from, tokens.length - from);\n    return result;\n  };\n\n  Parser.prototype.colon = function colon(tokens) {\n    var brackets = 0;\n    var token = void 0,\n        type = void 0,\n        prev = void 0;\n\n    for (var i = 0; i < tokens.length; i++) {\n      token = tokens[i];\n      type = token[0];\n\n      if (type === '(') {\n        brackets += 1;\n      } else if (type === ')') {\n        brackets -= 1;\n      } else if (brackets === 0 && type === ':') {\n        if (!prev) {\n          this.doubleColon(token);\n        } else if (prev[0] === 'word' && prev[1] === 'progid') {\n          continue;\n        } else {\n          return i;\n        }\n      }\n\n      prev = token;\n    }\n\n    return false;\n  }; // Errors\n\n\n  Parser.prototype.unclosedBracket = function unclosedBracket(bracket) {\n    throw this.input.error('Unclosed bracket', bracket[2], bracket[3]);\n  };\n\n  Parser.prototype.unknownWord = function unknownWord(tokens) {\n    throw this.input.error('Unknown word', tokens[0][2], tokens[0][3]);\n  };\n\n  Parser.prototype.unexpectedClose = function unexpectedClose(token) {\n    throw this.input.error('Unexpected }', token[2], token[3]);\n  };\n\n  Parser.prototype.unclosedBlock = function unclosedBlock() {\n    var pos = this.current.source.start;\n    throw this.input.error('Unclosed block', pos.line, pos.column);\n  };\n\n  Parser.prototype.doubleColon = function doubleColon(token) {\n    throw this.input.error('Double colon', token[2], token[3]);\n  };\n\n  Parser.prototype.unnamedAtrule = function unnamedAtrule(node, token) {\n    throw this.input.error('At-rule without name', token[2], token[3]);\n  };\n\n  Parser.prototype.precheckMissedSemicolon = function precheckMissedSemicolon(tokens) {\n    // Hook for Safe Parser\n    tokens;\n  };\n\n  Parser.prototype.checkMissedSemicolon = function checkMissedSemicolon(tokens) {\n    var colon = this.colon(tokens);\n    if (colon === false) return;\n    var founded = 0;\n    var token = void 0;\n\n    for (var j = colon - 1; j >= 0; j--) {\n      token = tokens[j];\n\n      if (token[0] !== 'space') {\n        founded += 1;\n        if (founded === 2) break;\n      }\n    }\n\n    throw this.input.error('Missed semicolon', token[2], token[3]);\n  };\n\n  return Parser;\n}();\n\nexports.default = Parser;\nmodule.exports = exports['default'];","map":{"version":3,"sources":["parser.es6"],"names":["Parser","Root","input","start","line","column","createTokenizer","parse","token","comment","node","Comment","text","match","emptyRule","Rule","other","end","type","colon","bracket","brackets","tokens","rule","decl","Declaration","last","i","string","cache","str","j","atrule","AtRule","prev","shift","open","params","endFile","freeSemicolon","init","raw","prop","length","value","clean","next","pattern","all","spacesAndCommentsFromEnd","lastTokenType","spaces","spacesAndCommentsFromStart","spacesFromEnd","stringFrom","from","result","unclosedBracket","unknownWord","unexpectedClose","unclosedBlock","pos","doubleColon","unnamedAtrule","precheckMissedSemicolon","checkMissedSemicolon","founded"],"mappings":"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","sourcesContent":["import Declaration from './declaration';\nimport tokenizer   from './tokenize';\nimport Comment     from './comment';\nimport AtRule      from './at-rule';\nimport Root        from './root';\nimport Rule        from './rule';\n\nexport default class Parser {\n\n    constructor(input) {\n        this.input = input;\n\n        this.root      = new Root();\n        this.current   = this.root;\n        this.spaces    = '';\n        this.semicolon = false;\n\n        this.createTokenizer();\n        this.root.source = { input, start: { line: 1, column: 1 } };\n    }\n\n    createTokenizer() {\n        this.tokenizer = tokenizer(this.input);\n    }\n\n    parse() {\n        let token;\n        while ( !this.tokenizer.endOfFile() ) {\n            token = this.tokenizer.nextToken();\n\n            switch ( token[0] ) {\n\n            case 'space':\n                this.spaces += token[1];\n                break;\n\n            case ';':\n                this.freeSemicolon(token);\n                break;\n\n            case '}':\n                this.end(token);\n                break;\n\n            case 'comment':\n                this.comment(token);\n                break;\n\n            case 'at-word':\n                this.atrule(token);\n                break;\n\n            case '{':\n                this.emptyRule(token);\n                break;\n\n            default:\n                this.other(token);\n                break;\n            }\n        }\n        this.endFile();\n    }\n\n    comment(token) {\n        let node = new Comment();\n        this.init(node, token[2], token[3]);\n        node.source.end = { line: token[4], column: token[5] };\n\n        let text = token[1].slice(2, -2);\n        if ( /^\\s*$/.test(text) ) {\n            node.text       = '';\n            node.raws.left  = text;\n            node.raws.right = '';\n        } else {\n            let match = text.match(/^(\\s*)([^]*[^\\s])(\\s*)$/);\n            node.text       = match[2];\n            node.raws.left  = match[1];\n            node.raws.right = match[3];\n        }\n    }\n\n    emptyRule(token) {\n        let node = new Rule();\n        this.init(node, token[2], token[3]);\n        node.selector = '';\n        node.raws.between = '';\n        this.current = node;\n    }\n\n    other(start) {\n        let end      = false;\n        let type     = null;\n        let colon    = false;\n        let bracket  = null;\n        let brackets = [];\n\n        let tokens = [];\n        let token = start;\n        while ( token ) {\n            type = token[0];\n            tokens.push(token);\n\n            if ( type === '(' || type === '[' ) {\n                if ( !bracket ) bracket = token;\n                brackets.push(type === '(' ? ')' : ']');\n\n            } else if ( brackets.length === 0 ) {\n                if ( type === ';' ) {\n                    if ( colon ) {\n                        this.decl(tokens);\n                        return;\n                    } else {\n                        break;\n                    }\n\n                } else if ( type === '{' ) {\n                    this.rule(tokens);\n                    return;\n\n                } else if ( type === '}' ) {\n                    this.tokenizer.back(tokens.pop());\n                    end = true;\n                    break;\n\n                } else if ( type === ':' ) {\n                    colon = true;\n                }\n\n            } else if ( type === brackets[brackets.length - 1] ) {\n                brackets.pop();\n                if ( brackets.length === 0 ) bracket = null;\n            }\n\n            token = this.tokenizer.nextToken();\n        }\n\n        if ( this.tokenizer.endOfFile() ) end = true;\n        if ( brackets.length > 0 ) this.unclosedBracket(bracket);\n\n        if ( end && colon ) {\n            while ( tokens.length ) {\n                token = tokens[tokens.length - 1][0];\n                if ( token !== 'space' && token !== 'comment' ) break;\n                this.tokenizer.back(tokens.pop());\n            }\n            this.decl(tokens);\n            return;\n        } else {\n            this.unknownWord(tokens);\n        }\n    }\n\n    rule(tokens) {\n        tokens.pop();\n\n        let node = new Rule();\n        this.init(node, tokens[0][2], tokens[0][3]);\n\n        node.raws.between = this.spacesAndCommentsFromEnd(tokens);\n        this.raw(node, 'selector', tokens);\n        this.current = node;\n    }\n\n    decl(tokens) {\n        let node = new Declaration();\n        this.init(node);\n\n        let last = tokens[tokens.length - 1];\n        if ( last[0] === ';' ) {\n            this.semicolon = true;\n            tokens.pop();\n        }\n        if ( last[4] ) {\n            node.source.end = { line: last[4], column: last[5] };\n        } else {\n            node.source.end = { line: last[2], column: last[3] };\n        }\n\n        while ( tokens[0][0] !== 'word' ) {\n            if ( tokens.length === 1 ) this.unknownWord(tokens);\n            node.raws.before += tokens.shift()[1];\n        }\n        node.source.start = { line: tokens[0][2], column: tokens[0][3] };\n\n        node.prop = '';\n        while ( tokens.length ) {\n            let type = tokens[0][0];\n            if ( type === ':' || type === 'space' || type === 'comment' ) {\n                break;\n            }\n            node.prop += tokens.shift()[1];\n        }\n\n        node.raws.between = '';\n\n        let token;\n        while ( tokens.length ) {\n            token = tokens.shift();\n\n            if ( token[0] === ':' ) {\n                node.raws.between += token[1];\n                break;\n            } else {\n                node.raws.between += token[1];\n            }\n        }\n\n        if ( node.prop[0] === '_' || node.prop[0] === '*' ) {\n            node.raws.before += node.prop[0];\n            node.prop = node.prop.slice(1);\n        }\n        node.raws.between += this.spacesAndCommentsFromStart(tokens);\n        this.precheckMissedSemicolon(tokens);\n\n        for ( let i = tokens.length - 1; i > 0; i-- ) {\n            token = tokens[i];\n            if ( token[1].toLowerCase() === '!important' ) {\n                node.important = true;\n                let string = this.stringFrom(tokens, i);\n                string = this.spacesFromEnd(tokens) + string;\n                if ( string !== ' !important' ) node.raws.important = string;\n                break;\n\n            } else if (token[1].toLowerCase() === 'important') {\n                let cache = tokens.slice(0);\n                let str   = '';\n                for ( let j = i; j > 0; j-- ) {\n                    let type = cache[j][0];\n                    if ( str.trim().indexOf('!') === 0 && type !== 'space' ) {\n                        break;\n                    }\n                    str = cache.pop()[1] + str;\n                }\n                if ( str.trim().indexOf('!') === 0 ) {\n                    node.important = true;\n                    node.raws.important = str;\n                    tokens = cache;\n                }\n            }\n\n            if ( token[0] !== 'space' && token[0] !== 'comment' ) {\n                break;\n            }\n        }\n\n        this.raw(node, 'value', tokens);\n\n        if ( node.value.indexOf(':') !== -1 ) this.checkMissedSemicolon(tokens);\n    }\n\n    atrule(token) {\n        let node  = new AtRule();\n        node.name = token[1].slice(1);\n        if ( node.name === '' ) {\n            this.unnamedAtrule(node, token);\n        }\n        this.init(node, token[2], token[3]);\n\n        let prev;\n        let shift;\n        let last   = false;\n        let open   = false;\n        let params = [];\n\n        while ( !this.tokenizer.endOfFile() ) {\n            token = this.tokenizer.nextToken();\n\n            if ( token[0] === ';' ) {\n                node.source.end = { line: token[2], column: token[3] };\n                this.semicolon = true;\n                break;\n            } else if ( token[0] === '{' ) {\n                open = true;\n                break;\n            } else if ( token[0] === '}') {\n                if ( params.length > 0 ) {\n                    shift = params.length - 1;\n                    prev = params[shift];\n                    while ( prev && prev[0] === 'space' ) {\n                        prev = params[--shift];\n                    }\n                    if ( prev ) {\n                        node.source.end = { line: prev[4], column: prev[5] };\n                    }\n                }\n                this.end(token);\n                break;\n            } else {\n                params.push(token);\n            }\n\n            if ( this.tokenizer.endOfFile() ) {\n                last = true;\n                break;\n            }\n        }\n\n        node.raws.between = this.spacesAndCommentsFromEnd(params);\n        if ( params.length ) {\n            node.raws.afterName = this.spacesAndCommentsFromStart(params);\n            this.raw(node, 'params', params);\n            if ( last ) {\n                token = params[params.length - 1];\n                node.source.end   = { line: token[4], column: token[5] };\n                this.spaces       = node.raws.between;\n                node.raws.between = '';\n            }\n        } else {\n            node.raws.afterName = '';\n            node.params         = '';\n        }\n\n        if ( open ) {\n            node.nodes   = [];\n            this.current = node;\n        }\n    }\n\n    end(token) {\n        if ( this.current.nodes && this.current.nodes.length ) {\n            this.current.raws.semicolon = this.semicolon;\n        }\n        this.semicolon = false;\n\n        this.current.raws.after = (this.current.raws.after || '') + this.spaces;\n        this.spaces = '';\n\n        if ( this.current.parent ) {\n            this.current.source.end = { line: token[2], column: token[3] };\n            this.current = this.current.parent;\n        } else {\n            this.unexpectedClose(token);\n        }\n    }\n\n    endFile() {\n        if ( this.current.parent ) this.unclosedBlock();\n        if ( this.current.nodes && this.current.nodes.length ) {\n            this.current.raws.semicolon = this.semicolon;\n        }\n        this.current.raws.after = (this.current.raws.after || '') + this.spaces;\n    }\n\n    freeSemicolon(token) {\n        this.spaces += token[1];\n        if ( this.current.nodes ) {\n            let prev = this.current.nodes[this.current.nodes.length - 1];\n            if ( prev && prev.type === 'rule' && !prev.raws.ownSemicolon ) {\n                prev.raws.ownSemicolon = this.spaces;\n                this.spaces = '';\n            }\n        }\n    }\n\n    // Helpers\n\n    init(node, line, column) {\n        this.current.push(node);\n\n        node.source = { start: { line, column }, input: this.input };\n        node.raws.before = this.spaces;\n        this.spaces = '';\n        if ( node.type !== 'comment' ) this.semicolon = false;\n    }\n\n    raw(node, prop, tokens) {\n        let token, type;\n        let length = tokens.length;\n        let value  = '';\n        let clean  = true;\n        let next, prev;\n        const pattern = /^([.|#])?([\\w])+/i;\n\n        for ( let i = 0; i < length; i += 1 ) {\n            token = tokens[i];\n            type  = token[0];\n\n            if ( type === 'comment' && node.type === 'rule' ) {\n                prev = tokens[i - 1];\n                next = tokens[i + 1];\n\n                if (\n                    prev[0] !== 'space' &&\n                    next[0] !== 'space' &&\n                    pattern.test(prev[1]) &&\n                    pattern.test(next[1])\n                ) {\n                    value += token[1];\n                } else {\n                    clean = false;\n                }\n\n                continue;\n            }\n\n            if ( type === 'comment' || type === 'space' && i === length - 1 ) {\n                clean = false;\n            } else {\n                value += token[1];\n            }\n        }\n        if ( !clean ) {\n            let raw = tokens.reduce( (all, i) => all + i[1], '');\n            node.raws[prop] = { value, raw };\n        }\n        node[prop] = value;\n    }\n\n    spacesAndCommentsFromEnd(tokens) {\n        let lastTokenType;\n        let spaces = '';\n        while ( tokens.length ) {\n            lastTokenType = tokens[tokens.length - 1][0];\n            if ( lastTokenType !== 'space' &&\n                lastTokenType !== 'comment' ) break;\n            spaces = tokens.pop()[1] + spaces;\n        }\n        return spaces;\n    }\n\n    spacesAndCommentsFromStart(tokens) {\n        let next;\n        let spaces = '';\n        while ( tokens.length ) {\n            next = tokens[0][0];\n            if ( next !== 'space' && next !== 'comment' ) break;\n            spaces += tokens.shift()[1];\n        }\n        return spaces;\n    }\n\n    spacesFromEnd(tokens) {\n        let lastTokenType;\n        let spaces = '';\n        while ( tokens.length ) {\n            lastTokenType = tokens[tokens.length - 1][0];\n            if ( lastTokenType !== 'space' ) break;\n            spaces = tokens.pop()[1] + spaces;\n        }\n        return spaces;\n    }\n\n    stringFrom(tokens, from) {\n        let result = '';\n        for ( let i = from; i < tokens.length; i++ ) {\n            result += tokens[i][1];\n        }\n        tokens.splice(from, tokens.length - from);\n        return result;\n    }\n\n    colon(tokens) {\n        let brackets = 0;\n        let token, type, prev;\n        for ( let i = 0; i < tokens.length; i++ ) {\n            token = tokens[i];\n            type  = token[0];\n\n            if ( type === '(' ) {\n                brackets += 1;\n            } else if ( type === ')' ) {\n                brackets -= 1;\n            } else if ( brackets === 0 && type === ':' ) {\n                if ( !prev ) {\n                    this.doubleColon(token);\n                } else if ( prev[0] === 'word' && prev[1] === 'progid' ) {\n                    continue;\n                } else {\n                    return i;\n                }\n            }\n\n            prev = token;\n        }\n        return false;\n    }\n\n    // Errors\n\n    unclosedBracket(bracket) {\n        throw this.input.error('Unclosed bracket', bracket[2], bracket[3]);\n    }\n\n    unknownWord(tokens) {\n        throw this.input.error('Unknown word', tokens[0][2], tokens[0][3]);\n    }\n\n    unexpectedClose(token) {\n        throw this.input.error('Unexpected }', token[2], token[3]);\n    }\n\n    unclosedBlock() {\n        let pos = this.current.source.start;\n        throw this.input.error('Unclosed block', pos.line, pos.column);\n    }\n\n    doubleColon(token) {\n        throw this.input.error('Double colon', token[2], token[3]);\n    }\n\n    unnamedAtrule(node, token) {\n        throw this.input.error('At-rule without name', token[2], token[3]);\n    }\n\n    precheckMissedSemicolon(tokens) {\n        // Hook for Safe Parser\n        tokens;\n    }\n\n    checkMissedSemicolon(tokens) {\n        let colon = this.colon(tokens);\n        if ( colon === false ) return;\n\n        let founded = 0;\n        let token;\n        for ( let j = colon - 1; j >= 0; j-- ) {\n            token = tokens[j];\n            if ( token[0] !== 'space' ) {\n                founded += 1;\n                if ( founded === 2 ) break;\n            }\n        }\n        throw this.input.error('Missed semicolon', token[2], token[3]);\n    }\n\n}\n"]},"metadata":{},"sourceType":"script"}