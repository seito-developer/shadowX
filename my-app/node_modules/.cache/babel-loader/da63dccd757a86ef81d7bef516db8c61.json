{"ast":null,"code":"/**\n * @module lib/callbacks\n */\nexport const callbackMap = new WeakMap();\n/**\n * Store a callback for a method or event for a player.\n *\n * @param {Player} player The player object.\n * @param {string} name The method or event name.\n * @param {(function(this:Player, *): void|{resolve: function, reject: function})} callback\n *        The callback to call or an object with resolve and reject functions for a promise.\n * @return {void}\n */\n\nexport function storeCallback(player, name, callback) {\n  const playerCallbacks = callbackMap.get(player.element) || {};\n\n  if (!(name in playerCallbacks)) {\n    playerCallbacks[name] = [];\n  }\n\n  playerCallbacks[name].push(callback);\n  callbackMap.set(player.element, playerCallbacks);\n}\n/**\n * Get the callbacks for a player and event or method.\n *\n * @param {Player} player The player object.\n * @param {string} name The method or event name\n * @return {function[]}\n */\n\nexport function getCallbacks(player, name) {\n  const playerCallbacks = callbackMap.get(player.element) || {};\n  return playerCallbacks[name] || [];\n}\n/**\n * Remove a stored callback for a method or event for a player.\n *\n * @param {Player} player The player object.\n * @param {string} name The method or event name\n * @param {function} [callback] The specific callback to remove.\n * @return {boolean} Was this the last callback?\n */\n\nexport function removeCallback(player, name, callback) {\n  const playerCallbacks = callbackMap.get(player.element) || {};\n\n  if (!playerCallbacks[name]) {\n    return true;\n  } // If no callback is passed, remove all callbacks for the event\n\n\n  if (!callback) {\n    playerCallbacks[name] = [];\n    callbackMap.set(player.element, playerCallbacks);\n    return true;\n  }\n\n  const index = playerCallbacks[name].indexOf(callback);\n\n  if (index !== -1) {\n    playerCallbacks[name].splice(index, 1);\n  }\n\n  callbackMap.set(player.element, playerCallbacks);\n  return playerCallbacks[name] && playerCallbacks[name].length === 0;\n}\n/**\n * Return the first stored callback for a player and event or method.\n *\n * @param {Player} player The player object.\n * @param {string} name The method or event name.\n * @return {function} The callback, or false if there were none\n */\n\nexport function shiftCallbacks(player, name) {\n  const playerCallbacks = getCallbacks(player, name);\n\n  if (playerCallbacks.length < 1) {\n    return false;\n  }\n\n  const callback = playerCallbacks.shift();\n  removeCallback(player, name, callback);\n  return callback;\n}\n/**\n * Move callbacks associated with an element to another element.\n *\n * @param {HTMLElement} oldElement The old element.\n * @param {HTMLElement} newElement The new element.\n * @return {void}\n */\n\nexport function swapCallbacks(oldElement, newElement) {\n  const playerCallbacks = callbackMap.get(oldElement);\n  callbackMap.set(newElement, playerCallbacks);\n  callbackMap.delete(oldElement);\n}","map":{"version":3,"sources":["/Users/seito/Documents/develop/shadowX/my-app/node_modules/@vimeo/player/src/lib/callbacks.js"],"names":["callbackMap","WeakMap","storeCallback","player","name","callback","playerCallbacks","get","element","push","set","getCallbacks","removeCallback","index","indexOf","splice","length","shiftCallbacks","shift","swapCallbacks","oldElement","newElement","delete"],"mappings":"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","sourcesContent":["/**\n * @module lib/callbacks\n */\n\nexport const callbackMap = new WeakMap();\n\n/**\n * Store a callback for a method or event for a player.\n *\n * @param {Player} player The player object.\n * @param {string} name The method or event name.\n * @param {(function(this:Player, *): void|{resolve: function, reject: function})} callback\n *        The callback to call or an object with resolve and reject functions for a promise.\n * @return {void}\n */\nexport function storeCallback(player, name, callback) {\n    const playerCallbacks = callbackMap.get(player.element) || {};\n\n    if (!(name in playerCallbacks)) {\n        playerCallbacks[name] = [];\n    }\n\n    playerCallbacks[name].push(callback);\n    callbackMap.set(player.element, playerCallbacks);\n}\n\n/**\n * Get the callbacks for a player and event or method.\n *\n * @param {Player} player The player object.\n * @param {string} name The method or event name\n * @return {function[]}\n */\nexport function getCallbacks(player, name) {\n    const playerCallbacks = callbackMap.get(player.element) || {};\n    return playerCallbacks[name] || [];\n}\n\n/**\n * Remove a stored callback for a method or event for a player.\n *\n * @param {Player} player The player object.\n * @param {string} name The method or event name\n * @param {function} [callback] The specific callback to remove.\n * @return {boolean} Was this the last callback?\n */\nexport function removeCallback(player, name, callback) {\n    const playerCallbacks = callbackMap.get(player.element) || {};\n\n    if (!playerCallbacks[name]) {\n        return true;\n    }\n\n    // If no callback is passed, remove all callbacks for the event\n    if (!callback) {\n        playerCallbacks[name] = [];\n        callbackMap.set(player.element, playerCallbacks);\n\n        return true;\n    }\n\n    const index = playerCallbacks[name].indexOf(callback);\n\n    if (index !== -1) {\n        playerCallbacks[name].splice(index, 1);\n    }\n\n    callbackMap.set(player.element, playerCallbacks);\n    return playerCallbacks[name] && playerCallbacks[name].length === 0;\n}\n\n/**\n * Return the first stored callback for a player and event or method.\n *\n * @param {Player} player The player object.\n * @param {string} name The method or event name.\n * @return {function} The callback, or false if there were none\n */\nexport function shiftCallbacks(player, name) {\n    const playerCallbacks = getCallbacks(player, name);\n\n    if (playerCallbacks.length < 1) {\n        return false;\n    }\n\n    const callback = playerCallbacks.shift();\n    removeCallback(player, name, callback);\n    return callback;\n}\n\n/**\n * Move callbacks associated with an element to another element.\n *\n * @param {HTMLElement} oldElement The old element.\n * @param {HTMLElement} newElement The new element.\n * @return {void}\n */\nexport function swapCallbacks(oldElement, newElement) {\n    const playerCallbacks = callbackMap.get(oldElement);\n\n    callbackMap.set(newElement, playerCallbacks);\n    callbackMap.delete(oldElement);\n}\n"]},"metadata":{},"sourceType":"module"}