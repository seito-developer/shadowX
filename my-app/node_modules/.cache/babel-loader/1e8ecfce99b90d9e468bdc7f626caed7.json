{"ast":null,"code":"const postcss = require('postcss');\n\nconst parseObjectStyles = require('../../lib/util/parseObjectStyles').default;\n\nconst {\n  isPlainObject\n} = require('./utils');\n\nconst selectorParser = require('postcss-selector-parser');\n\nconst prefixSelector = require('../../lib/util/prefixSelector').default;\n\nconst {\n  updateAllClasses\n} = require('../pluginUtils');\n\nlet classNameParser = selectorParser(selectors => {\n  return selectors.first.filter(({\n    type\n  }) => type === 'class').pop().value;\n});\n\nfunction getClassNameFromSelector(selector) {\n  return classNameParser.transformSync(selector);\n} // Generate match permutations for a class candidate, like:\n// ['ring-offset-blue', '100']\n// ['ring-offset', 'blue-100']\n// ['ring', 'offset-blue-100']\n\n\nfunction* candidatePermutations(candidate, lastIndex = Infinity) {\n  if (lastIndex < 0) {\n    return;\n  }\n\n  let dashIdx;\n\n  if (lastIndex === Infinity && candidate.endsWith(']')) {\n    let bracketIdx = candidate.lastIndexOf('['); // If character before `[` isn't a dash, this isn't a dynamic class\n    // eg. string[]\n\n    dashIdx = candidate[bracketIdx - 1] === '-' ? bracketIdx - 1 : -1;\n  } else {\n    dashIdx = candidate.lastIndexOf('-', lastIndex);\n  }\n\n  if (dashIdx < 0) {\n    return;\n  }\n\n  let prefix = candidate.slice(0, dashIdx);\n  let modifier = candidate.slice(dashIdx + 1);\n  yield [prefix, modifier];\n  yield* candidatePermutations(candidate, dashIdx - 1);\n}\n\nfunction applyPrefix(matches, context) {\n  if (matches.length === 0 || context.tailwindConfig.prefix === '') {\n    return matches;\n  }\n\n  for (let match of matches) {\n    let [meta] = match;\n\n    if (meta.options.respectPrefix) {\n      let container = postcss.root({\n        nodes: [match[1]]\n      });\n      container.walkRules(r => {\n        r.selector = prefixSelector(context.tailwindConfig.prefix, r.selector);\n      });\n      match[1] = container.nodes[0];\n    }\n  }\n\n  return matches;\n}\n\nfunction applyImportant(matches) {\n  if (matches.length === 0) {\n    return matches;\n  }\n\n  let result = [];\n\n  for (let [meta, rule] of matches) {\n    let container = postcss.root({\n      nodes: [rule]\n    });\n    container.walkRules(r => {\n      r.selector = updateAllClasses(r.selector, className => {\n        return `!${className}`;\n      });\n      r.walkDecls(d => d.important = true);\n    });\n    result.push([meta, container.nodes[0]]);\n  }\n\n  return result;\n} // Takes a list of rule tuples and applies a variant like `hover`, sm`,\n// whatever to it. We used to do some extra caching here to avoid generating\n// a variant of the same rule more than once, but this was never hit because\n// we cache at the entire selector level further up the tree.\n//\n// Technically you can get a cache hit if you have `hover:focus:text-center`\n// and `focus:hover:text-center` in the same project, but it doesn't feel\n// worth the complexity for that case.\n\n\nfunction applyVariant(variant, matches, context) {\n  if (matches.length === 0) {\n    return matches;\n  }\n\n  if (context.variantMap.has(variant)) {\n    let [variantSort, applyThisVariant] = context.variantMap.get(variant);\n    let result = [];\n\n    for (let [{\n      sort,\n      layer,\n      options\n    }, rule] of matches) {\n      if (options.respectVariants === false) {\n        result.push([{\n          sort,\n          layer,\n          options\n        }, rule]);\n        continue;\n      }\n\n      let container = postcss.root();\n      container.append(rule.clone());\n\n      function modifySelectors(modifierFunction) {\n        container.each(rule => {\n          if (rule.type !== 'rule') {\n            return;\n          }\n\n          rule.selectors = rule.selectors.map(selector => {\n            return modifierFunction({\n              get className() {\n                return getClassNameFromSelector(selector);\n              },\n\n              selector\n            });\n          });\n        });\n        return container;\n      }\n\n      let ruleWithVariant = applyThisVariant({\n        container,\n        separator: context.tailwindConfig.separator,\n        modifySelectors\n      });\n\n      if (ruleWithVariant === null) {\n        continue;\n      }\n\n      let withOffset = [{\n        sort: variantSort | sort,\n        layer,\n        options\n      }, container.nodes[0]];\n      result.push(withOffset);\n    }\n\n    return result;\n  }\n\n  return [];\n}\n\nfunction parseRules(rule, cache, options = {}) {\n  // PostCSS node\n  if (!isPlainObject(rule) && !Array.isArray(rule)) {\n    return [[rule], options];\n  } // Tuple\n\n\n  if (Array.isArray(rule)) {\n    return parseRules(rule[0], cache, rule[1]);\n  } // Simple object\n\n\n  if (!cache.has(rule)) {\n    cache.set(rule, parseObjectStyles(rule));\n  }\n\n  return [cache.get(rule), options];\n}\n\nfunction* resolveMatchedPlugins(classCandidate, context) {\n  if (context.candidateRuleMap.has(classCandidate)) {\n    yield [context.candidateRuleMap.get(classCandidate), 'DEFAULT'];\n  }\n\n  let candidatePrefix = classCandidate;\n  let negative = false;\n  const twConfigPrefix = context.tailwindConfig.prefix || '';\n  const twConfigPrefixLen = twConfigPrefix.length;\n\n  if (candidatePrefix[twConfigPrefixLen] === '-') {\n    negative = true;\n    candidatePrefix = twConfigPrefix + candidatePrefix.slice(twConfigPrefixLen + 1);\n  }\n\n  for (let [prefix, modifier] of candidatePermutations(candidatePrefix)) {\n    if (context.candidateRuleMap.has(prefix)) {\n      yield [context.candidateRuleMap.get(prefix), negative ? `-${modifier}` : modifier];\n      return;\n    }\n  }\n}\n\nfunction* resolveMatches(candidate, context) {\n  let separator = context.tailwindConfig.separator;\n  let [classCandidate, ...variants] = candidate.split(separator).reverse();\n  let important = false;\n\n  if (classCandidate.startsWith('!')) {\n    important = true;\n    classCandidate = classCandidate.slice(1);\n  } // TODO: Reintroduce this in ways that doesn't break on false positives\n  // function sortAgainst(toSort, against) {\n  //   return toSort.slice().sort((a, z) => {\n  //     return bigSign(against.get(a)[0] - against.get(z)[0])\n  //   })\n  // }\n  // let sorted = sortAgainst(variants, context.variantMap)\n  // if (sorted.toString() !== variants.toString()) {\n  //   let corrected = sorted.reverse().concat(classCandidate).join(':')\n  //   throw new Error(`Class ${candidate} should be written as ${corrected}`)\n  // }\n\n\n  for (let matchedPlugins of resolveMatchedPlugins(classCandidate, context)) {\n    let pluginHelpers = {\n      candidate: classCandidate,\n      theme: context.tailwindConfig.theme\n    };\n    let matches = [];\n    let [plugins, modifier] = matchedPlugins;\n\n    for (let [sort, plugin] of plugins) {\n      if (typeof plugin === 'function') {\n        for (let ruleSet of [].concat(plugin(modifier, pluginHelpers))) {\n          let [rules, options] = parseRules(ruleSet, context.postCssNodeCache);\n\n          for (let rule of rules) {\n            matches.push([{ ...sort,\n              options: { ...sort.options,\n                ...options\n              }\n            }, rule]);\n          }\n        }\n      } // Only process static plugins on exact matches\n      else if (modifier === 'DEFAULT') {\n          let ruleSet = plugin;\n          let [rules, options] = parseRules(ruleSet, context.postCssNodeCache);\n\n          for (let rule of rules) {\n            matches.push([{ ...sort,\n              options: { ...sort.options,\n                ...options\n              }\n            }, rule]);\n          }\n        }\n    }\n\n    matches = applyPrefix(matches, context);\n\n    if (important) {\n      matches = applyImportant(matches, context);\n    }\n\n    for (let variant of variants) {\n      matches = applyVariant(variant, matches, context);\n    }\n\n    for (let match of matches) {\n      yield match;\n    }\n  }\n}\n\nfunction inKeyframes(rule) {\n  return rule.parent && rule.parent.type === 'atrule' && rule.parent.name === 'keyframes';\n}\n\nfunction generateRules(candidates, context) {\n  let allRules = [];\n\n  for (let candidate of candidates) {\n    if (context.notClassCache.has(candidate)) {\n      continue;\n    }\n\n    if (context.classCache.has(candidate)) {\n      allRules.push(context.classCache.get(candidate));\n      continue;\n    }\n\n    let matches = Array.from(resolveMatches(candidate, context));\n\n    if (matches.length === 0) {\n      context.notClassCache.add(candidate);\n      continue;\n    }\n\n    context.classCache.set(candidate, matches);\n    allRules.push(matches);\n  }\n\n  return allRules.flat(1).map(([{\n    sort,\n    layer,\n    options\n  }, rule]) => {\n    if (options.respectImportant) {\n      if (context.tailwindConfig.important === true) {\n        rule.walkDecls(d => {\n          if (d.parent.type === 'rule' && !inKeyframes(d.parent)) {\n            d.important = true;\n          }\n        });\n      } else if (typeof context.tailwindConfig.important === 'string') {\n        let container = postcss.root({\n          nodes: [rule]\n        });\n        container.walkRules(r => {\n          if (inKeyframes(r)) {\n            return;\n          }\n\n          r.selectors = r.selectors.map(selector => {\n            return `${context.tailwindConfig.important} ${selector}`;\n          });\n        });\n        rule = container.nodes[0];\n      }\n    }\n\n    return [sort | context.layerOrder[layer], rule];\n  });\n}\n\nmodule.exports = {\n  resolveMatches,\n  generateRules\n};","map":{"version":3,"sources":["/Users/seito/Documents/develop/count-jp/my-app/node_modules/tailwindcss/jit/lib/generateRules.js"],"names":["postcss","require","parseObjectStyles","default","isPlainObject","selectorParser","prefixSelector","updateAllClasses","classNameParser","selectors","first","filter","type","pop","value","getClassNameFromSelector","selector","transformSync","candidatePermutations","candidate","lastIndex","Infinity","dashIdx","endsWith","bracketIdx","lastIndexOf","prefix","slice","modifier","applyPrefix","matches","context","length","tailwindConfig","match","meta","options","respectPrefix","container","root","nodes","walkRules","r","applyImportant","result","rule","className","walkDecls","d","important","push","applyVariant","variant","variantMap","has","variantSort","applyThisVariant","get","sort","layer","respectVariants","append","clone","modifySelectors","modifierFunction","each","map","ruleWithVariant","separator","withOffset","parseRules","cache","Array","isArray","set","resolveMatchedPlugins","classCandidate","candidateRuleMap","candidatePrefix","negative","twConfigPrefix","twConfigPrefixLen","resolveMatches","variants","split","reverse","startsWith","matchedPlugins","pluginHelpers","theme","plugins","plugin","ruleSet","concat","rules","postCssNodeCache","inKeyframes","parent","name","generateRules","candidates","allRules","notClassCache","classCache","from","add","flat","respectImportant","layerOrder","module","exports"],"mappings":"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","sourcesContent":["const postcss = require('postcss')\nconst parseObjectStyles = require('../../lib/util/parseObjectStyles').default\nconst { isPlainObject } = require('./utils')\nconst selectorParser = require('postcss-selector-parser')\nconst prefixSelector = require('../../lib/util/prefixSelector').default\nconst { updateAllClasses } = require('../pluginUtils')\n\nlet classNameParser = selectorParser((selectors) => {\n  return selectors.first.filter(({ type }) => type === 'class').pop().value\n})\n\nfunction getClassNameFromSelector(selector) {\n  return classNameParser.transformSync(selector)\n}\n\n// Generate match permutations for a class candidate, like:\n// ['ring-offset-blue', '100']\n// ['ring-offset', 'blue-100']\n// ['ring', 'offset-blue-100']\nfunction* candidatePermutations(candidate, lastIndex = Infinity) {\n  if (lastIndex < 0) {\n    return\n  }\n\n  let dashIdx\n\n  if (lastIndex === Infinity && candidate.endsWith(']')) {\n    let bracketIdx = candidate.lastIndexOf('[')\n\n    // If character before `[` isn't a dash, this isn't a dynamic class\n    // eg. string[]\n    dashIdx = candidate[bracketIdx - 1] === '-' ? bracketIdx - 1 : -1\n  } else {\n    dashIdx = candidate.lastIndexOf('-', lastIndex)\n  }\n\n  if (dashIdx < 0) {\n    return\n  }\n\n  let prefix = candidate.slice(0, dashIdx)\n  let modifier = candidate.slice(dashIdx + 1)\n\n  yield [prefix, modifier]\n\n  yield* candidatePermutations(candidate, dashIdx - 1)\n}\n\nfunction applyPrefix(matches, context) {\n  if (matches.length === 0 || context.tailwindConfig.prefix === '') {\n    return matches\n  }\n\n  for (let match of matches) {\n    let [meta] = match\n    if (meta.options.respectPrefix) {\n      let container = postcss.root({ nodes: [match[1]] })\n      container.walkRules((r) => {\n        r.selector = prefixSelector(context.tailwindConfig.prefix, r.selector)\n      })\n      match[1] = container.nodes[0]\n    }\n  }\n\n  return matches\n}\n\nfunction applyImportant(matches) {\n  if (matches.length === 0) {\n    return matches\n  }\n  let result = []\n\n  for (let [meta, rule] of matches) {\n    let container = postcss.root({ nodes: [rule] })\n    container.walkRules((r) => {\n      r.selector = updateAllClasses(r.selector, (className) => {\n        return `!${className}`\n      })\n      r.walkDecls((d) => (d.important = true))\n    })\n    result.push([meta, container.nodes[0]])\n  }\n\n  return result\n}\n\n// Takes a list of rule tuples and applies a variant like `hover`, sm`,\n// whatever to it. We used to do some extra caching here to avoid generating\n// a variant of the same rule more than once, but this was never hit because\n// we cache at the entire selector level further up the tree.\n//\n// Technically you can get a cache hit if you have `hover:focus:text-center`\n// and `focus:hover:text-center` in the same project, but it doesn't feel\n// worth the complexity for that case.\n\nfunction applyVariant(variant, matches, context) {\n  if (matches.length === 0) {\n    return matches\n  }\n\n  if (context.variantMap.has(variant)) {\n    let [variantSort, applyThisVariant] = context.variantMap.get(variant)\n    let result = []\n\n    for (let [{ sort, layer, options }, rule] of matches) {\n      if (options.respectVariants === false) {\n        result.push([{ sort, layer, options }, rule])\n        continue\n      }\n\n      let container = postcss.root()\n      container.append(rule.clone())\n\n      function modifySelectors(modifierFunction) {\n        container.each((rule) => {\n          if (rule.type !== 'rule') {\n            return\n          }\n\n          rule.selectors = rule.selectors.map((selector) => {\n            return modifierFunction({\n              get className() {\n                return getClassNameFromSelector(selector)\n              },\n              selector,\n            })\n          })\n        })\n        return container\n      }\n\n      let ruleWithVariant = applyThisVariant({\n        container,\n        separator: context.tailwindConfig.separator,\n        modifySelectors,\n      })\n\n      if (ruleWithVariant === null) {\n        continue\n      }\n\n      let withOffset = [{ sort: variantSort | sort, layer, options }, container.nodes[0]]\n      result.push(withOffset)\n    }\n\n    return result\n  }\n\n  return []\n}\n\nfunction parseRules(rule, cache, options = {}) {\n  // PostCSS node\n  if (!isPlainObject(rule) && !Array.isArray(rule)) {\n    return [[rule], options]\n  }\n\n  // Tuple\n  if (Array.isArray(rule)) {\n    return parseRules(rule[0], cache, rule[1])\n  }\n\n  // Simple object\n  if (!cache.has(rule)) {\n    cache.set(rule, parseObjectStyles(rule))\n  }\n\n  return [cache.get(rule), options]\n}\n\nfunction* resolveMatchedPlugins(classCandidate, context) {\n  if (context.candidateRuleMap.has(classCandidate)) {\n    yield [context.candidateRuleMap.get(classCandidate), 'DEFAULT']\n  }\n\n  let candidatePrefix = classCandidate\n  let negative = false\n\n  const twConfigPrefix = context.tailwindConfig.prefix || ''\n  const twConfigPrefixLen = twConfigPrefix.length\n  if (candidatePrefix[twConfigPrefixLen] === '-') {\n    negative = true\n    candidatePrefix = twConfigPrefix + candidatePrefix.slice(twConfigPrefixLen + 1)\n  }\n\n  for (let [prefix, modifier] of candidatePermutations(candidatePrefix)) {\n    if (context.candidateRuleMap.has(prefix)) {\n      yield [context.candidateRuleMap.get(prefix), negative ? `-${modifier}` : modifier]\n      return\n    }\n  }\n}\n\nfunction* resolveMatches(candidate, context) {\n  let separator = context.tailwindConfig.separator\n  let [classCandidate, ...variants] = candidate.split(separator).reverse()\n  let important = false\n\n  if (classCandidate.startsWith('!')) {\n    important = true\n    classCandidate = classCandidate.slice(1)\n  }\n\n  // TODO: Reintroduce this in ways that doesn't break on false positives\n  // function sortAgainst(toSort, against) {\n  //   return toSort.slice().sort((a, z) => {\n  //     return bigSign(against.get(a)[0] - against.get(z)[0])\n  //   })\n  // }\n  // let sorted = sortAgainst(variants, context.variantMap)\n  // if (sorted.toString() !== variants.toString()) {\n  //   let corrected = sorted.reverse().concat(classCandidate).join(':')\n  //   throw new Error(`Class ${candidate} should be written as ${corrected}`)\n  // }\n\n  for (let matchedPlugins of resolveMatchedPlugins(classCandidate, context)) {\n    let pluginHelpers = {\n      candidate: classCandidate,\n      theme: context.tailwindConfig.theme,\n    }\n\n    let matches = []\n    let [plugins, modifier] = matchedPlugins\n\n    for (let [sort, plugin] of plugins) {\n      if (typeof plugin === 'function') {\n        for (let ruleSet of [].concat(plugin(modifier, pluginHelpers))) {\n          let [rules, options] = parseRules(ruleSet, context.postCssNodeCache)\n          for (let rule of rules) {\n            matches.push([{ ...sort, options: { ...sort.options, ...options } }, rule])\n          }\n        }\n      }\n      // Only process static plugins on exact matches\n      else if (modifier === 'DEFAULT') {\n        let ruleSet = plugin\n        let [rules, options] = parseRules(ruleSet, context.postCssNodeCache)\n        for (let rule of rules) {\n          matches.push([{ ...sort, options: { ...sort.options, ...options } }, rule])\n        }\n      }\n    }\n\n    matches = applyPrefix(matches, context)\n\n    if (important) {\n      matches = applyImportant(matches, context)\n    }\n\n    for (let variant of variants) {\n      matches = applyVariant(variant, matches, context)\n    }\n\n    for (let match of matches) {\n      yield match\n    }\n  }\n}\n\nfunction inKeyframes(rule) {\n  return rule.parent && rule.parent.type === 'atrule' && rule.parent.name === 'keyframes'\n}\n\nfunction generateRules(candidates, context) {\n  let allRules = []\n\n  for (let candidate of candidates) {\n    if (context.notClassCache.has(candidate)) {\n      continue\n    }\n\n    if (context.classCache.has(candidate)) {\n      allRules.push(context.classCache.get(candidate))\n      continue\n    }\n\n    let matches = Array.from(resolveMatches(candidate, context))\n\n    if (matches.length === 0) {\n      context.notClassCache.add(candidate)\n      continue\n    }\n\n    context.classCache.set(candidate, matches)\n    allRules.push(matches)\n  }\n\n  return allRules.flat(1).map(([{ sort, layer, options }, rule]) => {\n    if (options.respectImportant) {\n      if (context.tailwindConfig.important === true) {\n        rule.walkDecls((d) => {\n          if (d.parent.type === 'rule' && !inKeyframes(d.parent)) {\n            d.important = true\n          }\n        })\n      } else if (typeof context.tailwindConfig.important === 'string') {\n        let container = postcss.root({ nodes: [rule] })\n        container.walkRules((r) => {\n          if (inKeyframes(r)) {\n            return\n          }\n\n          r.selectors = r.selectors.map((selector) => {\n            return `${context.tailwindConfig.important} ${selector}`\n          })\n        })\n        rule = container.nodes[0]\n      }\n    }\n    return [sort | context.layerOrder[layer], rule]\n  })\n}\n\nmodule.exports = {\n  resolveMatches,\n  generateRules,\n}\n"]},"metadata":{},"sourceType":"script"}