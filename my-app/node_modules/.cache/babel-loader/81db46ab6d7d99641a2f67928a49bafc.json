{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = substituteClassApplyAtRules;\n\nvar _lodash = _interopRequireDefault(require(\"lodash\"));\n\nvar _postcssSelectorParser = _interopRequireDefault(require(\"postcss-selector-parser\"));\n\nvar _postcss = _interopRequireDefault(require(\"postcss\"));\n\nvar _didyoumean = _interopRequireDefault(require(\"didyoumean\"));\n\nvar _substituteTailwindAtRules = _interopRequireDefault(require(\"./substituteTailwindAtRules\"));\n\nvar _evaluateTailwindFunctions = _interopRequireDefault(require(\"./evaluateTailwindFunctions\"));\n\nvar _substituteVariantsAtRules = _interopRequireDefault(require(\"./substituteVariantsAtRules\"));\n\nvar _substituteResponsiveAtRules = _interopRequireDefault(require(\"./substituteResponsiveAtRules\"));\n\nvar _convertLayerAtRulesToControlComments = _interopRequireDefault(require(\"./convertLayerAtRulesToControlComments\"));\n\nvar _substituteScreenAtRules = _interopRequireDefault(require(\"./substituteScreenAtRules\"));\n\nvar _prefixSelector = _interopRequireDefault(require(\"../util/prefixSelector\"));\n\nvar _useMemo = require(\"../util/useMemo\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction hasAtRule(css, atRule, condition) {\n  let found = false;\n  css.walkAtRules(atRule, condition === undefined ? () => {\n    found = true;\n    return false;\n  } : node => {\n    if (condition(node)) {\n      found = true;\n      return false;\n    }\n  });\n  return found;\n}\n\nfunction cloneWithoutChildren(node) {\n  if (node.type === 'atrule') {\n    return _postcss.default.atRule({\n      name: node.name,\n      params: node.params\n    });\n  }\n\n  if (node.type === 'rule') {\n    return _postcss.default.rule({\n      name: node.name,\n      selectors: node.selectors\n    });\n  }\n\n  const clone = node.clone();\n  clone.removeAll();\n  return clone;\n}\n\nconst tailwindApplyPlaceholder = _postcssSelectorParser.default.attribute({\n  attribute: '__TAILWIND-APPLY-PLACEHOLDER__'\n});\n\nfunction generateRulesFromApply({\n  rule,\n  utilityName: className,\n  classPosition\n}, replaceWiths) {\n  const parser = (0, _postcssSelectorParser.default)(selectors => {\n    let i = 0;\n    selectors.walkClasses(c => {\n      if (classPosition === i++ && c.value === className) {\n        c.replaceWith(tailwindApplyPlaceholder);\n      }\n    });\n  });\n\n  const processedSelectors = _lodash.default.flatMap(rule.selectors, selector => {\n    // You could argue we should make this replacement at the AST level, but if we believe\n    // the placeholder string is safe from collisions then it is safe to do this is a simple\n    // string replacement, and much, much faster.\n    return replaceWiths.map(replaceWith => parser.processSync(selector).replace('[__TAILWIND-APPLY-PLACEHOLDER__]', replaceWith));\n  });\n\n  const cloned = rule.clone();\n  let current = cloned;\n  let parent = rule.parent;\n\n  while (parent && parent.type !== 'root') {\n    const parentClone = cloneWithoutChildren(parent);\n    parentClone.append(current);\n    current.parent = parentClone;\n    current = parentClone;\n    parent = parent.parent;\n  }\n\n  cloned.selectors = processedSelectors;\n  return current;\n}\n\nconst extractUtilityNamesParser = (0, _postcssSelectorParser.default)(selectors => {\n  let classes = [];\n  selectors.walkClasses(c => classes.push(c.value));\n  return classes;\n});\nconst extractUtilityNames = (0, _useMemo.useMemo)(selector => extractUtilityNamesParser.transformSync(selector), selector => selector);\nconst cloneRuleWithParent = (0, _useMemo.useMemo)(rule => rule.clone({\n  parent: rule.parent\n}), rule => rule);\n\nfunction buildUtilityMap(css, lookupTree) {\n  let index = 0;\n  const utilityMap = {};\n\n  function handle(getRule, rule) {\n    const utilityNames = extractUtilityNames(rule.selector);\n    utilityNames.forEach((utilityName, i) => {\n      if (utilityMap[utilityName] === undefined) {\n        utilityMap[utilityName] = [];\n      }\n\n      utilityMap[utilityName].push({\n        index,\n        utilityName,\n        classPosition: i,\n        ...getRule(rule)\n      });\n      index++;\n    });\n  } // Lookup tree is the big lookup tree, making the rule lazy allows us to save\n  // some memory because we don't need everything.\n\n\n  lookupTree.walkRules(handle.bind(null, rule => ({\n    get rule() {\n      return cloneRuleWithParent(rule);\n    }\n\n  }))); // This is the end user's css. This might contain rules that we want to\n  // apply. We want immediate copies of everything in case that we have user\n  // defined classes that are recursively applied. Down below we are modifying\n  // the rules directly. We could do a better solution where we keep track of a\n  // dependency tree, but that is a bit more complex. Might revisit later,\n  // we'll see how this turns out!\n\n  css.walkRules(handle.bind(null, rule => ({\n    rule: cloneRuleWithParent(rule)\n  })));\n  return utilityMap;\n}\n\nfunction mergeAdjacentRules(initialRule, rulesToInsert) {\n  let previousRule = initialRule;\n  rulesToInsert.forEach(toInsert => {\n    if (toInsert.type === 'rule' && previousRule.type === 'rule' && toInsert.selector === previousRule.selector) {\n      previousRule.append(toInsert.nodes);\n    } else if (toInsert.type === 'atrule' && previousRule.type === 'atrule' && toInsert.params === previousRule.params) {\n      const merged = mergeAdjacentRules(previousRule.nodes[previousRule.nodes.length - 1], toInsert.nodes);\n      previousRule.append(merged);\n    } else {\n      previousRule = toInsert;\n    }\n\n    toInsert.walk(n => {\n      if (n.nodes && n.nodes.length === 0) {\n        n.remove();\n      }\n    });\n  });\n  return rulesToInsert.filter(r => r.nodes.length > 0);\n}\n\nfunction makeExtractUtilityRules(css, lookupTree, config) {\n  const utilityMap = buildUtilityMap(css, lookupTree);\n  return function extractUtilityRules(utilityNames, rule) {\n    const combined = [];\n    utilityNames.forEach(utilityName => {\n      if (utilityMap[utilityName] === undefined) {\n        // Look for prefixed utility in case the user has goofed\n        const prefixedUtility = (0, _prefixSelector.default)(config.prefix, `.${utilityName}`).slice(1);\n\n        if (utilityMap[prefixedUtility] !== undefined) {\n          throw rule.error(`The \\`${utilityName}\\` class does not exist, but \\`${prefixedUtility}\\` does. Did you forget the prefix?`);\n        }\n\n        const suggestedClass = (0, _didyoumean.default)(utilityName, Object.keys(utilityMap));\n        const suggestionMessage = suggestedClass ? `, but \\`${suggestedClass}\\` does` : '';\n        throw rule.error(`The \\`${utilityName}\\` class does not exist${suggestionMessage}. If you're sure that \\`${utilityName}\\` exists, make sure that any \\`@import\\` statements are being properly processed before Tailwind CSS sees your CSS, as \\`@apply\\` can only be used for classes in the same CSS tree.`, {\n          word: utilityName\n        });\n      }\n\n      combined.push(...utilityMap[utilityName]);\n    });\n    return combined.sort((a, b) => a.index - b.index);\n  };\n}\n\nfunction findParent(rule, predicate) {\n  let parent = rule.parent;\n\n  while (parent) {\n    if (predicate(parent)) {\n      return parent;\n    }\n\n    parent = parent.parent;\n  }\n\n  throw new Error('No parent could be found');\n}\n\nfunction processApplyAtRules(css, lookupTree, config) {\n  const extractUtilityRules = makeExtractUtilityRules(css, lookupTree, config);\n\n  do {\n    css.walkAtRules('apply', applyRule => {\n      const parent = applyRule.parent; // Direct parent\n\n      const nearestParentRule = findParent(applyRule, r => r.type === 'rule');\n      const currentUtilityNames = extractUtilityNames(nearestParentRule.selector);\n\n      const [importantEntries, applyUtilityNames, important = importantEntries.length > 0] = _lodash.default.partition(applyRule.params.split(/[\\s\\t\\n]+/g), n => n === '!important');\n\n      if (_lodash.default.intersection(applyUtilityNames, currentUtilityNames).length > 0) {\n        const currentUtilityName = _lodash.default.intersection(applyUtilityNames, currentUtilityNames)[0];\n\n        throw parent.error(`You cannot \\`@apply\\` the \\`${currentUtilityName}\\` utility here because it creates a circular dependency.`);\n      } // Extract any post-apply declarations and re-insert them after apply rules\n\n\n      const afterRule = parent.clone({\n        raws: {}\n      });\n      afterRule.nodes = afterRule.nodes.slice(parent.index(applyRule) + 1);\n      parent.nodes = parent.nodes.slice(0, parent.index(applyRule) + 1); // Sort applys to match CSS source order\n\n      const applys = extractUtilityRules(applyUtilityNames, applyRule); // Get new rules with the utility portion of the selector replaced with the new selector\n\n      const rulesToInsert = [];\n      applys.forEach(nearestParentRule === parent ? util => rulesToInsert.push(generateRulesFromApply(util, parent.selectors)) : util => util.rule.nodes.forEach(n => afterRule.append(n.clone())));\n      rulesToInsert.forEach(rule => {\n        if (rule.type === 'atrule') {\n          rule.walkRules(rule => {\n            rule.__tailwind = { ...rule.__tailwind,\n              important\n            };\n          });\n        } else {\n          rule.__tailwind = { ...rule.__tailwind,\n            important\n          };\n        }\n      });\n\n      const {\n        nodes\n      } = _lodash.default.tap(_postcss.default.root({\n        nodes: rulesToInsert\n      }), root => {\n        root.walkDecls(d => {\n          d.important = important;\n        });\n      });\n\n      const mergedRules = mergeAdjacentRules(nearestParentRule, [...nodes, afterRule]);\n      applyRule.remove();\n      parent.after(mergedRules); // If the base rule has nothing in it (all applys were pseudo or responsive variants),\n      // remove the rule fuggit.\n\n      if (parent.nodes.length === 0) {\n        parent.remove();\n      }\n    }); // We already know that we have at least 1 @apply rule. Otherwise this\n    // function would not have been called. Therefore we can execute this code\n    // at least once. This also means that in the best case scenario we only\n    // call this 2 times, instead of 3 times.\n    // 1st time -> before we call this function\n    // 2nd time -> when we check if we have to do this loop again (because do {} while (check))\n    // .. instead of\n    // 1st time -> before we call this function\n    // 2nd time -> when we check the first time (because while (check) do {})\n    // 3rd time -> when we re-check to see if we should do this loop again\n  } while (hasAtRule(css, 'apply'));\n\n  return css;\n}\n\nlet defaultTailwindTree = new Map();\n\nfunction substituteClassApplyAtRules(config, getProcessedPlugins, configChanged) {\n  return function (css) {\n    // We can stop already when we don't have any @apply rules. Vue users: you're welcome!\n    if (!hasAtRule(css, 'apply')) {\n      return css;\n    }\n\n    let requiredTailwindAtRules = ['base', 'components', 'utilities'];\n\n    if (hasAtRule(css, 'tailwind', node => {\n      let idx = requiredTailwindAtRules.indexOf(node.params);\n      if (idx !== -1) requiredTailwindAtRules.splice(idx, 1);\n      if (requiredTailwindAtRules.length <= 0) return true;\n      return false;\n    })) {\n      // Tree already contains all the at rules (requiredTailwindAtRules)\n      return processApplyAtRules(css, _postcss.default.root(), config);\n    }\n\n    let lookupKey = requiredTailwindAtRules.join(','); // We mutated the `requiredTailwindAtRules`, but when we hit this point in\n    // time, it means that we don't have all the atrules. The missing atrules\n    // are listed inside the requiredTailwindAtRules, which we can use to fill\n    // in the missing pieces.\n    //\n    // Important for <style> blocks in Vue components.\n\n    const generateLookupTree = configChanged || !defaultTailwindTree.has(lookupKey) ? () => {\n      return (0, _postcss.default)([(0, _substituteTailwindAtRules.default)(config, getProcessedPlugins()), (0, _evaluateTailwindFunctions.default)(config), (0, _substituteVariantsAtRules.default)(config, getProcessedPlugins()), (0, _substituteResponsiveAtRules.default)(config), (0, _convertLayerAtRulesToControlComments.default)(config), (0, _substituteScreenAtRules.default)(config)]).process(requiredTailwindAtRules.map(rule => `@tailwind ${rule};`).join('\\n'), {\n        from: __filename\n      }).then(result => {\n        defaultTailwindTree.set(lookupKey, result);\n        return result;\n      });\n    } : () => Promise.resolve(defaultTailwindTree.get(lookupKey));\n    return generateLookupTree().then(result => {\n      return processApplyAtRules(css, result.root, config);\n    });\n  };\n}","map":{"version":3,"sources":["/Users/seito/Documents/develop/count-jp/my-app/node_modules/tailwindcss/lib/lib/substituteClassApplyAtRules.js"],"names":["Object","defineProperty","exports","value","default","substituteClassApplyAtRules","_lodash","_interopRequireDefault","require","_postcssSelectorParser","_postcss","_didyoumean","_substituteTailwindAtRules","_evaluateTailwindFunctions","_substituteVariantsAtRules","_substituteResponsiveAtRules","_convertLayerAtRulesToControlComments","_substituteScreenAtRules","_prefixSelector","_useMemo","obj","__esModule","hasAtRule","css","atRule","condition","found","walkAtRules","undefined","node","cloneWithoutChildren","type","name","params","rule","selectors","clone","removeAll","tailwindApplyPlaceholder","attribute","generateRulesFromApply","utilityName","className","classPosition","replaceWiths","parser","i","walkClasses","c","replaceWith","processedSelectors","flatMap","selector","map","processSync","replace","cloned","current","parent","parentClone","append","extractUtilityNamesParser","classes","push","extractUtilityNames","useMemo","transformSync","cloneRuleWithParent","buildUtilityMap","lookupTree","index","utilityMap","handle","getRule","utilityNames","forEach","walkRules","bind","mergeAdjacentRules","initialRule","rulesToInsert","previousRule","toInsert","nodes","merged","length","walk","n","remove","filter","r","makeExtractUtilityRules","config","extractUtilityRules","combined","prefixedUtility","prefix","slice","error","suggestedClass","keys","suggestionMessage","word","sort","a","b","findParent","predicate","Error","processApplyAtRules","applyRule","nearestParentRule","currentUtilityNames","importantEntries","applyUtilityNames","important","partition","split","intersection","currentUtilityName","afterRule","raws","applys","util","__tailwind","tap","root","walkDecls","d","mergedRules","after","defaultTailwindTree","Map","getProcessedPlugins","configChanged","requiredTailwindAtRules","idx","indexOf","splice","lookupKey","join","generateLookupTree","has","process","from","__filename","then","result","set","Promise","resolve","get"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = substituteClassApplyAtRules;\n\nvar _lodash = _interopRequireDefault(require(\"lodash\"));\n\nvar _postcssSelectorParser = _interopRequireDefault(require(\"postcss-selector-parser\"));\n\nvar _postcss = _interopRequireDefault(require(\"postcss\"));\n\nvar _didyoumean = _interopRequireDefault(require(\"didyoumean\"));\n\nvar _substituteTailwindAtRules = _interopRequireDefault(require(\"./substituteTailwindAtRules\"));\n\nvar _evaluateTailwindFunctions = _interopRequireDefault(require(\"./evaluateTailwindFunctions\"));\n\nvar _substituteVariantsAtRules = _interopRequireDefault(require(\"./substituteVariantsAtRules\"));\n\nvar _substituteResponsiveAtRules = _interopRequireDefault(require(\"./substituteResponsiveAtRules\"));\n\nvar _convertLayerAtRulesToControlComments = _interopRequireDefault(require(\"./convertLayerAtRulesToControlComments\"));\n\nvar _substituteScreenAtRules = _interopRequireDefault(require(\"./substituteScreenAtRules\"));\n\nvar _prefixSelector = _interopRequireDefault(require(\"../util/prefixSelector\"));\n\nvar _useMemo = require(\"../util/useMemo\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction hasAtRule(css, atRule, condition) {\n  let found = false;\n  css.walkAtRules(atRule, condition === undefined ? () => {\n    found = true;\n    return false;\n  } : node => {\n    if (condition(node)) {\n      found = true;\n      return false;\n    }\n  });\n  return found;\n}\n\nfunction cloneWithoutChildren(node) {\n  if (node.type === 'atrule') {\n    return _postcss.default.atRule({\n      name: node.name,\n      params: node.params\n    });\n  }\n\n  if (node.type === 'rule') {\n    return _postcss.default.rule({\n      name: node.name,\n      selectors: node.selectors\n    });\n  }\n\n  const clone = node.clone();\n  clone.removeAll();\n  return clone;\n}\n\nconst tailwindApplyPlaceholder = _postcssSelectorParser.default.attribute({\n  attribute: '__TAILWIND-APPLY-PLACEHOLDER__'\n});\n\nfunction generateRulesFromApply({\n  rule,\n  utilityName: className,\n  classPosition\n}, replaceWiths) {\n  const parser = (0, _postcssSelectorParser.default)(selectors => {\n    let i = 0;\n    selectors.walkClasses(c => {\n      if (classPosition === i++ && c.value === className) {\n        c.replaceWith(tailwindApplyPlaceholder);\n      }\n    });\n  });\n\n  const processedSelectors = _lodash.default.flatMap(rule.selectors, selector => {\n    // You could argue we should make this replacement at the AST level, but if we believe\n    // the placeholder string is safe from collisions then it is safe to do this is a simple\n    // string replacement, and much, much faster.\n    return replaceWiths.map(replaceWith => parser.processSync(selector).replace('[__TAILWIND-APPLY-PLACEHOLDER__]', replaceWith));\n  });\n\n  const cloned = rule.clone();\n  let current = cloned;\n  let parent = rule.parent;\n\n  while (parent && parent.type !== 'root') {\n    const parentClone = cloneWithoutChildren(parent);\n    parentClone.append(current);\n    current.parent = parentClone;\n    current = parentClone;\n    parent = parent.parent;\n  }\n\n  cloned.selectors = processedSelectors;\n  return current;\n}\n\nconst extractUtilityNamesParser = (0, _postcssSelectorParser.default)(selectors => {\n  let classes = [];\n  selectors.walkClasses(c => classes.push(c.value));\n  return classes;\n});\nconst extractUtilityNames = (0, _useMemo.useMemo)(selector => extractUtilityNamesParser.transformSync(selector), selector => selector);\nconst cloneRuleWithParent = (0, _useMemo.useMemo)(rule => rule.clone({\n  parent: rule.parent\n}), rule => rule);\n\nfunction buildUtilityMap(css, lookupTree) {\n  let index = 0;\n  const utilityMap = {};\n\n  function handle(getRule, rule) {\n    const utilityNames = extractUtilityNames(rule.selector);\n    utilityNames.forEach((utilityName, i) => {\n      if (utilityMap[utilityName] === undefined) {\n        utilityMap[utilityName] = [];\n      }\n\n      utilityMap[utilityName].push({\n        index,\n        utilityName,\n        classPosition: i,\n        ...getRule(rule)\n      });\n      index++;\n    });\n  } // Lookup tree is the big lookup tree, making the rule lazy allows us to save\n  // some memory because we don't need everything.\n\n\n  lookupTree.walkRules(handle.bind(null, rule => ({\n    get rule() {\n      return cloneRuleWithParent(rule);\n    }\n\n  }))); // This is the end user's css. This might contain rules that we want to\n  // apply. We want immediate copies of everything in case that we have user\n  // defined classes that are recursively applied. Down below we are modifying\n  // the rules directly. We could do a better solution where we keep track of a\n  // dependency tree, but that is a bit more complex. Might revisit later,\n  // we'll see how this turns out!\n\n  css.walkRules(handle.bind(null, rule => ({\n    rule: cloneRuleWithParent(rule)\n  })));\n  return utilityMap;\n}\n\nfunction mergeAdjacentRules(initialRule, rulesToInsert) {\n  let previousRule = initialRule;\n  rulesToInsert.forEach(toInsert => {\n    if (toInsert.type === 'rule' && previousRule.type === 'rule' && toInsert.selector === previousRule.selector) {\n      previousRule.append(toInsert.nodes);\n    } else if (toInsert.type === 'atrule' && previousRule.type === 'atrule' && toInsert.params === previousRule.params) {\n      const merged = mergeAdjacentRules(previousRule.nodes[previousRule.nodes.length - 1], toInsert.nodes);\n      previousRule.append(merged);\n    } else {\n      previousRule = toInsert;\n    }\n\n    toInsert.walk(n => {\n      if (n.nodes && n.nodes.length === 0) {\n        n.remove();\n      }\n    });\n  });\n  return rulesToInsert.filter(r => r.nodes.length > 0);\n}\n\nfunction makeExtractUtilityRules(css, lookupTree, config) {\n  const utilityMap = buildUtilityMap(css, lookupTree);\n  return function extractUtilityRules(utilityNames, rule) {\n    const combined = [];\n    utilityNames.forEach(utilityName => {\n      if (utilityMap[utilityName] === undefined) {\n        // Look for prefixed utility in case the user has goofed\n        const prefixedUtility = (0, _prefixSelector.default)(config.prefix, `.${utilityName}`).slice(1);\n\n        if (utilityMap[prefixedUtility] !== undefined) {\n          throw rule.error(`The \\`${utilityName}\\` class does not exist, but \\`${prefixedUtility}\\` does. Did you forget the prefix?`);\n        }\n\n        const suggestedClass = (0, _didyoumean.default)(utilityName, Object.keys(utilityMap));\n        const suggestionMessage = suggestedClass ? `, but \\`${suggestedClass}\\` does` : '';\n        throw rule.error(`The \\`${utilityName}\\` class does not exist${suggestionMessage}. If you're sure that \\`${utilityName}\\` exists, make sure that any \\`@import\\` statements are being properly processed before Tailwind CSS sees your CSS, as \\`@apply\\` can only be used for classes in the same CSS tree.`, {\n          word: utilityName\n        });\n      }\n\n      combined.push(...utilityMap[utilityName]);\n    });\n    return combined.sort((a, b) => a.index - b.index);\n  };\n}\n\nfunction findParent(rule, predicate) {\n  let parent = rule.parent;\n\n  while (parent) {\n    if (predicate(parent)) {\n      return parent;\n    }\n\n    parent = parent.parent;\n  }\n\n  throw new Error('No parent could be found');\n}\n\nfunction processApplyAtRules(css, lookupTree, config) {\n  const extractUtilityRules = makeExtractUtilityRules(css, lookupTree, config);\n\n  do {\n    css.walkAtRules('apply', applyRule => {\n      const parent = applyRule.parent; // Direct parent\n\n      const nearestParentRule = findParent(applyRule, r => r.type === 'rule');\n      const currentUtilityNames = extractUtilityNames(nearestParentRule.selector);\n\n      const [importantEntries, applyUtilityNames, important = importantEntries.length > 0] = _lodash.default.partition(applyRule.params.split(/[\\s\\t\\n]+/g), n => n === '!important');\n\n      if (_lodash.default.intersection(applyUtilityNames, currentUtilityNames).length > 0) {\n        const currentUtilityName = _lodash.default.intersection(applyUtilityNames, currentUtilityNames)[0];\n\n        throw parent.error(`You cannot \\`@apply\\` the \\`${currentUtilityName}\\` utility here because it creates a circular dependency.`);\n      } // Extract any post-apply declarations and re-insert them after apply rules\n\n\n      const afterRule = parent.clone({\n        raws: {}\n      });\n      afterRule.nodes = afterRule.nodes.slice(parent.index(applyRule) + 1);\n      parent.nodes = parent.nodes.slice(0, parent.index(applyRule) + 1); // Sort applys to match CSS source order\n\n      const applys = extractUtilityRules(applyUtilityNames, applyRule); // Get new rules with the utility portion of the selector replaced with the new selector\n\n      const rulesToInsert = [];\n      applys.forEach(nearestParentRule === parent ? util => rulesToInsert.push(generateRulesFromApply(util, parent.selectors)) : util => util.rule.nodes.forEach(n => afterRule.append(n.clone())));\n      rulesToInsert.forEach(rule => {\n        if (rule.type === 'atrule') {\n          rule.walkRules(rule => {\n            rule.__tailwind = { ...rule.__tailwind,\n              important\n            };\n          });\n        } else {\n          rule.__tailwind = { ...rule.__tailwind,\n            important\n          };\n        }\n      });\n\n      const {\n        nodes\n      } = _lodash.default.tap(_postcss.default.root({\n        nodes: rulesToInsert\n      }), root => {\n        root.walkDecls(d => {\n          d.important = important;\n        });\n      });\n\n      const mergedRules = mergeAdjacentRules(nearestParentRule, [...nodes, afterRule]);\n      applyRule.remove();\n      parent.after(mergedRules); // If the base rule has nothing in it (all applys were pseudo or responsive variants),\n      // remove the rule fuggit.\n\n      if (parent.nodes.length === 0) {\n        parent.remove();\n      }\n    }); // We already know that we have at least 1 @apply rule. Otherwise this\n    // function would not have been called. Therefore we can execute this code\n    // at least once. This also means that in the best case scenario we only\n    // call this 2 times, instead of 3 times.\n    // 1st time -> before we call this function\n    // 2nd time -> when we check if we have to do this loop again (because do {} while (check))\n    // .. instead of\n    // 1st time -> before we call this function\n    // 2nd time -> when we check the first time (because while (check) do {})\n    // 3rd time -> when we re-check to see if we should do this loop again\n  } while (hasAtRule(css, 'apply'));\n\n  return css;\n}\n\nlet defaultTailwindTree = new Map();\n\nfunction substituteClassApplyAtRules(config, getProcessedPlugins, configChanged) {\n  return function (css) {\n    // We can stop already when we don't have any @apply rules. Vue users: you're welcome!\n    if (!hasAtRule(css, 'apply')) {\n      return css;\n    }\n\n    let requiredTailwindAtRules = ['base', 'components', 'utilities'];\n\n    if (hasAtRule(css, 'tailwind', node => {\n      let idx = requiredTailwindAtRules.indexOf(node.params);\n      if (idx !== -1) requiredTailwindAtRules.splice(idx, 1);\n      if (requiredTailwindAtRules.length <= 0) return true;\n      return false;\n    })) {\n      // Tree already contains all the at rules (requiredTailwindAtRules)\n      return processApplyAtRules(css, _postcss.default.root(), config);\n    }\n\n    let lookupKey = requiredTailwindAtRules.join(','); // We mutated the `requiredTailwindAtRules`, but when we hit this point in\n    // time, it means that we don't have all the atrules. The missing atrules\n    // are listed inside the requiredTailwindAtRules, which we can use to fill\n    // in the missing pieces.\n    //\n    // Important for <style> blocks in Vue components.\n\n    const generateLookupTree = configChanged || !defaultTailwindTree.has(lookupKey) ? () => {\n      return (0, _postcss.default)([(0, _substituteTailwindAtRules.default)(config, getProcessedPlugins()), (0, _evaluateTailwindFunctions.default)(config), (0, _substituteVariantsAtRules.default)(config, getProcessedPlugins()), (0, _substituteResponsiveAtRules.default)(config), (0, _convertLayerAtRulesToControlComments.default)(config), (0, _substituteScreenAtRules.default)(config)]).process(requiredTailwindAtRules.map(rule => `@tailwind ${rule};`).join('\\n'), {\n        from: __filename\n      }).then(result => {\n        defaultTailwindTree.set(lookupKey, result);\n        return result;\n      });\n    } : () => Promise.resolve(defaultTailwindTree.get(lookupKey));\n    return generateLookupTree().then(result => {\n      return processApplyAtRules(css, result.root, config);\n    });\n  };\n}"]},"metadata":{},"sourceType":"script"}