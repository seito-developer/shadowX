{"ast":null,"code":"const postcss = require('postcss');\n\nconst {\n  resolveMatches\n} = require('./generateRules');\n\nconst {\n  bigSign,\n  escapeClassName\n} = require('./utils');\n\nfunction buildApplyCache(applyCandidates, context) {\n  for (let candidate of applyCandidates) {\n    if (context.notClassCache.has(candidate) || context.applyClassCache.has(candidate)) {\n      continue;\n    }\n\n    if (context.classCache.has(candidate)) {\n      context.applyClassCache.set(candidate, context.classCache.get(candidate).map(([meta, rule]) => [meta, rule.clone()]));\n      continue;\n    }\n\n    let matches = Array.from(resolveMatches(candidate, context));\n\n    if (matches.length === 0) {\n      context.notClassCache.add(candidate);\n      continue;\n    }\n\n    context.applyClassCache.set(candidate, matches);\n  }\n\n  return context.applyClassCache;\n} // TODO: Apply `!important` stuff correctly instead of just skipping it\n\n\nfunction extractApplyCandidates(params) {\n  let candidates = params.split(/[\\s\\t\\n]+/g);\n\n  if (candidates[candidates.length - 1] === '!important') {\n    return [candidates.slice(0, -1), true];\n  }\n\n  return [candidates, false];\n}\n\nfunction partitionApplyParents(root) {\n  let applyParents = new Set();\n  root.walkAtRules('apply', rule => {\n    applyParents.add(rule.parent);\n  });\n\n  for (let rule of applyParents) {\n    let nodeGroups = [];\n    let lastGroup = [];\n\n    for (let node of rule.nodes) {\n      if (node.type === 'atrule' && node.name === 'apply') {\n        if (lastGroup.length > 0) {\n          nodeGroups.push(lastGroup);\n          lastGroup = [];\n        }\n\n        nodeGroups.push([node]);\n      } else {\n        lastGroup.push(node);\n      }\n    }\n\n    if (lastGroup.length > 0) {\n      nodeGroups.push(lastGroup);\n    }\n\n    if (nodeGroups.length === 1) {\n      continue;\n    }\n\n    for (let group of [...nodeGroups].reverse()) {\n      let newParent = rule.clone({\n        nodes: []\n      });\n      newParent.append(group);\n      rule.after(newParent);\n    }\n\n    rule.remove();\n  }\n}\n\nfunction processApply(root, context) {\n  let applyCandidates = new Set(); // Collect all @apply rules and candidates\n\n  let applies = [];\n  root.walkAtRules('apply', rule => {\n    let [candidates] = extractApplyCandidates(rule.params);\n\n    for (let util of candidates) {\n      applyCandidates.add(util);\n    }\n\n    applies.push(rule);\n  }); // Start the @apply process if we have rules with @apply in them\n\n  if (applies.length > 0) {\n    // Fill up some caches!\n    let applyClassCache = buildApplyCache(applyCandidates, context);\n    /**\n     * When we have an apply like this:\n     *\n     * .abc {\n     *    @apply hover:font-bold;\n     * }\n     *\n     * What we essentially will do is resolve to this:\n     *\n     * .abc {\n     *    @apply .hover\\:font-bold:hover {\n     *      font-weight: 500;\n     *    }\n     * }\n     *\n     * Notice that the to-be-applied class is `.hover\\:font-bold:hover` and that the utility candidate was `hover:font-bold`.\n     * What happens in this function is that we prepend a `.` and escape the candidate.\n     * This will result in `.hover\\:font-bold`\n     * Which means that we can replace `.hover\\:font-bold` with `.abc` in `.hover\\:font-bold:hover` resulting in `.abc:hover`\n     */\n    // TODO: Should we use postcss-selector-parser for this instead?\n\n    function replaceSelector(selector, utilitySelectors, candidate) {\n      let needle = `.${escapeClassName(candidate)}`;\n      let utilitySelectorsList = utilitySelectors.split(/\\s*,\\s*/g);\n      return selector.split(/\\s*,\\s*/g).map(s => {\n        let replaced = [];\n\n        for (let utilitySelector of utilitySelectorsList) {\n          let replacedSelector = utilitySelector.replace(needle, s);\n\n          if (replacedSelector === utilitySelector) {\n            continue;\n          }\n\n          replaced.push(replacedSelector);\n        }\n\n        return replaced.join(', ');\n      }).join(', ');\n    }\n    /** @type {Map<import('postcss').Node, [string, boolean, import('postcss').Node[]][]>} */\n\n\n    let perParentApplies = new Map(); // Collect all apply candidates and their rules\n\n    for (let apply of applies) {\n      let candidates = perParentApplies.get(apply.parent) || [];\n      perParentApplies.set(apply.parent, candidates);\n      let [applyCandidates, important] = extractApplyCandidates(apply.params);\n\n      if (apply.parent.type === 'atrule') {\n        if (apply.parent.name === 'screen') {\n          const screenType = apply.parent.params;\n          throw apply.error(`@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply ${applyCandidates.map(c => `${screenType}:${c}`).join(' ')} instead.`);\n        }\n\n        throw apply.error(`@apply is not supported within nested at-rules like @${apply.parent.name}. You can fix this by un-nesting @${apply.parent.name}.`);\n      }\n\n      for (let applyCandidate of applyCandidates) {\n        if (!applyClassCache.has(applyCandidate)) {\n          throw apply.error(`The \\`${applyCandidate}\\` class does not exist. If \\`${applyCandidate}\\` is a custom class, make sure it is defined within a \\`@layer\\` directive.`);\n        }\n\n        let rules = applyClassCache.get(applyCandidate);\n        candidates.push([applyCandidate, important, rules]);\n      }\n    }\n\n    for (const [parent, candidates] of perParentApplies) {\n      let siblings = [];\n\n      for (let [applyCandidate, important, rules] of candidates) {\n        for (let [meta, node] of rules) {\n          let root = postcss.root({\n            nodes: [node.clone()]\n          });\n          let canRewriteSelector = node.type !== 'atrule' || node.type === 'atrule' && node.name !== 'keyframes';\n\n          if (canRewriteSelector) {\n            root.walkRules(rule => {\n              rule.selector = replaceSelector(parent.selector, rule.selector, applyCandidate);\n              rule.walkDecls(d => {\n                d.important = important;\n              });\n            });\n          }\n\n          siblings.push([meta, root.nodes[0]]);\n        }\n      } // Inject the rules, sorted, correctly\n\n\n      let nodes = siblings.sort(([a], [z]) => bigSign(a.sort - z.sort)).map(s => s[1]); // console.log(parent)\n      // `parent` refers to the node at `.abc` in: .abc { @apply mt-2 }\n\n      parent.after(nodes);\n    }\n\n    for (let apply of applies) {\n      // If there are left-over declarations, just remove the @apply\n      if (apply.parent.nodes.length > 1) {\n        apply.remove();\n      } else {\n        // The node is empty, drop the full node\n        apply.parent.remove();\n      }\n    } // Do it again, in case we have other `@apply` rules\n\n\n    processApply(root, context);\n  }\n}\n\nfunction expandApplyAtRules(context) {\n  return root => {\n    partitionApplyParents(root);\n    processApply(root, context);\n  };\n}\n\nmodule.exports = expandApplyAtRules;","map":{"version":3,"sources":["/Users/seito/Documents/develop/count-jp/my-app/node_modules/tailwindcss/jit/lib/expandApplyAtRules.js"],"names":["postcss","require","resolveMatches","bigSign","escapeClassName","buildApplyCache","applyCandidates","context","candidate","notClassCache","has","applyClassCache","classCache","set","get","map","meta","rule","clone","matches","Array","from","length","add","extractApplyCandidates","params","candidates","split","slice","partitionApplyParents","root","applyParents","Set","walkAtRules","parent","nodeGroups","lastGroup","node","nodes","type","name","push","group","reverse","newParent","append","after","remove","processApply","applies","util","replaceSelector","selector","utilitySelectors","needle","utilitySelectorsList","s","replaced","utilitySelector","replacedSelector","replace","join","perParentApplies","Map","apply","important","screenType","error","c","applyCandidate","rules","siblings","canRewriteSelector","walkRules","walkDecls","d","sort","a","z","expandApplyAtRules","module","exports"],"mappings":"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","sourcesContent":["const postcss = require('postcss')\nconst { resolveMatches } = require('./generateRules')\nconst { bigSign, escapeClassName } = require('./utils')\n\nfunction buildApplyCache(applyCandidates, context) {\n  for (let candidate of applyCandidates) {\n    if (context.notClassCache.has(candidate) || context.applyClassCache.has(candidate)) {\n      continue\n    }\n\n    if (context.classCache.has(candidate)) {\n      context.applyClassCache.set(\n        candidate,\n        context.classCache.get(candidate).map(([meta, rule]) => [meta, rule.clone()])\n      )\n      continue\n    }\n\n    let matches = Array.from(resolveMatches(candidate, context))\n\n    if (matches.length === 0) {\n      context.notClassCache.add(candidate)\n      continue\n    }\n\n    context.applyClassCache.set(candidate, matches)\n  }\n\n  return context.applyClassCache\n}\n\n// TODO: Apply `!important` stuff correctly instead of just skipping it\nfunction extractApplyCandidates(params) {\n  let candidates = params.split(/[\\s\\t\\n]+/g)\n\n  if (candidates[candidates.length - 1] === '!important') {\n    return [candidates.slice(0, -1), true]\n  }\n\n  return [candidates, false]\n}\n\nfunction partitionApplyParents(root) {\n  let applyParents = new Set()\n\n  root.walkAtRules('apply', (rule) => {\n    applyParents.add(rule.parent)\n  })\n\n  for (let rule of applyParents) {\n    let nodeGroups = []\n    let lastGroup = []\n\n    for (let node of rule.nodes) {\n      if (node.type === 'atrule' && node.name === 'apply') {\n        if (lastGroup.length > 0) {\n          nodeGroups.push(lastGroup)\n          lastGroup = []\n        }\n        nodeGroups.push([node])\n      } else {\n        lastGroup.push(node)\n      }\n    }\n\n    if (lastGroup.length > 0) {\n      nodeGroups.push(lastGroup)\n    }\n\n    if (nodeGroups.length === 1) {\n      continue\n    }\n\n    for (let group of [...nodeGroups].reverse()) {\n      let newParent = rule.clone({ nodes: [] })\n      newParent.append(group)\n      rule.after(newParent)\n    }\n\n    rule.remove()\n  }\n}\n\nfunction processApply(root, context) {\n  let applyCandidates = new Set()\n\n  // Collect all @apply rules and candidates\n  let applies = []\n  root.walkAtRules('apply', (rule) => {\n    let [candidates] = extractApplyCandidates(rule.params)\n\n    for (let util of candidates) {\n      applyCandidates.add(util)\n    }\n    applies.push(rule)\n  })\n\n  // Start the @apply process if we have rules with @apply in them\n  if (applies.length > 0) {\n    // Fill up some caches!\n    let applyClassCache = buildApplyCache(applyCandidates, context)\n\n    /**\n     * When we have an apply like this:\n     *\n     * .abc {\n     *    @apply hover:font-bold;\n     * }\n     *\n     * What we essentially will do is resolve to this:\n     *\n     * .abc {\n     *    @apply .hover\\:font-bold:hover {\n     *      font-weight: 500;\n     *    }\n     * }\n     *\n     * Notice that the to-be-applied class is `.hover\\:font-bold:hover` and that the utility candidate was `hover:font-bold`.\n     * What happens in this function is that we prepend a `.` and escape the candidate.\n     * This will result in `.hover\\:font-bold`\n     * Which means that we can replace `.hover\\:font-bold` with `.abc` in `.hover\\:font-bold:hover` resulting in `.abc:hover`\n     */\n    // TODO: Should we use postcss-selector-parser for this instead?\n    function replaceSelector(selector, utilitySelectors, candidate) {\n      let needle = `.${escapeClassName(candidate)}`\n      let utilitySelectorsList = utilitySelectors.split(/\\s*,\\s*/g)\n\n      return selector\n        .split(/\\s*,\\s*/g)\n        .map((s) => {\n          let replaced = []\n\n          for (let utilitySelector of utilitySelectorsList) {\n            let replacedSelector = utilitySelector.replace(needle, s)\n            if (replacedSelector === utilitySelector) {\n              continue\n            }\n            replaced.push(replacedSelector)\n          }\n          return replaced.join(', ')\n        })\n        .join(', ')\n    }\n\n    /** @type {Map<import('postcss').Node, [string, boolean, import('postcss').Node[]][]>} */\n    let perParentApplies = new Map()\n\n    // Collect all apply candidates and their rules\n    for (let apply of applies) {\n      let candidates = perParentApplies.get(apply.parent) || []\n\n      perParentApplies.set(apply.parent, candidates)\n\n      let [applyCandidates, important] = extractApplyCandidates(apply.params)\n\n      if (apply.parent.type === 'atrule') {\n        if (apply.parent.name === 'screen') {\n          const screenType = apply.parent.params\n\n          throw apply.error(\n            `@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply ${applyCandidates\n              .map((c) => `${screenType}:${c}`)\n              .join(' ')} instead.`\n          )\n        }\n\n        throw apply.error(\n          `@apply is not supported within nested at-rules like @${apply.parent.name}. You can fix this by un-nesting @${apply.parent.name}.`\n        )\n      }\n\n      for (let applyCandidate of applyCandidates) {\n        if (!applyClassCache.has(applyCandidate)) {\n          throw apply.error(\n            `The \\`${applyCandidate}\\` class does not exist. If \\`${applyCandidate}\\` is a custom class, make sure it is defined within a \\`@layer\\` directive.`\n          )\n        }\n\n        let rules = applyClassCache.get(applyCandidate)\n\n        candidates.push([applyCandidate, important, rules])\n      }\n    }\n\n    for (const [parent, candidates] of perParentApplies) {\n      let siblings = []\n\n      for (let [applyCandidate, important, rules] of candidates) {\n        for (let [meta, node] of rules) {\n          let root = postcss.root({ nodes: [node.clone()] })\n          let canRewriteSelector =\n            node.type !== 'atrule' || (node.type === 'atrule' && node.name !== 'keyframes')\n\n          if (canRewriteSelector) {\n            root.walkRules((rule) => {\n              rule.selector = replaceSelector(parent.selector, rule.selector, applyCandidate)\n\n              rule.walkDecls((d) => {\n                d.important = important\n              })\n            })\n          }\n\n          siblings.push([meta, root.nodes[0]])\n        }\n      }\n\n      // Inject the rules, sorted, correctly\n      let nodes = siblings.sort(([a], [z]) => bigSign(a.sort - z.sort)).map((s) => s[1])\n\n      // console.log(parent)\n      // `parent` refers to the node at `.abc` in: .abc { @apply mt-2 }\n      parent.after(nodes)\n    }\n\n    for (let apply of applies) {\n      // If there are left-over declarations, just remove the @apply\n      if (apply.parent.nodes.length > 1) {\n        apply.remove()\n      } else {\n        // The node is empty, drop the full node\n        apply.parent.remove()\n      }\n    }\n\n    // Do it again, in case we have other `@apply` rules\n    processApply(root, context)\n  }\n}\n\nfunction expandApplyAtRules(context) {\n  return (root) => {\n    partitionApplyParents(root)\n    processApply(root, context)\n  }\n}\n\nmodule.exports = expandApplyAtRules\n"]},"metadata":{},"sourceType":"script"}