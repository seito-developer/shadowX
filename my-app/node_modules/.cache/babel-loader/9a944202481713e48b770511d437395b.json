{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _declaration = require('./declaration');\n\nvar _declaration2 = _interopRequireDefault(_declaration);\n\nvar _comment = require('./comment');\n\nvar _comment2 = _interopRequireDefault(_comment);\n\nvar _node = require('./node');\n\nvar _node2 = _interopRequireDefault(_node);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nfunction cleanSource(nodes) {\n  return nodes.map(function (i) {\n    if (i.nodes) i.nodes = cleanSource(i.nodes);\n    delete i.source;\n    return i;\n  });\n}\n/**\n * The {@link Root}, {@link AtRule}, and {@link Rule} container nodes\n * inherit some common methods to help work with their children.\n *\n * Note that all containers can store any content. If you write a rule inside\n * a rule, PostCSS will parse it.\n *\n * @extends Node\n * @abstract\n */\n\n\nvar Container = function (_Node) {\n  _inherits(Container, _Node);\n\n  function Container() {\n    _classCallCheck(this, Container);\n\n    return _possibleConstructorReturn(this, _Node.apply(this, arguments));\n  }\n\n  Container.prototype.push = function push(child) {\n    child.parent = this;\n    this.nodes.push(child);\n    return this;\n  };\n  /**\n   * Iterates through the container’s immediate children,\n   * calling `callback` for each child.\n   *\n   * Returning `false` in the callback will break iteration.\n   *\n   * This method only iterates through the container’s immediate children.\n   * If you need to recursively iterate through all the container’s descendant\n   * nodes, use {@link Container#walk}.\n   *\n   * Unlike the for `{}`-cycle or `Array#forEach` this iterator is safe\n   * if you are mutating the array of child nodes during iteration.\n   * PostCSS will adjust the current index to match the mutations.\n   *\n   * @param {childIterator} callback - iterator receives each node and index\n   *\n   * @return {false|undefined} returns `false` if iteration was broke\n   *\n   * @example\n   * const root = postcss.parse('a { color: black; z-index: 1 }');\n   * const rule = root.first;\n   *\n   * for ( let decl of rule.nodes ) {\n   *     decl.cloneBefore({ prop: '-webkit-' + decl.prop });\n   *     // Cycle will be infinite, because cloneBefore moves the current node\n   *     // to the next index\n   * }\n   *\n   * rule.each(decl => {\n   *     decl.cloneBefore({ prop: '-webkit-' + decl.prop });\n   *     // Will be executed only for color and z-index\n   * });\n   */\n\n\n  Container.prototype.each = function each(callback) {\n    if (!this.lastEach) this.lastEach = 0;\n    if (!this.indexes) this.indexes = {};\n    this.lastEach += 1;\n    var id = this.lastEach;\n    this.indexes[id] = 0;\n    if (!this.nodes) return undefined;\n    var index = void 0,\n        result = void 0;\n\n    while (this.indexes[id] < this.nodes.length) {\n      index = this.indexes[id];\n      result = callback(this.nodes[index], index);\n      if (result === false) break;\n      this.indexes[id] += 1;\n    }\n\n    delete this.indexes[id];\n    return result;\n  };\n  /**\n   * Traverses the container’s descendant nodes, calling callback\n   * for each node.\n   *\n   * Like container.each(), this method is safe to use\n   * if you are mutating arrays during iteration.\n   *\n   * If you only need to iterate through the container’s immediate children,\n   * use {@link Container#each}.\n   *\n   * @param {childIterator} callback - iterator receives each node and index\n   *\n   * @return {false|undefined} returns `false` if iteration was broke\n   *\n   * @example\n   * root.walk(node => {\n   *   // Traverses all descendant nodes.\n   * });\n   */\n\n\n  Container.prototype.walk = function walk(callback) {\n    return this.each(function (child, i) {\n      var result = callback(child, i);\n\n      if (result !== false && child.walk) {\n        result = child.walk(callback);\n      }\n\n      return result;\n    });\n  };\n  /**\n   * Traverses the container’s descendant nodes, calling callback\n   * for each declaration node.\n   *\n   * If you pass a filter, iteration will only happen over declarations\n   * with matching properties.\n   *\n   * Like {@link Container#each}, this method is safe\n   * to use if you are mutating arrays during iteration.\n   *\n   * @param {string|RegExp} [prop]   - string or regular expression\n   *                                   to filter declarations by property name\n   * @param {childIterator} callback - iterator receives each node and index\n   *\n   * @return {false|undefined} returns `false` if iteration was broke\n   *\n   * @example\n   * root.walkDecls(decl => {\n   *   checkPropertySupport(decl.prop);\n   * });\n   *\n   * root.walkDecls('border-radius', decl => {\n   *   decl.remove();\n   * });\n   *\n   * root.walkDecls(/^background/, decl => {\n   *   decl.value = takeFirstColorFromGradient(decl.value);\n   * });\n   */\n\n\n  Container.prototype.walkDecls = function walkDecls(prop, callback) {\n    if (!callback) {\n      callback = prop;\n      return this.walk(function (child, i) {\n        if (child.type === 'decl') {\n          return callback(child, i);\n        }\n      });\n    } else if (prop instanceof RegExp) {\n      return this.walk(function (child, i) {\n        if (child.type === 'decl' && prop.test(child.prop)) {\n          return callback(child, i);\n        }\n      });\n    } else {\n      return this.walk(function (child, i) {\n        if (child.type === 'decl' && child.prop === prop) {\n          return callback(child, i);\n        }\n      });\n    }\n  };\n  /**\n   * Traverses the container’s descendant nodes, calling callback\n   * for each rule node.\n   *\n   * If you pass a filter, iteration will only happen over rules\n   * with matching selectors.\n   *\n   * Like {@link Container#each}, this method is safe\n   * to use if you are mutating arrays during iteration.\n   *\n   * @param {string|RegExp} [selector] - string or regular expression\n   *                                     to filter rules by selector\n   * @param {childIterator} callback   - iterator receives each node and index\n   *\n   * @return {false|undefined} returns `false` if iteration was broke\n   *\n   * @example\n   * const selectors = [];\n   * root.walkRules(rule => {\n   *   selectors.push(rule.selector);\n   * });\n   * console.log(`Your CSS uses ${selectors.length} selectors`);\n   */\n\n\n  Container.prototype.walkRules = function walkRules(selector, callback) {\n    if (!callback) {\n      callback = selector;\n      return this.walk(function (child, i) {\n        if (child.type === 'rule') {\n          return callback(child, i);\n        }\n      });\n    } else if (selector instanceof RegExp) {\n      return this.walk(function (child, i) {\n        if (child.type === 'rule' && selector.test(child.selector)) {\n          return callback(child, i);\n        }\n      });\n    } else {\n      return this.walk(function (child, i) {\n        if (child.type === 'rule' && child.selector === selector) {\n          return callback(child, i);\n        }\n      });\n    }\n  };\n  /**\n   * Traverses the container’s descendant nodes, calling callback\n   * for each at-rule node.\n   *\n   * If you pass a filter, iteration will only happen over at-rules\n   * that have matching names.\n   *\n   * Like {@link Container#each}, this method is safe\n   * to use if you are mutating arrays during iteration.\n   *\n   * @param {string|RegExp} [name]   - string or regular expression\n   *                                   to filter at-rules by name\n   * @param {childIterator} callback - iterator receives each node and index\n   *\n   * @return {false|undefined} returns `false` if iteration was broke\n   *\n   * @example\n   * root.walkAtRules(rule => {\n   *   if ( isOld(rule.name) ) rule.remove();\n   * });\n   *\n   * let first = false;\n   * root.walkAtRules('charset', rule => {\n   *   if ( !first ) {\n   *     first = true;\n   *   } else {\n   *     rule.remove();\n   *   }\n   * });\n   */\n\n\n  Container.prototype.walkAtRules = function walkAtRules(name, callback) {\n    if (!callback) {\n      callback = name;\n      return this.walk(function (child, i) {\n        if (child.type === 'atrule') {\n          return callback(child, i);\n        }\n      });\n    } else if (name instanceof RegExp) {\n      return this.walk(function (child, i) {\n        if (child.type === 'atrule' && name.test(child.name)) {\n          return callback(child, i);\n        }\n      });\n    } else {\n      return this.walk(function (child, i) {\n        if (child.type === 'atrule' && child.name === name) {\n          return callback(child, i);\n        }\n      });\n    }\n  };\n  /**\n   * Traverses the container’s descendant nodes, calling callback\n   * for each comment node.\n   *\n   * Like {@link Container#each}, this method is safe\n   * to use if you are mutating arrays during iteration.\n   *\n   * @param {childIterator} callback - iterator receives each node and index\n   *\n   * @return {false|undefined} returns `false` if iteration was broke\n   *\n   * @example\n   * root.walkComments(comment => {\n   *   comment.remove();\n   * });\n   */\n\n\n  Container.prototype.walkComments = function walkComments(callback) {\n    return this.walk(function (child, i) {\n      if (child.type === 'comment') {\n        return callback(child, i);\n      }\n    });\n  };\n  /**\n   * Inserts new nodes to the end of the container.\n   *\n   * @param {...(Node|object|string|Node[])} children - new nodes\n   *\n   * @return {Node} this node for methods chain\n   *\n   * @example\n   * const decl1 = postcss.decl({ prop: 'color', value: 'black' });\n   * const decl2 = postcss.decl({ prop: 'background-color', value: 'white' });\n   * rule.append(decl1, decl2);\n   *\n   * root.append({ name: 'charset', params: '\"UTF-8\"' });  // at-rule\n   * root.append({ selector: 'a' });                       // rule\n   * rule.append({ prop: 'color', value: 'black' });       // declaration\n   * rule.append({ text: 'Comment' })                      // comment\n   *\n   * root.append('a {}');\n   * root.first.append('color: black; z-index: 1');\n   */\n\n\n  Container.prototype.append = function append() {\n    for (var _len = arguments.length, children = Array(_len), _key = 0; _key < _len; _key++) {\n      children[_key] = arguments[_key];\n    }\n\n    for (var _iterator = children, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var child = _ref;\n      var nodes = this.normalize(child, this.last);\n\n      for (var _iterator2 = nodes, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n        var _ref2;\n\n        if (_isArray2) {\n          if (_i2 >= _iterator2.length) break;\n          _ref2 = _iterator2[_i2++];\n        } else {\n          _i2 = _iterator2.next();\n          if (_i2.done) break;\n          _ref2 = _i2.value;\n        }\n\n        var node = _ref2;\n        this.nodes.push(node);\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Inserts new nodes to the start of the container.\n   *\n   * @param {...(Node|object|string|Node[])} children - new nodes\n   *\n   * @return {Node} this node for methods chain\n   *\n   * @example\n   * const decl1 = postcss.decl({ prop: 'color', value: 'black' });\n   * const decl2 = postcss.decl({ prop: 'background-color', value: 'white' });\n   * rule.prepend(decl1, decl2);\n   *\n   * root.append({ name: 'charset', params: '\"UTF-8\"' });  // at-rule\n   * root.append({ selector: 'a' });                       // rule\n   * rule.append({ prop: 'color', value: 'black' });       // declaration\n   * rule.append({ text: 'Comment' })                      // comment\n   *\n   * root.append('a {}');\n   * root.first.append('color: black; z-index: 1');\n   */\n\n\n  Container.prototype.prepend = function prepend() {\n    for (var _len2 = arguments.length, children = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      children[_key2] = arguments[_key2];\n    }\n\n    children = children.reverse();\n\n    for (var _iterator3 = children, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n      var _ref3;\n\n      if (_isArray3) {\n        if (_i3 >= _iterator3.length) break;\n        _ref3 = _iterator3[_i3++];\n      } else {\n        _i3 = _iterator3.next();\n        if (_i3.done) break;\n        _ref3 = _i3.value;\n      }\n\n      var child = _ref3;\n      var nodes = this.normalize(child, this.first, 'prepend').reverse();\n\n      for (var _iterator4 = nodes, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {\n        var _ref4;\n\n        if (_isArray4) {\n          if (_i4 >= _iterator4.length) break;\n          _ref4 = _iterator4[_i4++];\n        } else {\n          _i4 = _iterator4.next();\n          if (_i4.done) break;\n          _ref4 = _i4.value;\n        }\n\n        var node = _ref4;\n        this.nodes.unshift(node);\n      }\n\n      for (var id in this.indexes) {\n        this.indexes[id] = this.indexes[id] + nodes.length;\n      }\n    }\n\n    return this;\n  };\n\n  Container.prototype.cleanRaws = function cleanRaws(keepBetween) {\n    _Node.prototype.cleanRaws.call(this, keepBetween);\n\n    if (this.nodes) {\n      for (var _iterator5 = this.nodes, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {\n        var _ref5;\n\n        if (_isArray5) {\n          if (_i5 >= _iterator5.length) break;\n          _ref5 = _iterator5[_i5++];\n        } else {\n          _i5 = _iterator5.next();\n          if (_i5.done) break;\n          _ref5 = _i5.value;\n        }\n\n        var node = _ref5;\n        node.cleanRaws(keepBetween);\n      }\n    }\n  };\n  /**\n   * Insert new node before old node within the container.\n   *\n   * @param {Node|number} exist             - child or child’s index.\n   * @param {Node|object|string|Node[]} add - new node\n   *\n   * @return {Node} this node for methods chain\n   *\n   * @example\n   * rule.insertBefore(decl, decl.clone({ prop: '-webkit-' + decl.prop }));\n   */\n\n\n  Container.prototype.insertBefore = function insertBefore(exist, add) {\n    exist = this.index(exist);\n    var type = exist === 0 ? 'prepend' : false;\n    var nodes = this.normalize(add, this.nodes[exist], type).reverse();\n\n    for (var _iterator6 = nodes, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {\n      var _ref6;\n\n      if (_isArray6) {\n        if (_i6 >= _iterator6.length) break;\n        _ref6 = _iterator6[_i6++];\n      } else {\n        _i6 = _iterator6.next();\n        if (_i6.done) break;\n        _ref6 = _i6.value;\n      }\n\n      var node = _ref6;\n      this.nodes.splice(exist, 0, node);\n    }\n\n    var index = void 0;\n\n    for (var id in this.indexes) {\n      index = this.indexes[id];\n\n      if (exist <= index) {\n        this.indexes[id] = index + nodes.length;\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Insert new node after old node within the container.\n   *\n   * @param {Node|number} exist             - child or child’s index\n   * @param {Node|object|string|Node[]} add - new node\n   *\n   * @return {Node} this node for methods chain\n   */\n\n\n  Container.prototype.insertAfter = function insertAfter(exist, add) {\n    exist = this.index(exist);\n    var nodes = this.normalize(add, this.nodes[exist]).reverse();\n\n    for (var _iterator7 = nodes, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator]();;) {\n      var _ref7;\n\n      if (_isArray7) {\n        if (_i7 >= _iterator7.length) break;\n        _ref7 = _iterator7[_i7++];\n      } else {\n        _i7 = _iterator7.next();\n        if (_i7.done) break;\n        _ref7 = _i7.value;\n      }\n\n      var node = _ref7;\n      this.nodes.splice(exist + 1, 0, node);\n    }\n\n    var index = void 0;\n\n    for (var id in this.indexes) {\n      index = this.indexes[id];\n\n      if (exist < index) {\n        this.indexes[id] = index + nodes.length;\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Removes node from the container and cleans the parent properties\n   * from the node and its children.\n   *\n   * @param {Node|number} child - child or child’s index\n   *\n   * @return {Node} this node for methods chain\n   *\n   * @example\n   * rule.nodes.length  //=> 5\n   * rule.removeChild(decl);\n   * rule.nodes.length  //=> 4\n   * decl.parent        //=> undefined\n   */\n\n\n  Container.prototype.removeChild = function removeChild(child) {\n    child = this.index(child);\n    this.nodes[child].parent = undefined;\n    this.nodes.splice(child, 1);\n    var index = void 0;\n\n    for (var id in this.indexes) {\n      index = this.indexes[id];\n\n      if (index >= child) {\n        this.indexes[id] = index - 1;\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Removes all children from the container\n   * and cleans their parent properties.\n   *\n   * @return {Node} this node for methods chain\n   *\n   * @example\n   * rule.removeAll();\n   * rule.nodes.length //=> 0\n   */\n\n\n  Container.prototype.removeAll = function removeAll() {\n    for (var _iterator8 = this.nodes, _isArray8 = Array.isArray(_iterator8), _i8 = 0, _iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator]();;) {\n      var _ref8;\n\n      if (_isArray8) {\n        if (_i8 >= _iterator8.length) break;\n        _ref8 = _iterator8[_i8++];\n      } else {\n        _i8 = _iterator8.next();\n        if (_i8.done) break;\n        _ref8 = _i8.value;\n      }\n\n      var node = _ref8;\n      node.parent = undefined;\n    }\n\n    this.nodes = [];\n    return this;\n  };\n  /**\n   * Passes all declaration values within the container that match pattern\n   * through callback, replacing those values with the returned result\n   * of callback.\n   *\n   * This method is useful if you are using a custom unit or function\n   * and need to iterate through all values.\n   *\n   * @param {string|RegExp} pattern      - replace pattern\n   * @param {object} opts                - options to speed up the search\n   * @param {string|string[]} opts.props - an array of property names\n   * @param {string} opts.fast           - string that’s used\n   *                                       to narrow down values and speed up\n                                           the regexp search\n   * @param {function|string} callback   - string to replace pattern\n   *                                       or callback that returns a new\n   *                                       value.\n   *                                       The callback will receive\n   *                                       the same arguments as those\n   *                                       passed to a function parameter\n   *                                       of `String#replace`.\n   *\n   * @return {Node} this node for methods chain\n   *\n   * @example\n   * root.replaceValues(/\\d+rem/, { fast: 'rem' }, string => {\n   *   return 15 * parseInt(string) + 'px';\n   * });\n   */\n\n\n  Container.prototype.replaceValues = function replaceValues(pattern, opts, callback) {\n    if (!callback) {\n      callback = opts;\n      opts = {};\n    }\n\n    this.walkDecls(function (decl) {\n      if (opts.props && opts.props.indexOf(decl.prop) === -1) return;\n      if (opts.fast && decl.value.indexOf(opts.fast) === -1) return;\n      decl.value = decl.value.replace(pattern, callback);\n    });\n    return this;\n  };\n  /**\n   * Returns `true` if callback returns `true`\n   * for all of the container’s children.\n   *\n   * @param {childCondition} condition - iterator returns true or false.\n   *\n   * @return {boolean} is every child pass condition\n   *\n   * @example\n   * const noPrefixes = rule.every(i => i.prop[0] !== '-');\n   */\n\n\n  Container.prototype.every = function every(condition) {\n    return this.nodes.every(condition);\n  };\n  /**\n   * Returns `true` if callback returns `true` for (at least) one\n   * of the container’s children.\n   *\n   * @param {childCondition} condition - iterator returns true or false.\n   *\n   * @return {boolean} is some child pass condition\n   *\n   * @example\n   * const hasPrefix = rule.some(i => i.prop[0] === '-');\n   */\n\n\n  Container.prototype.some = function some(condition) {\n    return this.nodes.some(condition);\n  };\n  /**\n   * Returns a `child`’s index within the {@link Container#nodes} array.\n   *\n   * @param {Node} child - child of the current container.\n   *\n   * @return {number} child index\n   *\n   * @example\n   * rule.index( rule.nodes[2] ) //=> 2\n   */\n\n\n  Container.prototype.index = function index(child) {\n    if (typeof child === 'number') {\n      return child;\n    } else {\n      return this.nodes.indexOf(child);\n    }\n  };\n  /**\n   * The container’s first child.\n   *\n   * @type {Node}\n   *\n   * @example\n   * rule.first == rules.nodes[0];\n   */\n\n\n  Container.prototype.normalize = function normalize(nodes, sample) {\n    var _this2 = this;\n\n    if (typeof nodes === 'string') {\n      var parse = require('./parse');\n\n      nodes = cleanSource(parse(nodes).nodes);\n    } else if (Array.isArray(nodes)) {\n      nodes = nodes.slice(0);\n\n      for (var _iterator9 = nodes, _isArray9 = Array.isArray(_iterator9), _i9 = 0, _iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator]();;) {\n        var _ref9;\n\n        if (_isArray9) {\n          if (_i9 >= _iterator9.length) break;\n          _ref9 = _iterator9[_i9++];\n        } else {\n          _i9 = _iterator9.next();\n          if (_i9.done) break;\n          _ref9 = _i9.value;\n        }\n\n        var i = _ref9;\n        if (i.parent) i.parent.removeChild(i, 'ignore');\n      }\n    } else if (nodes.type === 'root') {\n      nodes = nodes.nodes.slice(0);\n\n      for (var _iterator10 = nodes, _isArray10 = Array.isArray(_iterator10), _i11 = 0, _iterator10 = _isArray10 ? _iterator10 : _iterator10[Symbol.iterator]();;) {\n        var _ref10;\n\n        if (_isArray10) {\n          if (_i11 >= _iterator10.length) break;\n          _ref10 = _iterator10[_i11++];\n        } else {\n          _i11 = _iterator10.next();\n          if (_i11.done) break;\n          _ref10 = _i11.value;\n        }\n\n        var _i10 = _ref10;\n        if (_i10.parent) _i10.parent.removeChild(_i10, 'ignore');\n      }\n    } else if (nodes.type) {\n      nodes = [nodes];\n    } else if (nodes.prop) {\n      if (typeof nodes.value === 'undefined') {\n        throw new Error('Value field is missed in node creation');\n      } else if (typeof nodes.value !== 'string') {\n        nodes.value = String(nodes.value);\n      }\n\n      nodes = [new _declaration2.default(nodes)];\n    } else if (nodes.selector) {\n      var Rule = require('./rule');\n\n      nodes = [new Rule(nodes)];\n    } else if (nodes.name) {\n      var AtRule = require('./at-rule');\n\n      nodes = [new AtRule(nodes)];\n    } else if (nodes.text) {\n      nodes = [new _comment2.default(nodes)];\n    } else {\n      throw new Error('Unknown node type in node creation');\n    }\n\n    var processed = nodes.map(function (i) {\n      if (typeof i.before !== 'function') i = _this2.rebuild(i);\n      if (i.parent) i.parent.removeChild(i);\n\n      if (typeof i.raws.before === 'undefined') {\n        if (sample && typeof sample.raws.before !== 'undefined') {\n          i.raws.before = sample.raws.before.replace(/[^\\s]/g, '');\n        }\n      }\n\n      i.parent = _this2;\n      return i;\n    });\n    return processed;\n  };\n\n  Container.prototype.rebuild = function rebuild(node, parent) {\n    var _this3 = this;\n\n    var fix = void 0;\n\n    if (node.type === 'root') {\n      var Root = require('./root');\n\n      fix = new Root();\n    } else if (node.type === 'atrule') {\n      var AtRule = require('./at-rule');\n\n      fix = new AtRule();\n    } else if (node.type === 'rule') {\n      var Rule = require('./rule');\n\n      fix = new Rule();\n    } else if (node.type === 'decl') {\n      fix = new _declaration2.default();\n    } else if (node.type === 'comment') {\n      fix = new _comment2.default();\n    }\n\n    for (var i in node) {\n      if (i === 'nodes') {\n        fix.nodes = node.nodes.map(function (j) {\n          return _this3.rebuild(j, fix);\n        });\n      } else if (i === 'parent' && parent) {\n        fix.parent = parent;\n      } else if (node.hasOwnProperty(i)) {\n        fix[i] = node[i];\n      }\n    }\n\n    return fix;\n  };\n  /**\n   * @memberof Container#\n   * @member {Node[]} nodes - an array containing the container’s children\n   *\n   * @example\n   * const root = postcss.parse('a { color: black }');\n   * root.nodes.length           //=> 1\n   * root.nodes[0].selector      //=> 'a'\n   * root.nodes[0].nodes[0].prop //=> 'color'\n   */\n\n\n  _createClass(Container, [{\n    key: 'first',\n    get: function get() {\n      if (!this.nodes) return undefined;\n      return this.nodes[0];\n    }\n    /**\n     * The container’s last child.\n     *\n     * @type {Node}\n     *\n     * @example\n     * rule.last == rule.nodes[rule.nodes.length - 1];\n     */\n\n  }, {\n    key: 'last',\n    get: function get() {\n      if (!this.nodes) return undefined;\n      return this.nodes[this.nodes.length - 1];\n    }\n  }]);\n\n  return Container;\n}(_node2.default);\n\nexports.default = Container;\n/**\n * @callback childCondition\n * @param {Node} node    - container child\n * @param {number} index - child index\n * @param {Node[]} nodes - all container children\n * @return {boolean}\n */\n\n/**\n * @callback childIterator\n * @param {Node} node    - container child\n * @param {number} index - child index\n * @return {false|undefined} returning `false` will break iteration\n */\n\nmodule.exports = exports['default'];","map":{"version":3,"sources":["container.es6"],"names":["i","cleanSource","Container","Node","push","child","each","callback","id","index","result","walk","walkDecls","prop","walkRules","selector","walkAtRules","name","walkComments","append","children","nodes","node","prepend","cleanRaws","keepBetween","insertBefore","exist","add","type","insertAfter","removeChild","removeAll","replaceValues","pattern","opts","decl","every","condition","some","normalize","sample","parse","require","Array","String","Declaration","Rule","AtRule","Comment","processed","rebuild","parent","fix","Root"],"mappings":"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","sourcesContent":["import Declaration from './declaration';\nimport Comment     from './comment';\nimport Node        from './node';\n\nfunction cleanSource(nodes) {\n    return nodes.map( i => {\n        if ( i.nodes ) i.nodes = cleanSource(i.nodes);\n        delete i.source;\n        return i;\n    });\n}\n\n/**\n * The {@link Root}, {@link AtRule}, and {@link Rule} container nodes\n * inherit some common methods to help work with their children.\n *\n * Note that all containers can store any content. If you write a rule inside\n * a rule, PostCSS will parse it.\n *\n * @extends Node\n * @abstract\n */\nclass Container extends Node {\n\n    push(child) {\n        child.parent = this;\n        this.nodes.push(child);\n        return this;\n    }\n\n    /**\n     * Iterates through the container’s immediate children,\n     * calling `callback` for each child.\n     *\n     * Returning `false` in the callback will break iteration.\n     *\n     * This method only iterates through the container’s immediate children.\n     * If you need to recursively iterate through all the container’s descendant\n     * nodes, use {@link Container#walk}.\n     *\n     * Unlike the for `{}`-cycle or `Array#forEach` this iterator is safe\n     * if you are mutating the array of child nodes during iteration.\n     * PostCSS will adjust the current index to match the mutations.\n     *\n     * @param {childIterator} callback - iterator receives each node and index\n     *\n     * @return {false|undefined} returns `false` if iteration was broke\n     *\n     * @example\n     * const root = postcss.parse('a { color: black; z-index: 1 }');\n     * const rule = root.first;\n     *\n     * for ( let decl of rule.nodes ) {\n     *     decl.cloneBefore({ prop: '-webkit-' + decl.prop });\n     *     // Cycle will be infinite, because cloneBefore moves the current node\n     *     // to the next index\n     * }\n     *\n     * rule.each(decl => {\n     *     decl.cloneBefore({ prop: '-webkit-' + decl.prop });\n     *     // Will be executed only for color and z-index\n     * });\n     */\n    each(callback) {\n        if ( !this.lastEach ) this.lastEach = 0;\n        if ( !this.indexes ) this.indexes = { };\n\n        this.lastEach += 1;\n        let id = this.lastEach;\n        this.indexes[id] = 0;\n\n        if ( !this.nodes ) return undefined;\n\n        let index, result;\n        while ( this.indexes[id] < this.nodes.length ) {\n            index  = this.indexes[id];\n            result = callback(this.nodes[index], index);\n            if ( result === false ) break;\n\n            this.indexes[id] += 1;\n        }\n\n        delete this.indexes[id];\n\n        return result;\n    }\n\n    /**\n     * Traverses the container’s descendant nodes, calling callback\n     * for each node.\n     *\n     * Like container.each(), this method is safe to use\n     * if you are mutating arrays during iteration.\n     *\n     * If you only need to iterate through the container’s immediate children,\n     * use {@link Container#each}.\n     *\n     * @param {childIterator} callback - iterator receives each node and index\n     *\n     * @return {false|undefined} returns `false` if iteration was broke\n     *\n     * @example\n     * root.walk(node => {\n     *   // Traverses all descendant nodes.\n     * });\n     */\n    walk(callback) {\n        return this.each( (child, i) => {\n            let result = callback(child, i);\n            if ( result !== false && child.walk ) {\n                result = child.walk(callback);\n            }\n            return result;\n        });\n    }\n\n    /**\n     * Traverses the container’s descendant nodes, calling callback\n     * for each declaration node.\n     *\n     * If you pass a filter, iteration will only happen over declarations\n     * with matching properties.\n     *\n     * Like {@link Container#each}, this method is safe\n     * to use if you are mutating arrays during iteration.\n     *\n     * @param {string|RegExp} [prop]   - string or regular expression\n     *                                   to filter declarations by property name\n     * @param {childIterator} callback - iterator receives each node and index\n     *\n     * @return {false|undefined} returns `false` if iteration was broke\n     *\n     * @example\n     * root.walkDecls(decl => {\n     *   checkPropertySupport(decl.prop);\n     * });\n     *\n     * root.walkDecls('border-radius', decl => {\n     *   decl.remove();\n     * });\n     *\n     * root.walkDecls(/^background/, decl => {\n     *   decl.value = takeFirstColorFromGradient(decl.value);\n     * });\n     */\n    walkDecls(prop, callback) {\n        if ( !callback ) {\n            callback = prop;\n            return this.walk( (child, i) => {\n                if ( child.type === 'decl' ) {\n                    return callback(child, i);\n                }\n            });\n        } else if ( prop instanceof RegExp ) {\n            return this.walk( (child, i) => {\n                if ( child.type === 'decl' && prop.test(child.prop) ) {\n                    return callback(child, i);\n                }\n            });\n        } else {\n            return this.walk( (child, i) => {\n                if ( child.type === 'decl' && child.prop === prop ) {\n                    return callback(child, i);\n                }\n            });\n        }\n    }\n\n    /**\n     * Traverses the container’s descendant nodes, calling callback\n     * for each rule node.\n     *\n     * If you pass a filter, iteration will only happen over rules\n     * with matching selectors.\n     *\n     * Like {@link Container#each}, this method is safe\n     * to use if you are mutating arrays during iteration.\n     *\n     * @param {string|RegExp} [selector] - string or regular expression\n     *                                     to filter rules by selector\n     * @param {childIterator} callback   - iterator receives each node and index\n     *\n     * @return {false|undefined} returns `false` if iteration was broke\n     *\n     * @example\n     * const selectors = [];\n     * root.walkRules(rule => {\n     *   selectors.push(rule.selector);\n     * });\n     * console.log(`Your CSS uses ${selectors.length} selectors`);\n     */\n    walkRules(selector, callback) {\n        if ( !callback ) {\n            callback = selector;\n\n            return this.walk( (child, i) => {\n                if ( child.type === 'rule' ) {\n                    return callback(child, i);\n                }\n            });\n        } else if ( selector instanceof RegExp ) {\n            return this.walk( (child, i) => {\n                if ( child.type === 'rule' && selector.test(child.selector) ) {\n                    return callback(child, i);\n                }\n            });\n        } else {\n            return this.walk( (child, i) => {\n                if ( child.type === 'rule' && child.selector === selector ) {\n                    return callback(child, i);\n                }\n            });\n        }\n    }\n\n    /**\n     * Traverses the container’s descendant nodes, calling callback\n     * for each at-rule node.\n     *\n     * If you pass a filter, iteration will only happen over at-rules\n     * that have matching names.\n     *\n     * Like {@link Container#each}, this method is safe\n     * to use if you are mutating arrays during iteration.\n     *\n     * @param {string|RegExp} [name]   - string or regular expression\n     *                                   to filter at-rules by name\n     * @param {childIterator} callback - iterator receives each node and index\n     *\n     * @return {false|undefined} returns `false` if iteration was broke\n     *\n     * @example\n     * root.walkAtRules(rule => {\n     *   if ( isOld(rule.name) ) rule.remove();\n     * });\n     *\n     * let first = false;\n     * root.walkAtRules('charset', rule => {\n     *   if ( !first ) {\n     *     first = true;\n     *   } else {\n     *     rule.remove();\n     *   }\n     * });\n     */\n    walkAtRules(name, callback) {\n        if ( !callback ) {\n            callback = name;\n            return this.walk( (child, i) => {\n                if ( child.type === 'atrule' ) {\n                    return callback(child, i);\n                }\n            });\n        } else if ( name instanceof RegExp ) {\n            return this.walk( (child, i) => {\n                if ( child.type === 'atrule' && name.test(child.name) ) {\n                    return callback(child, i);\n                }\n            });\n        } else {\n            return this.walk( (child, i) => {\n                if ( child.type === 'atrule' && child.name === name ) {\n                    return callback(child, i);\n                }\n            });\n        }\n    }\n\n    /**\n     * Traverses the container’s descendant nodes, calling callback\n     * for each comment node.\n     *\n     * Like {@link Container#each}, this method is safe\n     * to use if you are mutating arrays during iteration.\n     *\n     * @param {childIterator} callback - iterator receives each node and index\n     *\n     * @return {false|undefined} returns `false` if iteration was broke\n     *\n     * @example\n     * root.walkComments(comment => {\n     *   comment.remove();\n     * });\n     */\n    walkComments(callback) {\n        return this.walk( (child, i) => {\n            if ( child.type === 'comment' ) {\n                return callback(child, i);\n            }\n        });\n    }\n\n    /**\n     * Inserts new nodes to the end of the container.\n     *\n     * @param {...(Node|object|string|Node[])} children - new nodes\n     *\n     * @return {Node} this node for methods chain\n     *\n     * @example\n     * const decl1 = postcss.decl({ prop: 'color', value: 'black' });\n     * const decl2 = postcss.decl({ prop: 'background-color', value: 'white' });\n     * rule.append(decl1, decl2);\n     *\n     * root.append({ name: 'charset', params: '\"UTF-8\"' });  // at-rule\n     * root.append({ selector: 'a' });                       // rule\n     * rule.append({ prop: 'color', value: 'black' });       // declaration\n     * rule.append({ text: 'Comment' })                      // comment\n     *\n     * root.append('a {}');\n     * root.first.append('color: black; z-index: 1');\n     */\n    append(...children) {\n        for ( let child of children ) {\n            let nodes = this.normalize(child, this.last);\n            for ( let node of nodes ) this.nodes.push(node);\n        }\n        return this;\n    }\n\n    /**\n     * Inserts new nodes to the start of the container.\n     *\n     * @param {...(Node|object|string|Node[])} children - new nodes\n     *\n     * @return {Node} this node for methods chain\n     *\n     * @example\n     * const decl1 = postcss.decl({ prop: 'color', value: 'black' });\n     * const decl2 = postcss.decl({ prop: 'background-color', value: 'white' });\n     * rule.prepend(decl1, decl2);\n     *\n     * root.append({ name: 'charset', params: '\"UTF-8\"' });  // at-rule\n     * root.append({ selector: 'a' });                       // rule\n     * rule.append({ prop: 'color', value: 'black' });       // declaration\n     * rule.append({ text: 'Comment' })                      // comment\n     *\n     * root.append('a {}');\n     * root.first.append('color: black; z-index: 1');\n     */\n    prepend(...children) {\n        children = children.reverse();\n        for ( let child of children ) {\n            let nodes = this.normalize(child, this.first, 'prepend').reverse();\n            for ( let node of nodes ) this.nodes.unshift(node);\n            for ( let id in this.indexes ) {\n                this.indexes[id] = this.indexes[id] + nodes.length;\n            }\n        }\n        return this;\n    }\n\n    cleanRaws(keepBetween) {\n        super.cleanRaws(keepBetween);\n        if ( this.nodes ) {\n            for ( let node of this.nodes ) node.cleanRaws(keepBetween);\n        }\n    }\n\n    /**\n     * Insert new node before old node within the container.\n     *\n     * @param {Node|number} exist             - child or child’s index.\n     * @param {Node|object|string|Node[]} add - new node\n     *\n     * @return {Node} this node for methods chain\n     *\n     * @example\n     * rule.insertBefore(decl, decl.clone({ prop: '-webkit-' + decl.prop }));\n     */\n    insertBefore(exist, add) {\n        exist = this.index(exist);\n\n        let type  = exist === 0 ? 'prepend' : false;\n        let nodes = this.normalize(add, this.nodes[exist], type).reverse();\n        for ( let node of nodes ) this.nodes.splice(exist, 0, node);\n\n        let index;\n        for ( let id in this.indexes ) {\n            index = this.indexes[id];\n            if ( exist <= index ) {\n                this.indexes[id] = index + nodes.length;\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Insert new node after old node within the container.\n     *\n     * @param {Node|number} exist             - child or child’s index\n     * @param {Node|object|string|Node[]} add - new node\n     *\n     * @return {Node} this node for methods chain\n     */\n    insertAfter(exist, add) {\n        exist = this.index(exist);\n\n        let nodes = this.normalize(add, this.nodes[exist]).reverse();\n        for ( let node of nodes ) this.nodes.splice(exist + 1, 0, node);\n\n        let index;\n        for ( let id in this.indexes ) {\n            index = this.indexes[id];\n            if ( exist < index ) {\n                this.indexes[id] = index + nodes.length;\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Removes node from the container and cleans the parent properties\n     * from the node and its children.\n     *\n     * @param {Node|number} child - child or child’s index\n     *\n     * @return {Node} this node for methods chain\n     *\n     * @example\n     * rule.nodes.length  //=> 5\n     * rule.removeChild(decl);\n     * rule.nodes.length  //=> 4\n     * decl.parent        //=> undefined\n     */\n    removeChild(child) {\n        child = this.index(child);\n        this.nodes[child].parent = undefined;\n        this.nodes.splice(child, 1);\n\n        let index;\n        for ( let id in this.indexes ) {\n            index = this.indexes[id];\n            if ( index >= child ) {\n                this.indexes[id] = index - 1;\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Removes all children from the container\n     * and cleans their parent properties.\n     *\n     * @return {Node} this node for methods chain\n     *\n     * @example\n     * rule.removeAll();\n     * rule.nodes.length //=> 0\n     */\n    removeAll() {\n        for ( let node of this.nodes ) node.parent = undefined;\n        this.nodes = [];\n        return this;\n    }\n\n    /**\n     * Passes all declaration values within the container that match pattern\n     * through callback, replacing those values with the returned result\n     * of callback.\n     *\n     * This method is useful if you are using a custom unit or function\n     * and need to iterate through all values.\n     *\n     * @param {string|RegExp} pattern      - replace pattern\n     * @param {object} opts                - options to speed up the search\n     * @param {string|string[]} opts.props - an array of property names\n     * @param {string} opts.fast           - string that’s used\n     *                                       to narrow down values and speed up\n                                             the regexp search\n     * @param {function|string} callback   - string to replace pattern\n     *                                       or callback that returns a new\n     *                                       value.\n     *                                       The callback will receive\n     *                                       the same arguments as those\n     *                                       passed to a function parameter\n     *                                       of `String#replace`.\n     *\n     * @return {Node} this node for methods chain\n     *\n     * @example\n     * root.replaceValues(/\\d+rem/, { fast: 'rem' }, string => {\n     *   return 15 * parseInt(string) + 'px';\n     * });\n     */\n    replaceValues(pattern, opts, callback) {\n        if ( !callback ) {\n            callback = opts;\n            opts = { };\n        }\n\n        this.walkDecls( decl => {\n            if ( opts.props && opts.props.indexOf(decl.prop) === -1 ) return;\n            if ( opts.fast  && decl.value.indexOf(opts.fast) === -1 ) return;\n\n            decl.value = decl.value.replace(pattern, callback);\n        });\n\n        return this;\n    }\n\n    /**\n     * Returns `true` if callback returns `true`\n     * for all of the container’s children.\n     *\n     * @param {childCondition} condition - iterator returns true or false.\n     *\n     * @return {boolean} is every child pass condition\n     *\n     * @example\n     * const noPrefixes = rule.every(i => i.prop[0] !== '-');\n     */\n    every(condition) {\n        return this.nodes.every(condition);\n    }\n\n    /**\n     * Returns `true` if callback returns `true` for (at least) one\n     * of the container’s children.\n     *\n     * @param {childCondition} condition - iterator returns true or false.\n     *\n     * @return {boolean} is some child pass condition\n     *\n     * @example\n     * const hasPrefix = rule.some(i => i.prop[0] === '-');\n     */\n    some(condition) {\n        return this.nodes.some(condition);\n    }\n\n    /**\n     * Returns a `child`’s index within the {@link Container#nodes} array.\n     *\n     * @param {Node} child - child of the current container.\n     *\n     * @return {number} child index\n     *\n     * @example\n     * rule.index( rule.nodes[2] ) //=> 2\n     */\n    index(child) {\n        if ( typeof child === 'number' ) {\n            return child;\n        } else {\n            return this.nodes.indexOf(child);\n        }\n    }\n\n    /**\n     * The container’s first child.\n     *\n     * @type {Node}\n     *\n     * @example\n     * rule.first == rules.nodes[0];\n     */\n    get first() {\n        if ( !this.nodes ) return undefined;\n        return this.nodes[0];\n    }\n\n    /**\n     * The container’s last child.\n     *\n     * @type {Node}\n     *\n     * @example\n     * rule.last == rule.nodes[rule.nodes.length - 1];\n     */\n    get last() {\n        if ( !this.nodes ) return undefined;\n        return this.nodes[this.nodes.length - 1];\n    }\n\n    normalize(nodes, sample) {\n        if ( typeof nodes === 'string' ) {\n            let parse = require('./parse');\n            nodes = cleanSource(parse(nodes).nodes);\n        } else if ( Array.isArray(nodes) ) {\n            nodes = nodes.slice(0);\n            for ( let i of nodes ) {\n                if ( i.parent ) i.parent.removeChild(i, 'ignore');\n            }\n        } else if ( nodes.type === 'root' ) {\n            nodes = nodes.nodes.slice(0);\n            for ( let i of nodes ) {\n                if ( i.parent ) i.parent.removeChild(i, 'ignore');\n            }\n        } else if ( nodes.type ) {\n            nodes = [nodes];\n        } else if ( nodes.prop ) {\n            if ( typeof nodes.value === 'undefined' ) {\n                throw new Error('Value field is missed in node creation');\n            } else if ( typeof nodes.value !== 'string' ) {\n                nodes.value = String(nodes.value);\n            }\n            nodes = [new Declaration(nodes)];\n        } else if ( nodes.selector ) {\n            let Rule = require('./rule');\n            nodes = [new Rule(nodes)];\n        } else if ( nodes.name ) {\n            let AtRule = require('./at-rule');\n            nodes = [new AtRule(nodes)];\n        } else if ( nodes.text ) {\n            nodes = [new Comment(nodes)];\n        } else {\n            throw new Error('Unknown node type in node creation');\n        }\n\n        let processed = nodes.map( i => {\n            if ( typeof i.before !== 'function' ) i = this.rebuild(i);\n\n            if ( i.parent ) i.parent.removeChild(i);\n            if ( typeof i.raws.before === 'undefined' ) {\n                if ( sample && typeof sample.raws.before !== 'undefined' ) {\n                    i.raws.before = sample.raws.before.replace(/[^\\s]/g, '');\n                }\n            }\n            i.parent = this;\n            return i;\n        });\n\n        return processed;\n    }\n\n    rebuild(node, parent) {\n        let fix;\n        if ( node.type === 'root' ) {\n            let Root = require('./root');\n            fix = new Root();\n        } else if ( node.type === 'atrule' ) {\n            let AtRule = require('./at-rule');\n            fix = new AtRule();\n        } else if ( node.type === 'rule' ) {\n            let Rule = require('./rule');\n            fix = new Rule();\n        } else if ( node.type === 'decl' ) {\n            fix = new Declaration();\n        } else if ( node.type === 'comment' ) {\n            fix = new Comment();\n        }\n\n        for ( let i in node ) {\n            if ( i === 'nodes' ) {\n                fix.nodes = node.nodes.map( j => this.rebuild(j, fix) );\n            } else if ( i === 'parent' && parent ) {\n                fix.parent = parent;\n            } else if ( node.hasOwnProperty(i) ) {\n                fix[i] = node[i];\n            }\n        }\n\n        return fix;\n    }\n\n    /**\n     * @memberof Container#\n     * @member {Node[]} nodes - an array containing the container’s children\n     *\n     * @example\n     * const root = postcss.parse('a { color: black }');\n     * root.nodes.length           //=> 1\n     * root.nodes[0].selector      //=> 'a'\n     * root.nodes[0].nodes[0].prop //=> 'color'\n     */\n\n}\n\nexport default Container;\n\n\n/**\n * @callback childCondition\n * @param {Node} node    - container child\n * @param {number} index - child index\n * @param {Node[]} nodes - all container children\n * @return {boolean}\n */\n\n/**\n * @callback childIterator\n * @param {Node} node    - container child\n * @param {number} index - child index\n * @return {false|undefined} returning `false` will break iteration\n */\n"]},"metadata":{},"sourceType":"script"}