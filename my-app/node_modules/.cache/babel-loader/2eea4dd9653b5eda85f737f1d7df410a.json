{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nexports.getSource = getSource;\n\nvar _isReactNative = require(\"./isReactNative\");\n\nvar _isReactNative2 = _interopRequireDefault(_isReactNative);\n\nvar _uriToBlob = require(\"./uriToBlob\");\n\nvar _uriToBlob2 = _interopRequireDefault(_uriToBlob);\n\nvar _isCordova = require(\"./isCordova\");\n\nvar _isCordova2 = _interopRequireDefault(_isCordova);\n\nvar _readAsByteArray = require(\"./readAsByteArray\");\n\nvar _readAsByteArray2 = _interopRequireDefault(_readAsByteArray);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar FileSource = function () {\n  function FileSource(file) {\n    _classCallCheck(this, FileSource);\n\n    this._file = file;\n    this.size = file.size;\n  }\n\n  _createClass(FileSource, [{\n    key: \"slice\",\n    value: function slice(start, end, callback) {\n      // In Apache Cordova applications, a File must be resolved using\n      // FileReader instances, see\n      // https://cordova.apache.org/docs/en/8.x/reference/cordova-plugin-file/index.html#read-a-file\n      if ((0, _isCordova2.default)()) {\n        (0, _readAsByteArray2.default)(this._file.slice(start, end), function (err, chunk) {\n          if (err) return callback(err);\n          callback(null, chunk);\n        });\n        return;\n      }\n\n      callback(null, this._file.slice(start, end));\n    }\n  }, {\n    key: \"close\",\n    value: function close() {}\n  }]);\n\n  return FileSource;\n}();\n\nvar StreamSource = function () {\n  function StreamSource(reader, chunkSize) {\n    _classCallCheck(this, StreamSource);\n\n    this._chunkSize = chunkSize;\n    this._buffer = undefined;\n    this._bufferOffset = 0;\n    this._reader = reader;\n    this._done = false;\n  }\n\n  _createClass(StreamSource, [{\n    key: \"slice\",\n    value: function slice(start, end, callback) {\n      if (start < this._bufferOffset) {\n        callback(new Error(\"Requested data is before the reader's current offset\"));\n        return;\n      }\n\n      return this._readUntilEnoughDataOrDone(start, end, callback);\n    }\n  }, {\n    key: \"_readUntilEnoughDataOrDone\",\n    value: function _readUntilEnoughDataOrDone(start, end, callback) {\n      var _this = this;\n\n      var hasEnoughData = end <= this._bufferOffset + len(this._buffer);\n\n      if (this._done || hasEnoughData) {\n        var value = this._getDataFromBuffer(start, end);\n\n        callback(null, value, value == null ? this._done : false);\n        return;\n      }\n\n      this._reader.read().then(function (_ref) {\n        var value = _ref.value,\n            done = _ref.done;\n\n        if (done) {\n          _this._done = true;\n        } else if (_this._buffer === undefined) {\n          _this._buffer = value;\n        } else {\n          _this._buffer = concat(_this._buffer, value);\n        }\n\n        _this._readUntilEnoughDataOrDone(start, end, callback);\n      }).catch(function (err) {\n        callback(new Error(\"Error during read: \" + err));\n      });\n    }\n  }, {\n    key: \"_getDataFromBuffer\",\n    value: function _getDataFromBuffer(start, end) {\n      // Remove data from buffer before `start`.\n      // Data might be reread from the buffer if an upload fails, so we can only\n      // safely delete data when it comes *before* what is currently being read.\n      if (start > this._bufferOffset) {\n        this._buffer = this._buffer.slice(start - this._bufferOffset);\n        this._bufferOffset = start;\n      } // If the buffer is empty after removing old data, all data has been read.\n\n\n      var hasAllDataBeenRead = len(this._buffer) === 0;\n\n      if (this._done && hasAllDataBeenRead) {\n        return null;\n      } // We already removed data before `start`, so we just return the first\n      // chunk from the buffer.\n\n\n      return this._buffer.slice(0, end - start);\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      if (this._reader.cancel) {\n        this._reader.cancel();\n      }\n    }\n  }]);\n\n  return StreamSource;\n}();\n\nfunction len(blobOrArray) {\n  if (blobOrArray === undefined) return 0;\n  if (blobOrArray.size !== undefined) return blobOrArray.size;\n  return blobOrArray.length;\n}\n/*\n  Typed arrays and blobs don't have a concat method.\n  This function helps StreamSource accumulate data to reach chunkSize.\n*/\n\n\nfunction concat(a, b) {\n  if (a.concat) {\n    // Is `a` an Array?\n    return a.concat(b);\n  }\n\n  if (a instanceof Blob) {\n    return new Blob([a, b], {\n      type: a.type\n    });\n  }\n\n  if (a.set) {\n    // Is `a` a typed array?\n    var c = new a.constructor(a.length + b.length);\n    c.set(a);\n    c.set(b, a.length);\n    return c;\n  }\n\n  throw new Error(\"Unknown data type\");\n}\n\nfunction getSource(input, chunkSize, callback) {\n  // In React Native, when user selects a file, instead of a File or Blob,\n  // you usually get a file object {} with a uri property that contains\n  // a local path to the file. We use XMLHttpRequest to fetch\n  // the file blob, before uploading with tus.\n  if ((0, _isReactNative2.default)() && input && typeof input.uri !== \"undefined\") {\n    (0, _uriToBlob2.default)(input.uri, function (err, blob) {\n      if (err) {\n        return callback(new Error(\"tus: cannot fetch `file.uri` as Blob, make sure the uri is correct and accessible. \" + err));\n      }\n\n      callback(null, new FileSource(blob));\n    });\n    return;\n  } // Since we emulate the Blob type in our tests (not all target browsers\n  // support it), we cannot use `instanceof` for testing whether the input value\n  // can be handled. Instead, we simply check is the slice() function and the\n  // size property are available.\n\n\n  if (typeof input.slice === \"function\" && typeof input.size !== \"undefined\") {\n    callback(null, new FileSource(input));\n    return;\n  }\n\n  if (typeof input.read === \"function\") {\n    chunkSize = +chunkSize;\n\n    if (!isFinite(chunkSize)) {\n      callback(new Error(\"cannot create source for stream without a finite value for the `chunkSize` option\"));\n      return;\n    }\n\n    callback(null, new StreamSource(input, chunkSize));\n    return;\n  }\n\n  callback(new Error(\"source object may only be an instance of File, Blob, or Reader in this environment\"));\n}","map":{"version":3,"sources":["/Users/seito/Documents/develop/shadowX/node_modules/tus-js-client/lib.es5/browser/source.js"],"names":["Object","defineProperty","exports","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","Constructor","protoProps","staticProps","prototype","getSource","_isReactNative","require","_isReactNative2","_interopRequireDefault","_uriToBlob","_uriToBlob2","_isCordova","_isCordova2","_readAsByteArray","_readAsByteArray2","obj","__esModule","default","_classCallCheck","instance","TypeError","FileSource","file","_file","size","slice","start","end","callback","err","chunk","close","StreamSource","reader","chunkSize","_chunkSize","_buffer","undefined","_bufferOffset","_reader","_done","Error","_readUntilEnoughDataOrDone","_this","hasEnoughData","len","_getDataFromBuffer","read","then","_ref","done","concat","catch","hasAllDataBeenRead","cancel","blobOrArray","a","b","Blob","type","set","c","constructor","input","uri","blob","isFinite"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.getSource = getSource;\n\nvar _isReactNative = require(\"./isReactNative\");\n\nvar _isReactNative2 = _interopRequireDefault(_isReactNative);\n\nvar _uriToBlob = require(\"./uriToBlob\");\n\nvar _uriToBlob2 = _interopRequireDefault(_uriToBlob);\n\nvar _isCordova = require(\"./isCordova\");\n\nvar _isCordova2 = _interopRequireDefault(_isCordova);\n\nvar _readAsByteArray = require(\"./readAsByteArray\");\n\nvar _readAsByteArray2 = _interopRequireDefault(_readAsByteArray);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar FileSource = function () {\n  function FileSource(file) {\n    _classCallCheck(this, FileSource);\n\n    this._file = file;\n    this.size = file.size;\n  }\n\n  _createClass(FileSource, [{\n    key: \"slice\",\n    value: function slice(start, end, callback) {\n      // In Apache Cordova applications, a File must be resolved using\n      // FileReader instances, see\n      // https://cordova.apache.org/docs/en/8.x/reference/cordova-plugin-file/index.html#read-a-file\n      if ((0, _isCordova2.default)()) {\n        (0, _readAsByteArray2.default)(this._file.slice(start, end), function (err, chunk) {\n          if (err) return callback(err);\n\n          callback(null, chunk);\n        });\n        return;\n      }\n\n      callback(null, this._file.slice(start, end));\n    }\n  }, {\n    key: \"close\",\n    value: function close() {}\n  }]);\n\n  return FileSource;\n}();\n\nvar StreamSource = function () {\n  function StreamSource(reader, chunkSize) {\n    _classCallCheck(this, StreamSource);\n\n    this._chunkSize = chunkSize;\n    this._buffer = undefined;\n    this._bufferOffset = 0;\n    this._reader = reader;\n    this._done = false;\n  }\n\n  _createClass(StreamSource, [{\n    key: \"slice\",\n    value: function slice(start, end, callback) {\n      if (start < this._bufferOffset) {\n        callback(new Error(\"Requested data is before the reader's current offset\"));\n        return;\n      }\n\n      return this._readUntilEnoughDataOrDone(start, end, callback);\n    }\n  }, {\n    key: \"_readUntilEnoughDataOrDone\",\n    value: function _readUntilEnoughDataOrDone(start, end, callback) {\n      var _this = this;\n\n      var hasEnoughData = end <= this._bufferOffset + len(this._buffer);\n      if (this._done || hasEnoughData) {\n        var value = this._getDataFromBuffer(start, end);\n        callback(null, value, value == null ? this._done : false);\n        return;\n      }\n      this._reader.read().then(function (_ref) {\n        var value = _ref.value,\n            done = _ref.done;\n\n        if (done) {\n          _this._done = true;\n        } else if (_this._buffer === undefined) {\n          _this._buffer = value;\n        } else {\n          _this._buffer = concat(_this._buffer, value);\n        }\n\n        _this._readUntilEnoughDataOrDone(start, end, callback);\n      }).catch(function (err) {\n        callback(new Error(\"Error during read: \" + err));\n      });\n    }\n  }, {\n    key: \"_getDataFromBuffer\",\n    value: function _getDataFromBuffer(start, end) {\n      // Remove data from buffer before `start`.\n      // Data might be reread from the buffer if an upload fails, so we can only\n      // safely delete data when it comes *before* what is currently being read.\n      if (start > this._bufferOffset) {\n        this._buffer = this._buffer.slice(start - this._bufferOffset);\n        this._bufferOffset = start;\n      }\n      // If the buffer is empty after removing old data, all data has been read.\n      var hasAllDataBeenRead = len(this._buffer) === 0;\n      if (this._done && hasAllDataBeenRead) {\n        return null;\n      }\n      // We already removed data before `start`, so we just return the first\n      // chunk from the buffer.\n      return this._buffer.slice(0, end - start);\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      if (this._reader.cancel) {\n        this._reader.cancel();\n      }\n    }\n  }]);\n\n  return StreamSource;\n}();\n\nfunction len(blobOrArray) {\n  if (blobOrArray === undefined) return 0;\n  if (blobOrArray.size !== undefined) return blobOrArray.size;\n  return blobOrArray.length;\n}\n\n/*\n  Typed arrays and blobs don't have a concat method.\n  This function helps StreamSource accumulate data to reach chunkSize.\n*/\nfunction concat(a, b) {\n  if (a.concat) {\n    // Is `a` an Array?\n    return a.concat(b);\n  }\n  if (a instanceof Blob) {\n    return new Blob([a, b], { type: a.type });\n  }\n  if (a.set) {\n    // Is `a` a typed array?\n    var c = new a.constructor(a.length + b.length);\n    c.set(a);\n    c.set(b, a.length);\n    return c;\n  }\n  throw new Error(\"Unknown data type\");\n}\n\nfunction getSource(input, chunkSize, callback) {\n  // In React Native, when user selects a file, instead of a File or Blob,\n  // you usually get a file object {} with a uri property that contains\n  // a local path to the file. We use XMLHttpRequest to fetch\n  // the file blob, before uploading with tus.\n  if ((0, _isReactNative2.default)() && input && typeof input.uri !== \"undefined\") {\n    (0, _uriToBlob2.default)(input.uri, function (err, blob) {\n      if (err) {\n        return callback(new Error(\"tus: cannot fetch `file.uri` as Blob, make sure the uri is correct and accessible. \" + err));\n      }\n      callback(null, new FileSource(blob));\n    });\n    return;\n  }\n\n  // Since we emulate the Blob type in our tests (not all target browsers\n  // support it), we cannot use `instanceof` for testing whether the input value\n  // can be handled. Instead, we simply check is the slice() function and the\n  // size property are available.\n  if (typeof input.slice === \"function\" && typeof input.size !== \"undefined\") {\n    callback(null, new FileSource(input));\n    return;\n  }\n\n  if (typeof input.read === \"function\") {\n    chunkSize = +chunkSize;\n    if (!isFinite(chunkSize)) {\n      callback(new Error(\"cannot create source for stream without a finite value for the `chunkSize` option\"));\n      return;\n    }\n    callback(null, new StreamSource(input, chunkSize));\n    return;\n  }\n\n  callback(new Error(\"source object may only be an instance of File, Blob, or Reader in this environment\"));\n}"]},"metadata":{},"sourceType":"script"}