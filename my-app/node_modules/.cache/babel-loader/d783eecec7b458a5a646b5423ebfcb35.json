{"ast":null,"code":"'use strict';\n\nlet CssSyntaxError = require('./css-syntax-error');\n\nlet Stringifier = require('./stringifier');\n\nlet {\n  isClean\n} = require('./symbols');\n\nlet stringify = require('./stringify');\n\nfunction cloneNode(obj, parent) {\n  let cloned = new obj.constructor();\n\n  for (let i in obj) {\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) {\n      // istanbul ignore next\n      continue;\n    }\n\n    if (i === 'proxyCache') continue;\n    let value = obj[i];\n    let type = typeof value;\n\n    if (i === 'parent' && type === 'object') {\n      if (parent) cloned[i] = parent;\n    } else if (i === 'source') {\n      cloned[i] = value;\n    } else if (Array.isArray(value)) {\n      cloned[i] = value.map(j => cloneNode(j, cloned));\n    } else {\n      if (type === 'object' && value !== null) value = cloneNode(value);\n      cloned[i] = value;\n    }\n  }\n\n  return cloned;\n}\n\nclass Node {\n  constructor(defaults = {}) {\n    this.raws = {};\n    this[isClean] = false;\n\n    for (let name in defaults) {\n      if (name === 'nodes') {\n        this.nodes = [];\n\n        for (let node of defaults[name]) {\n          if (typeof node.clone === 'function') {\n            this.append(node.clone());\n          } else {\n            this.append(node);\n          }\n        }\n      } else {\n        this[name] = defaults[name];\n      }\n    }\n  }\n\n  error(message, opts = {}) {\n    if (this.source) {\n      let pos = this.positionBy(opts);\n      return this.source.input.error(message, pos.line, pos.column, opts);\n    }\n\n    return new CssSyntaxError(message);\n  }\n\n  warn(result, text, opts) {\n    let data = {\n      node: this\n    };\n\n    for (let i in opts) data[i] = opts[i];\n\n    return result.warn(text, data);\n  }\n\n  remove() {\n    if (this.parent) {\n      this.parent.removeChild(this);\n    }\n\n    this.parent = undefined;\n    return this;\n  }\n\n  toString(stringifier = stringify) {\n    if (stringifier.stringify) stringifier = stringifier.stringify;\n    let result = '';\n    stringifier(this, i => {\n      result += i;\n    });\n    return result;\n  }\n\n  assign(overrides = {}) {\n    for (let name in overrides) {\n      this[name] = overrides[name];\n    }\n\n    return this;\n  }\n\n  clone(overrides = {}) {\n    let cloned = cloneNode(this);\n\n    for (let name in overrides) {\n      cloned[name] = overrides[name];\n    }\n\n    return cloned;\n  }\n\n  cloneBefore(overrides = {}) {\n    let cloned = this.clone(overrides);\n    this.parent.insertBefore(this, cloned);\n    return cloned;\n  }\n\n  cloneAfter(overrides = {}) {\n    let cloned = this.clone(overrides);\n    this.parent.insertAfter(this, cloned);\n    return cloned;\n  }\n\n  replaceWith(...nodes) {\n    if (this.parent) {\n      let bookmark = this;\n      let foundSelf = false;\n\n      for (let node of nodes) {\n        if (node === this) {\n          foundSelf = true;\n        } else if (foundSelf) {\n          this.parent.insertAfter(bookmark, node);\n          bookmark = node;\n        } else {\n          this.parent.insertBefore(bookmark, node);\n        }\n      }\n\n      if (!foundSelf) {\n        this.remove();\n      }\n    }\n\n    return this;\n  }\n\n  next() {\n    if (!this.parent) return undefined;\n    let index = this.parent.index(this);\n    return this.parent.nodes[index + 1];\n  }\n\n  prev() {\n    if (!this.parent) return undefined;\n    let index = this.parent.index(this);\n    return this.parent.nodes[index - 1];\n  }\n\n  before(add) {\n    this.parent.insertBefore(this, add);\n    return this;\n  }\n\n  after(add) {\n    this.parent.insertAfter(this, add);\n    return this;\n  }\n\n  root() {\n    let result = this;\n\n    while (result.parent && result.parent.type !== 'document') {\n      result = result.parent;\n    }\n\n    return result;\n  }\n\n  raw(prop, defaultType) {\n    let str = new Stringifier();\n    return str.raw(this, prop, defaultType);\n  }\n\n  cleanRaws(keepBetween) {\n    delete this.raws.before;\n    delete this.raws.after;\n    if (!keepBetween) delete this.raws.between;\n  }\n\n  toJSON(_, inputs) {\n    let fixed = {};\n    let emitInputs = inputs == null;\n    inputs = inputs || new Map();\n    let inputsNextIndex = 0;\n\n    for (let name in this) {\n      if (!Object.prototype.hasOwnProperty.call(this, name)) {\n        // istanbul ignore next\n        continue;\n      }\n\n      if (name === 'parent' || name === 'proxyCache') continue;\n      let value = this[name];\n\n      if (Array.isArray(value)) {\n        fixed[name] = value.map(i => {\n          if (typeof i === 'object' && i.toJSON) {\n            return i.toJSON(null, inputs);\n          } else {\n            return i;\n          }\n        });\n      } else if (typeof value === 'object' && value.toJSON) {\n        fixed[name] = value.toJSON(null, inputs);\n      } else if (name === 'source') {\n        let inputId = inputs.get(value.input);\n\n        if (inputId == null) {\n          inputId = inputsNextIndex;\n          inputs.set(value.input, inputsNextIndex);\n          inputsNextIndex++;\n        }\n\n        fixed[name] = {\n          inputId,\n          start: value.start,\n          end: value.end\n        };\n      } else {\n        fixed[name] = value;\n      }\n    }\n\n    if (emitInputs) {\n      fixed.inputs = [...inputs.keys()].map(input => input.toJSON());\n    }\n\n    return fixed;\n  }\n\n  positionInside(index) {\n    let string = this.toString();\n    let column = this.source.start.column;\n    let line = this.source.start.line;\n\n    for (let i = 0; i < index; i++) {\n      if (string[i] === '\\n') {\n        column = 1;\n        line += 1;\n      } else {\n        column += 1;\n      }\n    }\n\n    return {\n      line,\n      column\n    };\n  }\n\n  positionBy(opts) {\n    let pos = this.source.start;\n\n    if (opts.index) {\n      pos = this.positionInside(opts.index);\n    } else if (opts.word) {\n      let index = this.toString().indexOf(opts.word);\n      if (index !== -1) pos = this.positionInside(index);\n    }\n\n    return pos;\n  }\n\n  getProxyProcessor() {\n    return {\n      set(node, prop, value) {\n        if (node[prop] === value) return true;\n        node[prop] = value;\n\n        if (prop === 'prop' || prop === 'value' || prop === 'name' || prop === 'params' || prop === 'important' || prop === 'text') {\n          node.markDirty();\n        }\n\n        return true;\n      },\n\n      get(node, prop) {\n        if (prop === 'proxyOf') {\n          return node;\n        } else if (prop === 'root') {\n          return () => node.root().toProxy();\n        } else {\n          return node[prop];\n        }\n      }\n\n    };\n  }\n\n  toProxy() {\n    if (!this.proxyCache) {\n      this.proxyCache = new Proxy(this, this.getProxyProcessor());\n    }\n\n    return this.proxyCache;\n  }\n\n  addToError(error) {\n    error.postcssNode = this;\n\n    if (error.stack && this.source && /\\n\\s{4}at /.test(error.stack)) {\n      let s = this.source;\n      error.stack = error.stack.replace(/\\n\\s{4}at /, `$&${s.input.from}:${s.start.line}:${s.start.column}$&`);\n    }\n\n    return error;\n  }\n\n  markDirty() {\n    if (this[isClean]) {\n      this[isClean] = false;\n      let next = this;\n\n      while (next = next.parent) {\n        next[isClean] = false;\n      }\n    }\n  }\n\n  get proxyOf() {\n    return this;\n  }\n\n}\n\nmodule.exports = Node;\nNode.default = Node;","map":{"version":3,"sources":["/Users/seito/Documents/develop/count-jp/my-app/node_modules/postcss-js/node_modules/postcss/lib/node.js"],"names":["CssSyntaxError","require","Stringifier","isClean","stringify","cloneNode","obj","parent","cloned","constructor","i","Object","prototype","hasOwnProperty","call","value","type","Array","isArray","map","j","Node","defaults","raws","name","nodes","node","clone","append","error","message","opts","source","pos","positionBy","input","line","column","warn","result","text","data","remove","removeChild","undefined","toString","stringifier","assign","overrides","cloneBefore","insertBefore","cloneAfter","insertAfter","replaceWith","bookmark","foundSelf","next","index","prev","before","add","after","root","raw","prop","defaultType","str","cleanRaws","keepBetween","between","toJSON","_","inputs","fixed","emitInputs","Map","inputsNextIndex","inputId","get","set","start","end","keys","positionInside","string","word","indexOf","getProxyProcessor","markDirty","toProxy","proxyCache","Proxy","addToError","postcssNode","stack","test","s","replace","from","proxyOf","module","exports","default"],"mappings":"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","sourcesContent":["'use strict'\n\nlet CssSyntaxError = require('./css-syntax-error')\nlet Stringifier = require('./stringifier')\nlet { isClean } = require('./symbols')\nlet stringify = require('./stringify')\n\nfunction cloneNode(obj, parent) {\n  let cloned = new obj.constructor()\n\n  for (let i in obj) {\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) {\n      // istanbul ignore next\n      continue\n    }\n    if (i === 'proxyCache') continue\n    let value = obj[i]\n    let type = typeof value\n\n    if (i === 'parent' && type === 'object') {\n      if (parent) cloned[i] = parent\n    } else if (i === 'source') {\n      cloned[i] = value\n    } else if (Array.isArray(value)) {\n      cloned[i] = value.map(j => cloneNode(j, cloned))\n    } else {\n      if (type === 'object' && value !== null) value = cloneNode(value)\n      cloned[i] = value\n    }\n  }\n\n  return cloned\n}\n\nclass Node {\n  constructor(defaults = {}) {\n    this.raws = {}\n    this[isClean] = false\n\n    for (let name in defaults) {\n      if (name === 'nodes') {\n        this.nodes = []\n        for (let node of defaults[name]) {\n          if (typeof node.clone === 'function') {\n            this.append(node.clone())\n          } else {\n            this.append(node)\n          }\n        }\n      } else {\n        this[name] = defaults[name]\n      }\n    }\n  }\n\n  error(message, opts = {}) {\n    if (this.source) {\n      let pos = this.positionBy(opts)\n      return this.source.input.error(message, pos.line, pos.column, opts)\n    }\n    return new CssSyntaxError(message)\n  }\n\n  warn(result, text, opts) {\n    let data = { node: this }\n    for (let i in opts) data[i] = opts[i]\n    return result.warn(text, data)\n  }\n\n  remove() {\n    if (this.parent) {\n      this.parent.removeChild(this)\n    }\n    this.parent = undefined\n    return this\n  }\n\n  toString(stringifier = stringify) {\n    if (stringifier.stringify) stringifier = stringifier.stringify\n    let result = ''\n    stringifier(this, i => {\n      result += i\n    })\n    return result\n  }\n\n  assign(overrides = {}) {\n    for (let name in overrides) {\n      this[name] = overrides[name]\n    }\n    return this\n  }\n\n  clone(overrides = {}) {\n    let cloned = cloneNode(this)\n    for (let name in overrides) {\n      cloned[name] = overrides[name]\n    }\n    return cloned\n  }\n\n  cloneBefore(overrides = {}) {\n    let cloned = this.clone(overrides)\n    this.parent.insertBefore(this, cloned)\n    return cloned\n  }\n\n  cloneAfter(overrides = {}) {\n    let cloned = this.clone(overrides)\n    this.parent.insertAfter(this, cloned)\n    return cloned\n  }\n\n  replaceWith(...nodes) {\n    if (this.parent) {\n      let bookmark = this\n      let foundSelf = false\n      for (let node of nodes) {\n        if (node === this) {\n          foundSelf = true\n        } else if (foundSelf) {\n          this.parent.insertAfter(bookmark, node)\n          bookmark = node\n        } else {\n          this.parent.insertBefore(bookmark, node)\n        }\n      }\n\n      if (!foundSelf) {\n        this.remove()\n      }\n    }\n\n    return this\n  }\n\n  next() {\n    if (!this.parent) return undefined\n    let index = this.parent.index(this)\n    return this.parent.nodes[index + 1]\n  }\n\n  prev() {\n    if (!this.parent) return undefined\n    let index = this.parent.index(this)\n    return this.parent.nodes[index - 1]\n  }\n\n  before(add) {\n    this.parent.insertBefore(this, add)\n    return this\n  }\n\n  after(add) {\n    this.parent.insertAfter(this, add)\n    return this\n  }\n\n  root() {\n    let result = this\n    while (result.parent && result.parent.type !== 'document') {\n      result = result.parent\n    }\n    return result\n  }\n\n  raw(prop, defaultType) {\n    let str = new Stringifier()\n    return str.raw(this, prop, defaultType)\n  }\n\n  cleanRaws(keepBetween) {\n    delete this.raws.before\n    delete this.raws.after\n    if (!keepBetween) delete this.raws.between\n  }\n\n  toJSON(_, inputs) {\n    let fixed = {}\n    let emitInputs = inputs == null\n    inputs = inputs || new Map()\n    let inputsNextIndex = 0\n\n    for (let name in this) {\n      if (!Object.prototype.hasOwnProperty.call(this, name)) {\n        // istanbul ignore next\n        continue\n      }\n      if (name === 'parent' || name === 'proxyCache') continue\n      let value = this[name]\n\n      if (Array.isArray(value)) {\n        fixed[name] = value.map(i => {\n          if (typeof i === 'object' && i.toJSON) {\n            return i.toJSON(null, inputs)\n          } else {\n            return i\n          }\n        })\n      } else if (typeof value === 'object' && value.toJSON) {\n        fixed[name] = value.toJSON(null, inputs)\n      } else if (name === 'source') {\n        let inputId = inputs.get(value.input)\n        if (inputId == null) {\n          inputId = inputsNextIndex\n          inputs.set(value.input, inputsNextIndex)\n          inputsNextIndex++\n        }\n        fixed[name] = {\n          inputId,\n          start: value.start,\n          end: value.end\n        }\n      } else {\n        fixed[name] = value\n      }\n    }\n\n    if (emitInputs) {\n      fixed.inputs = [...inputs.keys()].map(input => input.toJSON())\n    }\n\n    return fixed\n  }\n\n  positionInside(index) {\n    let string = this.toString()\n    let column = this.source.start.column\n    let line = this.source.start.line\n\n    for (let i = 0; i < index; i++) {\n      if (string[i] === '\\n') {\n        column = 1\n        line += 1\n      } else {\n        column += 1\n      }\n    }\n\n    return { line, column }\n  }\n\n  positionBy(opts) {\n    let pos = this.source.start\n    if (opts.index) {\n      pos = this.positionInside(opts.index)\n    } else if (opts.word) {\n      let index = this.toString().indexOf(opts.word)\n      if (index !== -1) pos = this.positionInside(index)\n    }\n    return pos\n  }\n\n  getProxyProcessor() {\n    return {\n      set(node, prop, value) {\n        if (node[prop] === value) return true\n        node[prop] = value\n        if (\n          prop === 'prop' ||\n          prop === 'value' ||\n          prop === 'name' ||\n          prop === 'params' ||\n          prop === 'important' ||\n          prop === 'text'\n        ) {\n          node.markDirty()\n        }\n        return true\n      },\n\n      get(node, prop) {\n        if (prop === 'proxyOf') {\n          return node\n        } else if (prop === 'root') {\n          return () => node.root().toProxy()\n        } else {\n          return node[prop]\n        }\n      }\n    }\n  }\n\n  toProxy() {\n    if (!this.proxyCache) {\n      this.proxyCache = new Proxy(this, this.getProxyProcessor())\n    }\n    return this.proxyCache\n  }\n\n  addToError(error) {\n    error.postcssNode = this\n    if (error.stack && this.source && /\\n\\s{4}at /.test(error.stack)) {\n      let s = this.source\n      error.stack = error.stack.replace(\n        /\\n\\s{4}at /,\n        `$&${s.input.from}:${s.start.line}:${s.start.column}$&`\n      )\n    }\n    return error\n  }\n\n  markDirty() {\n    if (this[isClean]) {\n      this[isClean] = false\n      let next = this\n      while ((next = next.parent)) {\n        next[isClean] = false\n      }\n    }\n  }\n\n  get proxyOf() {\n    return this\n  }\n}\n\nmodule.exports = Node\nNode.default = Node\n"]},"metadata":{},"sourceType":"script"}