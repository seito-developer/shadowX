{"ast":null,"code":"const fs = require('fs');\n\nconst path = require('path');\n\nconst fastGlob = require('fast-glob');\n\nconst parseGlob = require('parse-glob');\n\nconst sharedState = require('./sharedState');\n\nconst {\n  generateRules\n} = require('./generateRules');\n\nconst {\n  bigSign,\n  cloneNodes\n} = require('./utils');\n\nlet env = sharedState.env;\nlet contentMatchCache = sharedState.contentMatchCache;\nconst BROAD_MATCH_GLOBAL_REGEXP = /[^<>\"'`\\s]*[^<>\"'`\\s:]/g;\nconst INNER_MATCH_GLOBAL_REGEXP = /[^<>\"'`\\s.(){}[\\]#=%]*[^<>\"'`\\s.(){}[\\]#=%:]/g;\n\nfunction getDefaultExtractor(fileExtension) {\n  return function (content) {\n    if (fileExtension === 'svelte') {\n      content = content.replace(/\\sclass:/g, ' ');\n    }\n\n    let broadMatches = content.match(BROAD_MATCH_GLOBAL_REGEXP) || [];\n    let innerMatches = content.match(INNER_MATCH_GLOBAL_REGEXP) || [];\n    return [...broadMatches, ...innerMatches];\n  };\n}\n\nfunction getExtractor(fileName, tailwindConfig) {\n  const purgeOptions = tailwindConfig && tailwindConfig.purge && tailwindConfig.purge.options;\n  const fileExtension = path.extname(fileName).slice(1);\n\n  if (!purgeOptions) {\n    return getDefaultExtractor(fileExtension);\n  }\n\n  const fileSpecificExtractor = (purgeOptions.extractors || []).find(extractor => extractor.extensions.includes(fileExtension));\n\n  if (fileSpecificExtractor) {\n    return fileSpecificExtractor.extractor;\n  }\n\n  return purgeOptions.defaultExtractor || getDefaultExtractor(fileExtension);\n} // Scans template contents for possible classes. This is a hot path on initial build but\n// not too important for subsequent builds. The faster the better though — if we can speed\n// up these regexes by 50% that could cut initial build time by like 20%.\n\n\nfunction getClassCandidates(content, extractor, contentMatchCache, candidates, seen) {\n  for (let line of content.split('\\n')) {\n    line = line.trim();\n\n    if (seen.has(line)) {\n      continue;\n    }\n\n    seen.add(line);\n\n    if (contentMatchCache.has(line)) {\n      for (let match of contentMatchCache.get(line)) {\n        candidates.add(match);\n      }\n    } else {\n      let extractorMatches = extractor(line);\n      let lineMatchesSet = new Set(extractorMatches);\n\n      for (let match of lineMatchesSet) {\n        candidates.add(match);\n      }\n\n      contentMatchCache.set(line, lineMatchesSet);\n    }\n  }\n}\n\nfunction buildStylesheet(rules, context) {\n  let sortedRules = rules.sort(([a], [z]) => bigSign(a - z));\n  let returnValue = {\n    base: new Set(),\n    components: new Set(),\n    utilities: new Set(),\n    screens: new Set()\n  };\n\n  for (let [sort, rule] of sortedRules) {\n    if (sort >= context.minimumScreen) {\n      returnValue.screens.add(rule);\n      continue;\n    }\n\n    if (sort & context.layerOrder.base) {\n      returnValue.base.add(rule);\n      continue;\n    }\n\n    if (sort & context.layerOrder.components) {\n      returnValue.components.add(rule);\n      continue;\n    }\n\n    if (sort & context.layerOrder.utilities) {\n      returnValue.utilities.add(rule);\n      continue;\n    }\n  }\n\n  return returnValue;\n}\n\nfunction expandTailwindAtRules(context, registerDependency) {\n  return root => {\n    let foundTailwind = false;\n    let layerNodes = {\n      base: null,\n      components: null,\n      utilities: null,\n      screens: null\n    }; // Make sure this file contains Tailwind directives. If not, we can save\n    // a lot of work and bail early. Also we don't have to register our touch\n    // file as a dependency since the output of this CSS does not depend on\n    // the source of any templates. Think Vue <style> blocks for example.\n\n    root.walkAtRules('tailwind', rule => {\n      foundTailwind = true;\n\n      if (rule.params === 'base') {\n        layerNodes.base = rule;\n      }\n\n      if (rule.params === 'components') {\n        layerNodes.components = rule;\n      }\n\n      if (rule.params === 'utilities') {\n        layerNodes.utilities = rule;\n      }\n\n      if (rule.params === 'screens') {\n        layerNodes.screens = rule;\n      }\n    });\n\n    if (!foundTailwind) {\n      return root;\n    } // ---\n\n\n    if (sharedState.env.TAILWIND_DISABLE_TOUCH) {\n      for (let maybeGlob of context.candidateFiles) {\n        let {\n          is: {\n            glob: isGlob\n          },\n          base\n        } = parseGlob(maybeGlob);\n\n        if (isGlob) {\n          // register base dir as `dependency` _and_ `context-dependency` for\n          // increased compatibility\n          registerDependency(path.resolve(base));\n          registerDependency(path.resolve(base), 'context-dependency');\n        } else {\n          registerDependency(path.resolve(maybeGlob));\n        }\n      }\n\n      env.DEBUG && console.time('Finding changed files');\n      let files = fastGlob.sync(context.candidateFiles);\n\n      for (let file of files) {\n        let prevModified = context.fileModifiedMap.has(file) ? context.fileModifiedMap.get(file) : -Infinity;\n        let modified = fs.statSync(file).mtimeMs;\n\n        if (!context.scannedContent || modified > prevModified) {\n          context.changedFiles.add(file);\n          context.fileModifiedMap.set(file, modified);\n        }\n      }\n\n      context.scannedContent = true;\n      env.DEBUG && console.timeEnd('Finding changed files');\n    } else {\n      // Register our temp file as a dependency — we write to this file\n      // to trigger rebuilds.\n      if (context.touchFile) {\n        registerDependency(context.touchFile);\n      } // If we're not set up and watching files ourselves, we need to do\n      // the work of grabbing all of the template files for candidate\n      // detection.\n\n\n      if (!context.scannedContent) {\n        let files = fastGlob.sync(context.candidateFiles);\n\n        for (let file of files) {\n          context.changedFiles.add(file);\n        }\n\n        context.scannedContent = true;\n      }\n    } // ---\n    // Find potential rules in changed files\n\n\n    let candidates = new Set(['*']);\n    let seen = new Set();\n    env.DEBUG && console.time('Reading changed files');\n\n    for (let file of context.changedFiles) {\n      let content = fs.readFileSync(file, 'utf8');\n      let extractor = getExtractor(file, context.tailwindConfig);\n      getClassCandidates(content, extractor, contentMatchCache, candidates, seen);\n    }\n\n    env.DEBUG && console.timeEnd('Reading changed files'); // ---\n    // Generate the actual CSS\n\n    let classCacheCount = context.classCache.size;\n    env.DEBUG && console.time('Generate rules');\n    let rules = generateRules(candidates, context);\n    env.DEBUG && console.timeEnd('Generate rules'); // We only ever add to the classCache, so if it didn't grow, there is nothing new.\n\n    env.DEBUG && console.time('Build stylesheet');\n\n    if (context.stylesheetCache === null || context.classCache.size !== classCacheCount) {\n      for (let rule of rules) {\n        context.ruleCache.add(rule);\n      }\n\n      context.stylesheetCache = buildStylesheet([...context.ruleCache], context);\n    }\n\n    env.DEBUG && console.timeEnd('Build stylesheet');\n    let {\n      base: baseNodes,\n      components: componentNodes,\n      utilities: utilityNodes,\n      screens: screenNodes\n    } = context.stylesheetCache; // ---\n    // Replace any Tailwind directives with generated CSS\n\n    if (layerNodes.base) {\n      layerNodes.base.before(cloneNodes([...baseNodes]));\n      layerNodes.base.remove();\n    }\n\n    if (layerNodes.components) {\n      layerNodes.components.before(cloneNodes([...componentNodes]));\n      layerNodes.components.remove();\n    }\n\n    if (layerNodes.utilities) {\n      layerNodes.utilities.before(cloneNodes([...utilityNodes]));\n      layerNodes.utilities.remove();\n    }\n\n    if (layerNodes.screens) {\n      layerNodes.screens.before(cloneNodes([...screenNodes]));\n      layerNodes.screens.remove();\n    } else {\n      root.append(cloneNodes([...screenNodes]));\n    } // ---\n\n\n    if (env.DEBUG) {\n      console.log('Changed files: ', context.changedFiles.size);\n      console.log('Potential classes: ', candidates.size);\n      console.log('Active contexts: ', sharedState.contextSourcesMap.size);\n      console.log('Content match entries', contentMatchCache.size);\n    } // Clear the cache for the changed files\n\n\n    context.changedFiles.clear();\n  };\n}\n\nmodule.exports = expandTailwindAtRules;","map":{"version":3,"sources":["/Users/seito/Documents/develop/count-jp/my-app/node_modules/tailwindcss/jit/lib/expandTailwindAtRules.js"],"names":["fs","require","path","fastGlob","parseGlob","sharedState","generateRules","bigSign","cloneNodes","env","contentMatchCache","BROAD_MATCH_GLOBAL_REGEXP","INNER_MATCH_GLOBAL_REGEXP","getDefaultExtractor","fileExtension","content","replace","broadMatches","match","innerMatches","getExtractor","fileName","tailwindConfig","purgeOptions","purge","options","extname","slice","fileSpecificExtractor","extractors","find","extractor","extensions","includes","defaultExtractor","getClassCandidates","candidates","seen","line","split","trim","has","add","get","extractorMatches","lineMatchesSet","Set","set","buildStylesheet","rules","context","sortedRules","sort","a","z","returnValue","base","components","utilities","screens","rule","minimumScreen","layerOrder","expandTailwindAtRules","registerDependency","root","foundTailwind","layerNodes","walkAtRules","params","TAILWIND_DISABLE_TOUCH","maybeGlob","candidateFiles","is","glob","isGlob","resolve","DEBUG","console","time","files","sync","file","prevModified","fileModifiedMap","Infinity","modified","statSync","mtimeMs","scannedContent","changedFiles","timeEnd","touchFile","readFileSync","classCacheCount","classCache","size","stylesheetCache","ruleCache","baseNodes","componentNodes","utilityNodes","screenNodes","before","remove","append","log","contextSourcesMap","clear","module","exports"],"mappings":"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","sourcesContent":["const fs = require('fs')\nconst path = require('path')\nconst fastGlob = require('fast-glob')\nconst parseGlob = require('parse-glob')\nconst sharedState = require('./sharedState')\nconst { generateRules } = require('./generateRules')\nconst { bigSign, cloneNodes } = require('./utils')\n\nlet env = sharedState.env\nlet contentMatchCache = sharedState.contentMatchCache\n\nconst BROAD_MATCH_GLOBAL_REGEXP = /[^<>\"'`\\s]*[^<>\"'`\\s:]/g\nconst INNER_MATCH_GLOBAL_REGEXP = /[^<>\"'`\\s.(){}[\\]#=%]*[^<>\"'`\\s.(){}[\\]#=%:]/g\n\nfunction getDefaultExtractor(fileExtension) {\n  return function (content) {\n    if (fileExtension === 'svelte') {\n      content = content.replace(/\\sclass:/g, ' ')\n    }\n    let broadMatches = content.match(BROAD_MATCH_GLOBAL_REGEXP) || []\n    let innerMatches = content.match(INNER_MATCH_GLOBAL_REGEXP) || []\n\n    return [...broadMatches, ...innerMatches]\n  }\n}\n\nfunction getExtractor(fileName, tailwindConfig) {\n  const purgeOptions = tailwindConfig && tailwindConfig.purge && tailwindConfig.purge.options\n  const fileExtension = path.extname(fileName).slice(1)\n\n  if (!purgeOptions) {\n    return getDefaultExtractor(fileExtension)\n  }\n\n  const fileSpecificExtractor = (purgeOptions.extractors || []).find((extractor) =>\n    extractor.extensions.includes(fileExtension)\n  )\n\n  if (fileSpecificExtractor) {\n    return fileSpecificExtractor.extractor\n  }\n\n  return purgeOptions.defaultExtractor || getDefaultExtractor(fileExtension)\n}\n\n// Scans template contents for possible classes. This is a hot path on initial build but\n// not too important for subsequent builds. The faster the better though — if we can speed\n// up these regexes by 50% that could cut initial build time by like 20%.\nfunction getClassCandidates(content, extractor, contentMatchCache, candidates, seen) {\n  for (let line of content.split('\\n')) {\n    line = line.trim()\n\n    if (seen.has(line)) {\n      continue\n    }\n    seen.add(line)\n\n    if (contentMatchCache.has(line)) {\n      for (let match of contentMatchCache.get(line)) {\n        candidates.add(match)\n      }\n    } else {\n      let extractorMatches = extractor(line)\n      let lineMatchesSet = new Set(extractorMatches)\n\n      for (let match of lineMatchesSet) {\n        candidates.add(match)\n      }\n\n      contentMatchCache.set(line, lineMatchesSet)\n    }\n  }\n}\n\nfunction buildStylesheet(rules, context) {\n  let sortedRules = rules.sort(([a], [z]) => bigSign(a - z))\n\n  let returnValue = {\n    base: new Set(),\n    components: new Set(),\n    utilities: new Set(),\n    screens: new Set(),\n  }\n\n  for (let [sort, rule] of sortedRules) {\n    if (sort >= context.minimumScreen) {\n      returnValue.screens.add(rule)\n      continue\n    }\n\n    if (sort & context.layerOrder.base) {\n      returnValue.base.add(rule)\n      continue\n    }\n\n    if (sort & context.layerOrder.components) {\n      returnValue.components.add(rule)\n      continue\n    }\n\n    if (sort & context.layerOrder.utilities) {\n      returnValue.utilities.add(rule)\n      continue\n    }\n  }\n\n  return returnValue\n}\n\nfunction expandTailwindAtRules(context, registerDependency) {\n  return (root) => {\n    let foundTailwind = false\n    let layerNodes = {\n      base: null,\n      components: null,\n      utilities: null,\n      screens: null,\n    }\n\n    // Make sure this file contains Tailwind directives. If not, we can save\n    // a lot of work and bail early. Also we don't have to register our touch\n    // file as a dependency since the output of this CSS does not depend on\n    // the source of any templates. Think Vue <style> blocks for example.\n    root.walkAtRules('tailwind', (rule) => {\n      foundTailwind = true\n\n      if (rule.params === 'base') {\n        layerNodes.base = rule\n      }\n\n      if (rule.params === 'components') {\n        layerNodes.components = rule\n      }\n\n      if (rule.params === 'utilities') {\n        layerNodes.utilities = rule\n      }\n\n      if (rule.params === 'screens') {\n        layerNodes.screens = rule\n      }\n    })\n\n    if (!foundTailwind) {\n      return root\n    }\n\n    // ---\n\n    if (sharedState.env.TAILWIND_DISABLE_TOUCH) {\n      for (let maybeGlob of context.candidateFiles) {\n        let {\n          is: { glob: isGlob },\n          base,\n        } = parseGlob(maybeGlob)\n\n        if (isGlob) {\n          // register base dir as `dependency` _and_ `context-dependency` for\n          // increased compatibility\n          registerDependency(path.resolve(base))\n          registerDependency(path.resolve(base), 'context-dependency')\n        } else {\n          registerDependency(path.resolve(maybeGlob))\n        }\n      }\n\n      env.DEBUG && console.time('Finding changed files')\n      let files = fastGlob.sync(context.candidateFiles)\n      for (let file of files) {\n        let prevModified = context.fileModifiedMap.has(file)\n          ? context.fileModifiedMap.get(file)\n          : -Infinity\n        let modified = fs.statSync(file).mtimeMs\n\n        if (!context.scannedContent || modified > prevModified) {\n          context.changedFiles.add(file)\n          context.fileModifiedMap.set(file, modified)\n        }\n      }\n      context.scannedContent = true\n      env.DEBUG && console.timeEnd('Finding changed files')\n    } else {\n      // Register our temp file as a dependency — we write to this file\n      // to trigger rebuilds.\n      if (context.touchFile) {\n        registerDependency(context.touchFile)\n      }\n\n      // If we're not set up and watching files ourselves, we need to do\n      // the work of grabbing all of the template files for candidate\n      // detection.\n      if (!context.scannedContent) {\n        let files = fastGlob.sync(context.candidateFiles)\n        for (let file of files) {\n          context.changedFiles.add(file)\n        }\n        context.scannedContent = true\n      }\n    }\n\n    // ---\n\n    // Find potential rules in changed files\n    let candidates = new Set(['*'])\n    let seen = new Set()\n\n    env.DEBUG && console.time('Reading changed files')\n    for (let file of context.changedFiles) {\n      let content = fs.readFileSync(file, 'utf8')\n      let extractor = getExtractor(file, context.tailwindConfig)\n      getClassCandidates(content, extractor, contentMatchCache, candidates, seen)\n    }\n    env.DEBUG && console.timeEnd('Reading changed files')\n\n    // ---\n\n    // Generate the actual CSS\n    let classCacheCount = context.classCache.size\n\n    env.DEBUG && console.time('Generate rules')\n    let rules = generateRules(candidates, context)\n    env.DEBUG && console.timeEnd('Generate rules')\n\n    // We only ever add to the classCache, so if it didn't grow, there is nothing new.\n    env.DEBUG && console.time('Build stylesheet')\n    if (context.stylesheetCache === null || context.classCache.size !== classCacheCount) {\n      for (let rule of rules) {\n        context.ruleCache.add(rule)\n      }\n\n      context.stylesheetCache = buildStylesheet([...context.ruleCache], context)\n    }\n    env.DEBUG && console.timeEnd('Build stylesheet')\n\n    let {\n      base: baseNodes,\n      components: componentNodes,\n      utilities: utilityNodes,\n      screens: screenNodes,\n    } = context.stylesheetCache\n\n    // ---\n\n    // Replace any Tailwind directives with generated CSS\n\n    if (layerNodes.base) {\n      layerNodes.base.before(cloneNodes([...baseNodes]))\n      layerNodes.base.remove()\n    }\n\n    if (layerNodes.components) {\n      layerNodes.components.before(cloneNodes([...componentNodes]))\n      layerNodes.components.remove()\n    }\n\n    if (layerNodes.utilities) {\n      layerNodes.utilities.before(cloneNodes([...utilityNodes]))\n      layerNodes.utilities.remove()\n    }\n\n    if (layerNodes.screens) {\n      layerNodes.screens.before(cloneNodes([...screenNodes]))\n      layerNodes.screens.remove()\n    } else {\n      root.append(cloneNodes([...screenNodes]))\n    }\n\n    // ---\n\n    if (env.DEBUG) {\n      console.log('Changed files: ', context.changedFiles.size)\n      console.log('Potential classes: ', candidates.size)\n      console.log('Active contexts: ', sharedState.contextSourcesMap.size)\n      console.log('Content match entries', contentMatchCache.size)\n    }\n\n    // Clear the cache for the changed files\n    context.changedFiles.clear()\n  }\n}\n\nmodule.exports = expandTailwindAtRules\n"]},"metadata":{},"sourceType":"script"}