{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _cssSyntaxError = require('./css-syntax-error');\n\nvar _cssSyntaxError2 = _interopRequireDefault(_cssSyntaxError);\n\nvar _stringifier = require('./stringifier');\n\nvar _stringifier2 = _interopRequireDefault(_stringifier);\n\nvar _stringify = require('./stringify');\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _warnOnce = require('./warn-once');\n\nvar _warnOnce2 = _interopRequireDefault(_warnOnce);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar cloneNode = function cloneNode(obj, parent) {\n  var cloned = new obj.constructor();\n\n  for (var i in obj) {\n    if (!obj.hasOwnProperty(i)) continue;\n    var value = obj[i];\n    var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);\n\n    if (i === 'parent' && type === 'object') {\n      if (parent) cloned[i] = parent;\n    } else if (i === 'source') {\n      cloned[i] = value;\n    } else if (value instanceof Array) {\n      cloned[i] = value.map(function (j) {\n        return cloneNode(j, cloned);\n      });\n    } else {\n      if (type === 'object' && value !== null) value = cloneNode(value);\n      cloned[i] = value;\n    }\n  }\n\n  return cloned;\n};\n/**\n * All node classes inherit the following common methods.\n *\n * @abstract\n */\n\n\nvar Node = function () {\n  /**\n   * @param {object} [defaults] - value for node properties\n   */\n  function Node() {\n    var defaults = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Node);\n\n    this.raws = {};\n\n    if ((typeof defaults === 'undefined' ? 'undefined' : _typeof(defaults)) !== 'object' && typeof defaults !== 'undefined') {\n      throw new Error('PostCSS nodes constructor accepts object, not ' + JSON.stringify(defaults));\n    }\n\n    for (var name in defaults) {\n      this[name] = defaults[name];\n    }\n  }\n  /**\n   * Returns a CssSyntaxError instance containing the original position\n   * of the node in the source, showing line and column numbers and also\n   * a small excerpt to facilitate debugging.\n   *\n   * If present, an input source map will be used to get the original position\n   * of the source, even from a previous compilation step\n   * (e.g., from Sass compilation).\n   *\n   * This method produces very useful error messages.\n   *\n   * @param {string} message     - error description\n   * @param {object} [opts]      - options\n   * @param {string} opts.plugin - plugin name that created this error.\n   *                               PostCSS will set it automatically.\n   * @param {string} opts.word   - a word inside a node’s string that should\n   *                               be highlighted as the source of the error\n   * @param {number} opts.index  - an index inside a node’s string that should\n   *                               be highlighted as the source of the error\n   *\n   * @return {CssSyntaxError} error object to throw it\n   *\n   * @example\n   * if ( !variables[name] ) {\n   *   throw decl.error('Unknown variable ' + name, { word: name });\n   *   // CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black\n   *   //   color: $black\n   *   // a\n   *   //          ^\n   *   //   background: white\n   * }\n   */\n\n\n  Node.prototype.error = function error(message) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (this.source) {\n      var pos = this.positionBy(opts);\n      return this.source.input.error(message, pos.line, pos.column, opts);\n    } else {\n      return new _cssSyntaxError2.default(message);\n    }\n  };\n  /**\n   * This method is provided as a convenience wrapper for {@link Result#warn}.\n   *\n   * @param {Result} result      - the {@link Result} instance\n   *                               that will receive the warning\n   * @param {string} text        - warning message\n   * @param {object} [opts]      - options\n   * @param {string} opts.plugin - plugin name that created this warning.\n   *                               PostCSS will set it automatically.\n   * @param {string} opts.word   - a word inside a node’s string that should\n   *                               be highlighted as the source of the warning\n   * @param {number} opts.index  - an index inside a node’s string that should\n   *                               be highlighted as the source of the warning\n   *\n   * @return {Warning} created warning object\n   *\n   * @example\n   * const plugin = postcss.plugin('postcss-deprecated', () => {\n   *   return (root, result) => {\n   *     root.walkDecls('bad', decl => {\n   *       decl.warn(result, 'Deprecated property bad');\n   *     });\n   *   };\n   * });\n   */\n\n\n  Node.prototype.warn = function warn(result, text, opts) {\n    var data = {\n      node: this\n    };\n\n    for (var i in opts) {\n      data[i] = opts[i];\n    }\n\n    return result.warn(text, data);\n  };\n  /**\n   * Removes the node from its parent and cleans the parent properties\n   * from the node and its children.\n   *\n   * @example\n   * if ( decl.prop.match(/^-webkit-/) ) {\n   *   decl.remove();\n   * }\n   *\n   * @return {Node} node to make calls chain\n   */\n\n\n  Node.prototype.remove = function remove() {\n    if (this.parent) {\n      this.parent.removeChild(this);\n    }\n\n    this.parent = undefined;\n    return this;\n  };\n  /**\n   * Returns a CSS string representing the node.\n   *\n   * @param {stringifier|syntax} [stringifier] - a syntax to use\n   *                                             in string generation\n   *\n   * @return {string} CSS string of this node\n   *\n   * @example\n   * postcss.rule({ selector: 'a' }).toString() //=> \"a {}\"\n   */\n\n\n  Node.prototype.toString = function toString() {\n    var stringifier = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _stringify2.default;\n    if (stringifier.stringify) stringifier = stringifier.stringify;\n    var result = '';\n    stringifier(this, function (i) {\n      result += i;\n    });\n    return result;\n  };\n  /**\n   * Returns a clone of the node.\n   *\n   * The resulting cloned node and its (cloned) children will have\n   * a clean parent and code style properties.\n   *\n   * @param {object} [overrides] - new properties to override in the clone.\n   *\n   * @example\n   * const cloned = decl.clone({ prop: '-moz-' + decl.prop });\n   * cloned.raws.before  //=> undefined\n   * cloned.parent       //=> undefined\n   * cloned.toString()   //=> -moz-transform: scale(0)\n   *\n   * @return {Node} clone of the node\n   */\n\n\n  Node.prototype.clone = function clone() {\n    var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var cloned = cloneNode(this);\n\n    for (var name in overrides) {\n      cloned[name] = overrides[name];\n    }\n\n    return cloned;\n  };\n  /**\n   * Shortcut to clone the node and insert the resulting cloned node\n   * before the current node.\n   *\n   * @param {object} [overrides] - new properties to override in the clone.\n   *\n   * @example\n   * decl.cloneBefore({ prop: '-moz-' + decl.prop });\n   *\n   * @return {Node} - new node\n   */\n\n\n  Node.prototype.cloneBefore = function cloneBefore() {\n    var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var cloned = this.clone(overrides);\n    this.parent.insertBefore(this, cloned);\n    return cloned;\n  };\n  /**\n   * Shortcut to clone the node and insert the resulting cloned node\n   * after the current node.\n   *\n   * @param {object} [overrides] - new properties to override in the clone.\n   *\n   * @return {Node} - new node\n   */\n\n\n  Node.prototype.cloneAfter = function cloneAfter() {\n    var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var cloned = this.clone(overrides);\n    this.parent.insertAfter(this, cloned);\n    return cloned;\n  };\n  /**\n   * Inserts node(s) before the current node and removes the current node.\n   *\n   * @param {...Node} nodes - node(s) to replace current one\n   *\n   * @example\n   * if ( atrule.name == 'mixin' ) {\n   *   atrule.replaceWith(mixinRules[atrule.params]);\n   * }\n   *\n   * @return {Node} current node to methods chain\n   */\n\n\n  Node.prototype.replaceWith = function replaceWith() {\n    if (this.parent) {\n      for (var _len = arguments.length, nodes = Array(_len), _key = 0; _key < _len; _key++) {\n        nodes[_key] = arguments[_key];\n      }\n\n      for (var _iterator = nodes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref;\n\n        if (_isArray) {\n          if (_i >= _iterator.length) break;\n          _ref = _iterator[_i++];\n        } else {\n          _i = _iterator.next();\n          if (_i.done) break;\n          _ref = _i.value;\n        }\n\n        var node = _ref;\n        this.parent.insertBefore(this, node);\n      }\n\n      this.remove();\n    }\n\n    return this;\n  };\n\n  Node.prototype.moveTo = function moveTo(newParent) {\n    (0, _warnOnce2.default)('Node#moveTo was deprecated. Use Container#append.');\n    this.cleanRaws(this.root() === newParent.root());\n    this.remove();\n    newParent.append(this);\n    return this;\n  };\n\n  Node.prototype.moveBefore = function moveBefore(otherNode) {\n    (0, _warnOnce2.default)('Node#moveBefore was deprecated. Use Node#before.');\n    this.cleanRaws(this.root() === otherNode.root());\n    this.remove();\n    otherNode.parent.insertBefore(otherNode, this);\n    return this;\n  };\n\n  Node.prototype.moveAfter = function moveAfter(otherNode) {\n    (0, _warnOnce2.default)('Node#moveAfter was deprecated. Use Node#after.');\n    this.cleanRaws(this.root() === otherNode.root());\n    this.remove();\n    otherNode.parent.insertAfter(otherNode, this);\n    return this;\n  };\n  /**\n   * Returns the next child of the node’s parent.\n   * Returns `undefined` if the current node is the last child.\n   *\n   * @return {Node|undefined} next node\n   *\n   * @example\n   * if ( comment.text === 'delete next' ) {\n   *   const next = comment.next();\n   *   if ( next ) {\n   *     next.remove();\n   *   }\n   * }\n   */\n\n\n  Node.prototype.next = function next() {\n    if (!this.parent) return undefined;\n    var index = this.parent.index(this);\n    return this.parent.nodes[index + 1];\n  };\n  /**\n   * Returns the previous child of the node’s parent.\n   * Returns `undefined` if the current node is the first child.\n   *\n   * @return {Node|undefined} previous node\n   *\n   * @example\n   * const annotation = decl.prev();\n   * if ( annotation.type == 'comment' ) {\n   *  readAnnotation(annotation.text);\n   * }\n   */\n\n\n  Node.prototype.prev = function prev() {\n    if (!this.parent) return undefined;\n    var index = this.parent.index(this);\n    return this.parent.nodes[index - 1];\n  };\n  /**\n   * Insert new node before current node to current node’s parent.\n   *\n   * Just alias for `node.parent.insertBefore(node, add)`.\n   *\n   * @param {Node|object|string|Node[]} add - new node\n   *\n   * @return {Node} this node for methods chain.\n   *\n   * @example\n   * decl.before('content: \"\"');\n   */\n\n\n  Node.prototype.before = function before(add) {\n    this.parent.insertBefore(this, add);\n    return this;\n  };\n  /**\n   * Insert new node after current node to current node’s parent.\n   *\n   * Just alias for `node.parent.insertAfter(node, add)`.\n   *\n   * @param {Node|object|string|Node[]} add - new node\n   *\n   * @return {Node} this node for methods chain.\n   *\n   * @example\n   * decl.after('color: black');\n   */\n\n\n  Node.prototype.after = function after(add) {\n    this.parent.insertAfter(this, add);\n    return this;\n  };\n\n  Node.prototype.toJSON = function toJSON() {\n    var fixed = {};\n\n    for (var name in this) {\n      if (!this.hasOwnProperty(name)) continue;\n      if (name === 'parent') continue;\n      var value = this[name];\n\n      if (value instanceof Array) {\n        fixed[name] = value.map(function (i) {\n          if ((typeof i === 'undefined' ? 'undefined' : _typeof(i)) === 'object' && i.toJSON) {\n            return i.toJSON();\n          } else {\n            return i;\n          }\n        });\n      } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value.toJSON) {\n        fixed[name] = value.toJSON();\n      } else {\n        fixed[name] = value;\n      }\n    }\n\n    return fixed;\n  };\n  /**\n   * Returns a {@link Node#raws} value. If the node is missing\n   * the code style property (because the node was manually built or cloned),\n   * PostCSS will try to autodetect the code style property by looking\n   * at other nodes in the tree.\n   *\n   * @param {string} prop          - name of code style property\n   * @param {string} [defaultType] - name of default value, it can be missed\n   *                                 if the value is the same as prop\n   *\n   * @example\n   * const root = postcss.parse('a { background: white }');\n   * root.nodes[0].append({ prop: 'color', value: 'black' });\n   * root.nodes[0].nodes[1].raws.before   //=> undefined\n   * root.nodes[0].nodes[1].raw('before') //=> ' '\n   *\n   * @return {string} code style value\n   */\n\n\n  Node.prototype.raw = function raw(prop, defaultType) {\n    var str = new _stringifier2.default();\n    return str.raw(this, prop, defaultType);\n  };\n  /**\n   * Finds the Root instance of the node’s tree.\n   *\n   * @example\n   * root.nodes[0].nodes[0].root() === root\n   *\n   * @return {Root} root parent\n   */\n\n\n  Node.prototype.root = function root() {\n    var result = this;\n\n    while (result.parent) {\n      result = result.parent;\n    }\n\n    return result;\n  };\n\n  Node.prototype.cleanRaws = function cleanRaws(keepBetween) {\n    delete this.raws.before;\n    delete this.raws.after;\n    if (!keepBetween) delete this.raws.between;\n  };\n\n  Node.prototype.positionInside = function positionInside(index) {\n    var string = this.toString();\n    var column = this.source.start.column;\n    var line = this.source.start.line;\n\n    for (var i = 0; i < index; i++) {\n      if (string[i] === '\\n') {\n        column = 1;\n        line += 1;\n      } else {\n        column += 1;\n      }\n    }\n\n    return {\n      line: line,\n      column: column\n    };\n  };\n\n  Node.prototype.positionBy = function positionBy(opts) {\n    var pos = this.source.start;\n\n    if (opts.index) {\n      pos = this.positionInside(opts.index);\n    } else if (opts.word) {\n      var index = this.toString().indexOf(opts.word);\n      if (index !== -1) pos = this.positionInside(index);\n    }\n\n    return pos;\n  };\n  /**\n   * @memberof Node#\n   * @member {string} type - String representing the node’s type.\n   *                         Possible values are `root`, `atrule`, `rule`,\n   *                         `decl`, or `comment`.\n   *\n   * @example\n   * postcss.decl({ prop: 'color', value: 'black' }).type //=> 'decl'\n   */\n\n  /**\n   * @memberof Node#\n   * @member {Container} parent - the node’s parent node.\n   *\n   * @example\n   * root.nodes[0].parent == root;\n   */\n\n  /**\n   * @memberof Node#\n   * @member {source} source - the input source of the node\n   *\n   * The property is used in source map generation.\n   *\n   * If you create a node manually (e.g., with `postcss.decl()`),\n   * that node will not have a `source` property and will be absent\n   * from the source map. For this reason, the plugin developer should\n   * consider cloning nodes to create new ones (in which case the new node’s\n   * source will reference the original, cloned node) or setting\n   * the `source` property manually.\n   *\n   * ```js\n   * // Bad\n   * const prefixed = postcss.decl({\n   *   prop: '-moz-' + decl.prop,\n   *   value: decl.value\n   * });\n   *\n   * // Good\n   * const prefixed = decl.clone({ prop: '-moz-' + decl.prop });\n   * ```\n   *\n   * ```js\n   * if ( atrule.name == 'add-link' ) {\n   *   const rule = postcss.rule({ selector: 'a', source: atrule.source });\n   *   atrule.parent.insertBefore(atrule, rule);\n   * }\n   * ```\n   *\n   * @example\n   * decl.source.input.from //=> '/home/ai/a.sass'\n   * decl.source.start      //=> { line: 10, column: 2 }\n   * decl.source.end        //=> { line: 10, column: 12 }\n   */\n\n  /**\n   * @memberof Node#\n   * @member {object} raws - Information to generate byte-to-byte equal\n   *                         node string as it was in the origin input.\n   *\n   * Every parser saves its own properties,\n   * but the default CSS parser uses:\n   *\n   * * `before`: the space symbols before the node. It also stores `*`\n   *   and `_` symbols before the declaration (IE hack).\n   * * `after`: the space symbols after the last child of the node\n   *   to the end of the node.\n   * * `between`: the symbols between the property and value\n   *   for declarations, selector and `{` for rules, or last parameter\n   *   and `{` for at-rules.\n   * * `semicolon`: contains true if the last child has\n   *   an (optional) semicolon.\n   * * `afterName`: the space between the at-rule name and its parameters.\n   * * `left`: the space symbols between `/*` and the comment’s text.\n   * * `right`: the space symbols between the comment’s text\n   *   and <code>*&#47;</code>.\n   * * `important`: the content of the important statement,\n   *   if it is not just `!important`.\n   *\n   * PostCSS cleans selectors, declaration values and at-rule parameters\n   * from comments and extra spaces, but it stores origin content in raws\n   * properties. As such, if you don’t change a declaration’s value,\n   * PostCSS will use the raw value with comments.\n   *\n   * @example\n   * const root = postcss.parse('a {\\n  color:black\\n}')\n   * root.first.first.raws //=> { before: '\\n  ', between: ':' }\n   */\n\n\n  return Node;\n}();\n\nexports.default = Node;\n/**\n * @typedef {object} position\n * @property {number} line   - source line in file\n * @property {number} column - source column in file\n */\n\n/**\n * @typedef {object} source\n * @property {Input} input    - {@link Input} with input file\n * @property {position} start - The starting position of the node’s source\n * @property {position} end   - The ending position of the node’s source\n */\n\nmodule.exports = exports['default'];","map":{"version":3,"sources":["node.es6"],"names":["cloneNode","cloned","obj","value","type","i","Node","defaults","JSON","error","message","opts","pos","CssSyntaxError","warn","result","text","data","node","remove","toString","stringifier","stringify","clone","overrides","cloneBefore","cloneAfter","replaceWith","nodes","moveTo","newParent","moveBefore","otherNode","moveAfter","next","index","prev","before","add","after","toJSON","fixed","name","raw","prop","defaultType","str","Stringifier","root","cleanRaws","keepBetween","positionInside","string","column","line","positionBy"],"mappings":"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","sourcesContent":["import CssSyntaxError from './css-syntax-error';\nimport Stringifier    from './stringifier';\nimport stringify      from './stringify';\nimport warnOnce       from './warn-once';\n\nlet cloneNode = function (obj, parent) {\n    let cloned = new obj.constructor();\n\n    for ( let i in obj ) {\n        if ( !obj.hasOwnProperty(i) ) continue;\n        let value = obj[i];\n        let type  = typeof value;\n\n        if ( i === 'parent' && type === 'object' ) {\n            if (parent) cloned[i] = parent;\n        } else if ( i === 'source' ) {\n            cloned[i] = value;\n        } else if ( value instanceof Array ) {\n            cloned[i] = value.map( j => cloneNode(j, cloned) );\n        } else {\n            if ( type === 'object' && value !== null ) value = cloneNode(value);\n            cloned[i] = value;\n        }\n    }\n\n    return cloned;\n};\n\n/**\n * All node classes inherit the following common methods.\n *\n * @abstract\n */\nclass Node {\n\n    /**\n     * @param {object} [defaults] - value for node properties\n     */\n    constructor(defaults = { }) {\n        this.raws = { };\n        if ( typeof defaults !== 'object' && typeof defaults !== 'undefined' ) {\n            throw new Error(\n                'PostCSS nodes constructor accepts object, not ' +\n                JSON.stringify(defaults));\n        }\n        for ( let name in defaults ) {\n            this[name] = defaults[name];\n        }\n    }\n\n    /**\n     * Returns a CssSyntaxError instance containing the original position\n     * of the node in the source, showing line and column numbers and also\n     * a small excerpt to facilitate debugging.\n     *\n     * If present, an input source map will be used to get the original position\n     * of the source, even from a previous compilation step\n     * (e.g., from Sass compilation).\n     *\n     * This method produces very useful error messages.\n     *\n     * @param {string} message     - error description\n     * @param {object} [opts]      - options\n     * @param {string} opts.plugin - plugin name that created this error.\n     *                               PostCSS will set it automatically.\n     * @param {string} opts.word   - a word inside a node’s string that should\n     *                               be highlighted as the source of the error\n     * @param {number} opts.index  - an index inside a node’s string that should\n     *                               be highlighted as the source of the error\n     *\n     * @return {CssSyntaxError} error object to throw it\n     *\n     * @example\n     * if ( !variables[name] ) {\n     *   throw decl.error('Unknown variable ' + name, { word: name });\n     *   // CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black\n     *   //   color: $black\n     *   // a\n     *   //          ^\n     *   //   background: white\n     * }\n     */\n    error(message, opts = { }) {\n        if ( this.source ) {\n            let pos = this.positionBy(opts);\n            return this.source.input.error(message, pos.line, pos.column, opts);\n        } else {\n            return new CssSyntaxError(message);\n        }\n    }\n\n    /**\n     * This method is provided as a convenience wrapper for {@link Result#warn}.\n     *\n     * @param {Result} result      - the {@link Result} instance\n     *                               that will receive the warning\n     * @param {string} text        - warning message\n     * @param {object} [opts]      - options\n     * @param {string} opts.plugin - plugin name that created this warning.\n     *                               PostCSS will set it automatically.\n     * @param {string} opts.word   - a word inside a node’s string that should\n     *                               be highlighted as the source of the warning\n     * @param {number} opts.index  - an index inside a node’s string that should\n     *                               be highlighted as the source of the warning\n     *\n     * @return {Warning} created warning object\n     *\n     * @example\n     * const plugin = postcss.plugin('postcss-deprecated', () => {\n     *   return (root, result) => {\n     *     root.walkDecls('bad', decl => {\n     *       decl.warn(result, 'Deprecated property bad');\n     *     });\n     *   };\n     * });\n     */\n    warn(result, text, opts) {\n        let data = { node: this };\n        for ( let i in opts ) data[i] = opts[i];\n        return result.warn(text, data);\n    }\n\n    /**\n     * Removes the node from its parent and cleans the parent properties\n     * from the node and its children.\n     *\n     * @example\n     * if ( decl.prop.match(/^-webkit-/) ) {\n     *   decl.remove();\n     * }\n     *\n     * @return {Node} node to make calls chain\n     */\n    remove() {\n        if ( this.parent ) {\n            this.parent.removeChild(this);\n        }\n        this.parent = undefined;\n        return this;\n    }\n\n    /**\n     * Returns a CSS string representing the node.\n     *\n     * @param {stringifier|syntax} [stringifier] - a syntax to use\n     *                                             in string generation\n     *\n     * @return {string} CSS string of this node\n     *\n     * @example\n     * postcss.rule({ selector: 'a' }).toString() //=> \"a {}\"\n     */\n    toString(stringifier = stringify) {\n        if ( stringifier.stringify ) stringifier = stringifier.stringify;\n        let result  = '';\n        stringifier(this, i => {\n            result += i;\n        });\n        return result;\n    }\n\n    /**\n     * Returns a clone of the node.\n     *\n     * The resulting cloned node and its (cloned) children will have\n     * a clean parent and code style properties.\n     *\n     * @param {object} [overrides] - new properties to override in the clone.\n     *\n     * @example\n     * const cloned = decl.clone({ prop: '-moz-' + decl.prop });\n     * cloned.raws.before  //=> undefined\n     * cloned.parent       //=> undefined\n     * cloned.toString()   //=> -moz-transform: scale(0)\n     *\n     * @return {Node} clone of the node\n     */\n    clone(overrides = { }) {\n        let cloned = cloneNode(this);\n        for ( let name in overrides ) {\n            cloned[name] = overrides[name];\n        }\n        return cloned;\n    }\n\n    /**\n     * Shortcut to clone the node and insert the resulting cloned node\n     * before the current node.\n     *\n     * @param {object} [overrides] - new properties to override in the clone.\n     *\n     * @example\n     * decl.cloneBefore({ prop: '-moz-' + decl.prop });\n     *\n     * @return {Node} - new node\n     */\n    cloneBefore(overrides = { }) {\n        let cloned = this.clone(overrides);\n        this.parent.insertBefore(this, cloned);\n        return cloned;\n    }\n\n    /**\n     * Shortcut to clone the node and insert the resulting cloned node\n     * after the current node.\n     *\n     * @param {object} [overrides] - new properties to override in the clone.\n     *\n     * @return {Node} - new node\n     */\n    cloneAfter(overrides = { }) {\n        let cloned = this.clone(overrides);\n        this.parent.insertAfter(this, cloned);\n        return cloned;\n    }\n\n    /**\n     * Inserts node(s) before the current node and removes the current node.\n     *\n     * @param {...Node} nodes - node(s) to replace current one\n     *\n     * @example\n     * if ( atrule.name == 'mixin' ) {\n     *   atrule.replaceWith(mixinRules[atrule.params]);\n     * }\n     *\n     * @return {Node} current node to methods chain\n     */\n    replaceWith(...nodes) {\n        if (this.parent) {\n            for (let node of nodes) {\n                this.parent.insertBefore(this, node);\n            }\n\n            this.remove();\n        }\n\n        return this;\n    }\n\n    moveTo(newParent) {\n        warnOnce('Node#moveTo was deprecated. Use Container#append.');\n        this.cleanRaws(this.root() === newParent.root());\n        this.remove();\n        newParent.append(this);\n        return this;\n    }\n\n    moveBefore(otherNode) {\n        warnOnce('Node#moveBefore was deprecated. Use Node#before.');\n        this.cleanRaws(this.root() === otherNode.root());\n        this.remove();\n        otherNode.parent.insertBefore(otherNode, this);\n        return this;\n    }\n\n    moveAfter(otherNode) {\n        warnOnce('Node#moveAfter was deprecated. Use Node#after.');\n        this.cleanRaws(this.root() === otherNode.root());\n        this.remove();\n        otherNode.parent.insertAfter(otherNode, this);\n        return this;\n    }\n\n    /**\n     * Returns the next child of the node’s parent.\n     * Returns `undefined` if the current node is the last child.\n     *\n     * @return {Node|undefined} next node\n     *\n     * @example\n     * if ( comment.text === 'delete next' ) {\n     *   const next = comment.next();\n     *   if ( next ) {\n     *     next.remove();\n     *   }\n     * }\n     */\n    next() {\n        if ( !this.parent ) return undefined;\n        let index = this.parent.index(this);\n        return this.parent.nodes[index + 1];\n    }\n\n    /**\n     * Returns the previous child of the node’s parent.\n     * Returns `undefined` if the current node is the first child.\n     *\n     * @return {Node|undefined} previous node\n     *\n     * @example\n     * const annotation = decl.prev();\n     * if ( annotation.type == 'comment' ) {\n     *  readAnnotation(annotation.text);\n     * }\n     */\n    prev() {\n        if ( !this.parent ) return undefined;\n        let index = this.parent.index(this);\n        return this.parent.nodes[index - 1];\n    }\n\n    /**\n     * Insert new node before current node to current node’s parent.\n     *\n     * Just alias for `node.parent.insertBefore(node, add)`.\n     *\n     * @param {Node|object|string|Node[]} add - new node\n     *\n     * @return {Node} this node for methods chain.\n     *\n     * @example\n     * decl.before('content: \"\"');\n     */\n    before(add) {\n        this.parent.insertBefore(this, add);\n        return this;\n    }\n\n    /**\n     * Insert new node after current node to current node’s parent.\n     *\n     * Just alias for `node.parent.insertAfter(node, add)`.\n     *\n     * @param {Node|object|string|Node[]} add - new node\n     *\n     * @return {Node} this node for methods chain.\n     *\n     * @example\n     * decl.after('color: black');\n     */\n    after(add) {\n        this.parent.insertAfter(this, add);\n        return this;\n    }\n\n    toJSON() {\n        let fixed = { };\n\n        for ( let name in this ) {\n            if ( !this.hasOwnProperty(name) ) continue;\n            if ( name === 'parent' ) continue;\n            let value = this[name];\n\n            if ( value instanceof Array ) {\n                fixed[name] = value.map( i => {\n                    if ( typeof i === 'object' && i.toJSON ) {\n                        return i.toJSON();\n                    } else {\n                        return i;\n                    }\n                });\n            } else if ( typeof value === 'object' && value.toJSON ) {\n                fixed[name] = value.toJSON();\n            } else {\n                fixed[name] = value;\n            }\n        }\n\n        return fixed;\n    }\n\n    /**\n     * Returns a {@link Node#raws} value. If the node is missing\n     * the code style property (because the node was manually built or cloned),\n     * PostCSS will try to autodetect the code style property by looking\n     * at other nodes in the tree.\n     *\n     * @param {string} prop          - name of code style property\n     * @param {string} [defaultType] - name of default value, it can be missed\n     *                                 if the value is the same as prop\n     *\n     * @example\n     * const root = postcss.parse('a { background: white }');\n     * root.nodes[0].append({ prop: 'color', value: 'black' });\n     * root.nodes[0].nodes[1].raws.before   //=> undefined\n     * root.nodes[0].nodes[1].raw('before') //=> ' '\n     *\n     * @return {string} code style value\n     */\n    raw(prop, defaultType) {\n        let str = new Stringifier();\n        return str.raw(this, prop, defaultType);\n    }\n\n    /**\n     * Finds the Root instance of the node’s tree.\n     *\n     * @example\n     * root.nodes[0].nodes[0].root() === root\n     *\n     * @return {Root} root parent\n     */\n    root() {\n        let result = this;\n        while ( result.parent ) result = result.parent;\n        return result;\n    }\n\n    cleanRaws(keepBetween) {\n        delete this.raws.before;\n        delete this.raws.after;\n        if ( !keepBetween ) delete this.raws.between;\n    }\n\n    positionInside(index) {\n        let string = this.toString();\n        let column = this.source.start.column;\n        let line   = this.source.start.line;\n\n        for ( let i = 0; i < index; i++ ) {\n            if ( string[i] === '\\n' ) {\n                column = 1;\n                line  += 1;\n            } else {\n                column += 1;\n            }\n        }\n\n        return { line, column };\n    }\n\n    positionBy(opts) {\n        let pos = this.source.start;\n        if ( opts.index ) {\n            pos = this.positionInside(opts.index);\n        } else if ( opts.word ) {\n            let index = this.toString().indexOf(opts.word);\n            if ( index !== -1 ) pos = this.positionInside(index);\n        }\n        return pos;\n    }\n\n    /**\n     * @memberof Node#\n     * @member {string} type - String representing the node’s type.\n     *                         Possible values are `root`, `atrule`, `rule`,\n     *                         `decl`, or `comment`.\n     *\n     * @example\n     * postcss.decl({ prop: 'color', value: 'black' }).type //=> 'decl'\n     */\n\n    /**\n     * @memberof Node#\n     * @member {Container} parent - the node’s parent node.\n     *\n     * @example\n     * root.nodes[0].parent == root;\n     */\n\n    /**\n     * @memberof Node#\n     * @member {source} source - the input source of the node\n     *\n     * The property is used in source map generation.\n     *\n     * If you create a node manually (e.g., with `postcss.decl()`),\n     * that node will not have a `source` property and will be absent\n     * from the source map. For this reason, the plugin developer should\n     * consider cloning nodes to create new ones (in which case the new node’s\n     * source will reference the original, cloned node) or setting\n     * the `source` property manually.\n     *\n     * ```js\n     * // Bad\n     * const prefixed = postcss.decl({\n     *   prop: '-moz-' + decl.prop,\n     *   value: decl.value\n     * });\n     *\n     * // Good\n     * const prefixed = decl.clone({ prop: '-moz-' + decl.prop });\n     * ```\n     *\n     * ```js\n     * if ( atrule.name == 'add-link' ) {\n     *   const rule = postcss.rule({ selector: 'a', source: atrule.source });\n     *   atrule.parent.insertBefore(atrule, rule);\n     * }\n     * ```\n     *\n     * @example\n     * decl.source.input.from //=> '/home/ai/a.sass'\n     * decl.source.start      //=> { line: 10, column: 2 }\n     * decl.source.end        //=> { line: 10, column: 12 }\n     */\n\n    /**\n     * @memberof Node#\n     * @member {object} raws - Information to generate byte-to-byte equal\n     *                         node string as it was in the origin input.\n     *\n     * Every parser saves its own properties,\n     * but the default CSS parser uses:\n     *\n     * * `before`: the space symbols before the node. It also stores `*`\n     *   and `_` symbols before the declaration (IE hack).\n     * * `after`: the space symbols after the last child of the node\n     *   to the end of the node.\n     * * `between`: the symbols between the property and value\n     *   for declarations, selector and `{` for rules, or last parameter\n     *   and `{` for at-rules.\n     * * `semicolon`: contains true if the last child has\n     *   an (optional) semicolon.\n     * * `afterName`: the space between the at-rule name and its parameters.\n     * * `left`: the space symbols between `/*` and the comment’s text.\n     * * `right`: the space symbols between the comment’s text\n     *   and <code>*&#47;</code>.\n     * * `important`: the content of the important statement,\n     *   if it is not just `!important`.\n     *\n     * PostCSS cleans selectors, declaration values and at-rule parameters\n     * from comments and extra spaces, but it stores origin content in raws\n     * properties. As such, if you don’t change a declaration’s value,\n     * PostCSS will use the raw value with comments.\n     *\n     * @example\n     * const root = postcss.parse('a {\\n  color:black\\n}')\n     * root.first.first.raws //=> { before: '\\n  ', between: ':' }\n     */\n\n}\n\nexport default Node;\n\n/**\n * @typedef {object} position\n * @property {number} line   - source line in file\n * @property {number} column - source column in file\n */\n\n/**\n * @typedef {object} source\n * @property {Input} input    - {@link Input} with input file\n * @property {position} start - The starting position of the node’s source\n * @property {position} end   - The ending position of the node’s source\n */\n"]},"metadata":{},"sourceType":"script"}