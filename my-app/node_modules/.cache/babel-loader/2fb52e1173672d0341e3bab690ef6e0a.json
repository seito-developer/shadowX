{"ast":null,"code":"const selectorParser = require('postcss-selector-parser');\n\nconst postcss = require('postcss');\n\nconst {\n  toRgba\n} = require('../lib/util/withAlphaVariable');\n\nconst {\n  nameClass,\n  escapeCommas\n} = require('./lib/utils');\n\nfunction updateAllClasses(selectors, updateClass) {\n  let parser = selectorParser(selectors => {\n    selectors.walkClasses(sel => {\n      let updatedClass = updateClass(sel.value, {\n        withPseudo(className, pseudo) {\n          sel.parent.insertAfter(sel, selectorParser.pseudo({\n            value: `:${pseudo}`\n          }));\n          return className;\n        }\n\n      });\n      sel.value = updatedClass;\n\n      if (sel.raws && sel.raws.value) {\n        sel.raws.value = escapeCommas(sel.raws.value);\n      }\n    });\n  });\n  let result = parser.processSync(selectors);\n  return result;\n}\n\nfunction updateLastClasses(selectors, updateClass) {\n  let parser = selectorParser(selectors => {\n    selectors.each(sel => {\n      let lastClass = sel.filter(({\n        type\n      }) => type === 'class').pop();\n\n      if (lastClass === undefined) {\n        return;\n      }\n\n      let updatedClass = updateClass(lastClass.value, {\n        withPseudo(className, pseudo) {\n          lastClass.parent.insertAfter(lastClass, selectorParser.pseudo({\n            value: `:${pseudo}`\n          }));\n          return className;\n        }\n\n      });\n      lastClass.value = updatedClass;\n\n      if (lastClass.raws && lastClass.raws.value) {\n        lastClass.raws.value = escapeCommas(lastClass.raws.value);\n      }\n    });\n  });\n  let result = parser.processSync(selectors);\n  return result;\n}\n\nfunction transformAllSelectors(transformSelector, wrap = null) {\n  return ({\n    container\n  }) => {\n    container.walkRules(rule => {\n      let transformed = rule.selector.split(',').map(transformSelector).join(',');\n      rule.selector = transformed;\n      return rule;\n    });\n\n    if (wrap) {\n      let wrapper = wrap();\n      wrapper.append(container.nodes);\n      container.append(wrapper);\n    }\n  };\n}\n\nfunction transformAllClasses(transformClass) {\n  return ({\n    container\n  }) => {\n    container.walkRules(rule => {\n      let selector = rule.selector;\n      let variantSelector = updateAllClasses(selector, transformClass);\n      rule.selector = variantSelector;\n      return rule;\n    });\n  };\n}\n\nfunction transformLastClasses(transformClass, wrap = null) {\n  return ({\n    container\n  }) => {\n    container.walkRules(rule => {\n      let selector = rule.selector;\n      let variantSelector = updateLastClasses(selector, transformClass);\n      rule.selector = variantSelector;\n      return rule;\n    });\n\n    if (wrap) {\n      let wrapper = wrap();\n      wrapper.append(container.nodes);\n      container.append(wrapper);\n    }\n  };\n}\n\nfunction asValue(modifier, lookup = {}, {\n  validate = () => true,\n  transform = v => v\n} = {}) {\n  let value = lookup[modifier];\n\n  if (value !== undefined) {\n    return value;\n  }\n\n  if (modifier[0] !== '[' || modifier[modifier.length - 1] !== ']') {\n    return undefined;\n  }\n\n  value = modifier.slice(1, -1);\n\n  if (!validate(value)) {\n    return undefined;\n  } // add spaces around operators inside calc() that do not follow an operator or (\n\n\n  return transform(value).replace(/(?<=^calc\\(.+?)(?<![-+*/(])([-+*/])/g, ' $1 ');\n}\n\nfunction asUnit(modifier, units, lookup = {}) {\n  return asValue(modifier, lookup, {\n    validate: value => {\n      let unitsPattern = `(?:${units.join('|')})`;\n      return new RegExp(`${unitsPattern}$`).test(value) || new RegExp(`^calc\\\\(.+?${unitsPattern}`).test(value);\n    },\n    transform: value => {\n      return value;\n    }\n  });\n}\n\nmodule.exports = {\n  nameClass,\n  updateAllClasses,\n  updateLastClasses,\n  transformAllSelectors,\n  transformAllClasses,\n  transformLastClasses,\n\n  createSimpleStaticUtilityPlugin(styles) {\n    return function ({\n      matchUtilities\n    }) {\n      matchUtilities(Object.entries(styles).reduce((newStyles, [selector, rules]) => {\n        let result = {\n          [selector]: rules\n        };\n        newStyles[selector.slice(1)] = [result];\n        return newStyles;\n      }, {}));\n    };\n  },\n\n  asValue,\n\n  asList(modifier, lookup = {}) {\n    return asValue(modifier, lookup, {\n      transform: value => {\n        return postcss.list.comma(value).map(v => v.replace(/,/g, ', ')).join(' ');\n      }\n    });\n  },\n\n  asColor(modifier, lookup = {}) {\n    return asValue(modifier, lookup, {\n      validate: value => {\n        try {\n          toRgba(value);\n          return true;\n        } catch (e) {\n          return false;\n        }\n      }\n    });\n  },\n\n  asAngle(modifier, lookup = {}) {\n    return asUnit(modifier, ['deg', 'grad', 'rad', 'turn'], lookup);\n  },\n\n  asLength(modifier, lookup = {}) {\n    return asUnit(modifier, ['cm', 'mm', 'Q', 'in', 'pc', 'pt', 'px', 'em', 'ex', 'ch', 'rem', 'lh', 'vw', 'vh', 'vmin', 'vmax', '%'], lookup);\n  }\n\n};","map":{"version":3,"sources":["/Users/seito/Documents/develop/count-jp/my-app/node_modules/tailwindcss/jit/pluginUtils.js"],"names":["selectorParser","require","postcss","toRgba","nameClass","escapeCommas","updateAllClasses","selectors","updateClass","parser","walkClasses","sel","updatedClass","value","withPseudo","className","pseudo","parent","insertAfter","raws","result","processSync","updateLastClasses","each","lastClass","filter","type","pop","undefined","transformAllSelectors","transformSelector","wrap","container","walkRules","rule","transformed","selector","split","map","join","wrapper","append","nodes","transformAllClasses","transformClass","variantSelector","transformLastClasses","asValue","modifier","lookup","validate","transform","v","length","slice","replace","asUnit","units","unitsPattern","RegExp","test","module","exports","createSimpleStaticUtilityPlugin","styles","matchUtilities","Object","entries","reduce","newStyles","rules","asList","list","comma","asColor","e","asAngle","asLength"],"mappings":"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","sourcesContent":["const selectorParser = require('postcss-selector-parser')\nconst postcss = require('postcss')\nconst { toRgba } = require('../lib/util/withAlphaVariable')\nconst { nameClass, escapeCommas } = require('./lib/utils')\n\nfunction updateAllClasses(selectors, updateClass) {\n  let parser = selectorParser((selectors) => {\n    selectors.walkClasses((sel) => {\n      let updatedClass = updateClass(sel.value, {\n        withPseudo(className, pseudo) {\n          sel.parent.insertAfter(sel, selectorParser.pseudo({ value: `:${pseudo}` }))\n          return className\n        },\n      })\n      sel.value = updatedClass\n      if (sel.raws && sel.raws.value) {\n        sel.raws.value = escapeCommas(sel.raws.value)\n      }\n    })\n  })\n\n  let result = parser.processSync(selectors)\n\n  return result\n}\n\nfunction updateLastClasses(selectors, updateClass) {\n  let parser = selectorParser((selectors) => {\n    selectors.each((sel) => {\n      let lastClass = sel.filter(({ type }) => type === 'class').pop()\n\n      if (lastClass === undefined) {\n        return\n      }\n\n      let updatedClass = updateClass(lastClass.value, {\n        withPseudo(className, pseudo) {\n          lastClass.parent.insertAfter(lastClass, selectorParser.pseudo({ value: `:${pseudo}` }))\n          return className\n        },\n      })\n      lastClass.value = updatedClass\n      if (lastClass.raws && lastClass.raws.value) {\n        lastClass.raws.value = escapeCommas(lastClass.raws.value)\n      }\n    })\n  })\n  let result = parser.processSync(selectors)\n\n  return result\n}\n\nfunction transformAllSelectors(transformSelector, wrap = null) {\n  return ({ container }) => {\n    container.walkRules((rule) => {\n      let transformed = rule.selector.split(',').map(transformSelector).join(',')\n      rule.selector = transformed\n      return rule\n    })\n\n    if (wrap) {\n      let wrapper = wrap()\n      wrapper.append(container.nodes)\n      container.append(wrapper)\n    }\n  }\n}\n\nfunction transformAllClasses(transformClass) {\n  return ({ container }) => {\n    container.walkRules((rule) => {\n      let selector = rule.selector\n      let variantSelector = updateAllClasses(selector, transformClass)\n      rule.selector = variantSelector\n      return rule\n    })\n  }\n}\n\nfunction transformLastClasses(transformClass, wrap = null) {\n  return ({ container }) => {\n    container.walkRules((rule) => {\n      let selector = rule.selector\n      let variantSelector = updateLastClasses(selector, transformClass)\n      rule.selector = variantSelector\n      return rule\n    })\n\n    if (wrap) {\n      let wrapper = wrap()\n      wrapper.append(container.nodes)\n      container.append(wrapper)\n    }\n  }\n}\n\nfunction asValue(modifier, lookup = {}, { validate = () => true, transform = (v) => v } = {}) {\n  let value = lookup[modifier]\n\n  if (value !== undefined) {\n    return value\n  }\n\n  if (modifier[0] !== '[' || modifier[modifier.length - 1] !== ']') {\n    return undefined\n  }\n\n  value = modifier.slice(1, -1)\n\n  if (!validate(value)) {\n    return undefined\n  }\n\n  // add spaces around operators inside calc() that do not follow an operator or (\n  return transform(value).replace(/(?<=^calc\\(.+?)(?<![-+*/(])([-+*/])/g, ' $1 ')\n}\n\nfunction asUnit(modifier, units, lookup = {}) {\n  return asValue(modifier, lookup, {\n    validate: (value) => {\n      let unitsPattern = `(?:${units.join('|')})`\n      return (\n        new RegExp(`${unitsPattern}$`).test(value) ||\n        new RegExp(`^calc\\\\(.+?${unitsPattern}`).test(value)\n      )\n    },\n    transform: (value) => {\n      return value\n    },\n  })\n}\n\nmodule.exports = {\n  nameClass,\n  updateAllClasses,\n  updateLastClasses,\n  transformAllSelectors,\n  transformAllClasses,\n  transformLastClasses,\n  createSimpleStaticUtilityPlugin(styles) {\n    return function ({ matchUtilities }) {\n      matchUtilities(\n        Object.entries(styles).reduce((newStyles, [selector, rules]) => {\n          let result = { [selector]: rules }\n          newStyles[selector.slice(1)] = [result]\n          return newStyles\n        }, {})\n      )\n    }\n  },\n  asValue,\n  asList(modifier, lookup = {}) {\n    return asValue(modifier, lookup, {\n      transform: (value) => {\n        return postcss.list\n          .comma(value)\n          .map((v) => v.replace(/,/g, ', '))\n          .join(' ')\n      },\n    })\n  },\n  asColor(modifier, lookup = {}) {\n    return asValue(modifier, lookup, {\n      validate: (value) => {\n        try {\n          toRgba(value)\n          return true\n        } catch (e) {\n          return false\n        }\n      },\n    })\n  },\n  asAngle(modifier, lookup = {}) {\n    return asUnit(modifier, ['deg', 'grad', 'rad', 'turn'], lookup)\n  },\n  asLength(modifier, lookup = {}) {\n    return asUnit(\n      modifier,\n      [\n        'cm',\n        'mm',\n        'Q',\n        'in',\n        'pc',\n        'pt',\n        'px',\n        'em',\n        'ex',\n        'ch',\n        'rem',\n        'lh',\n        'vw',\n        'vh',\n        'vmin',\n        'vmax',\n        '%',\n      ],\n      lookup\n    )\n  },\n}\n"]},"metadata":{},"sourceType":"script"}