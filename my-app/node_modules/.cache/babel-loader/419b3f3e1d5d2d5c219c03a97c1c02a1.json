{"ast":null,"code":"var acorn = require('acorn-node');\n\nvar walk = require('acorn-node/walk');\n\nvar defined = require('defined');\n\nvar requireRe = /\\brequire\\b/;\n\nfunction parse(src, opts) {\n  if (!opts) opts = {};\n  var acornOpts = {\n    ranges: defined(opts.ranges, opts.range),\n    locations: defined(opts.locations, opts.loc),\n    allowReserved: defined(opts.allowReserved, true),\n    allowImportExportEverywhere: defined(opts.allowImportExportEverywhere, false)\n  }; // Use acorn-node's defaults for the rest.\n\n  if (opts.ecmaVersion != null) acornOpts.ecmaVersion = opts.ecmaVersion;\n  if (opts.sourceType != null) acornOpts.sourceType = opts.sourceType;\n  if (opts.allowHashBang != null) acornOpts.allowHashBang = opts.allowHashBang;\n  if (opts.allowReturnOutsideFunction != null) acornOpts.allowReturnOutsideFunction = opts.allowReturnOutsideFunction;\n  return acorn.parse(src, acornOpts);\n}\n\nvar exports = module.exports = function (src, opts) {\n  return exports.find(src, opts).strings;\n};\n\nexports.find = function (src, opts) {\n  if (!opts) opts = {};\n  var word = opts.word === undefined ? 'require' : opts.word;\n  if (typeof src !== 'string') src = String(src);\n\n  var isRequire = opts.isRequire || function (node) {\n    return node.callee.type === 'Identifier' && node.callee.name === word;\n  };\n\n  var modules = {\n    strings: [],\n    expressions: []\n  };\n  if (opts.nodes) modules.nodes = [];\n  var wordRe = word === 'require' ? requireRe : RegExp('\\\\b' + word + '\\\\b');\n  if (!wordRe.test(src)) return modules;\n  var ast = parse(src, opts.parse);\n\n  function visit(node, st, c) {\n    var hasRequire = wordRe.test(src.slice(node.start, node.end));\n    if (!hasRequire) return;\n    walk.base[node.type](node, st, c);\n    if (node.type !== 'CallExpression') return;\n\n    if (isRequire(node)) {\n      if (node.arguments.length) {\n        var arg = node.arguments[0];\n\n        if (arg.type === 'Literal') {\n          modules.strings.push(arg.value);\n        } else if (arg.type === 'TemplateLiteral' && arg.quasis.length === 1 && arg.expressions.length === 0) {\n          modules.strings.push(arg.quasis[0].value.raw);\n        } else {\n          modules.expressions.push(src.slice(arg.start, arg.end));\n        }\n      }\n\n      if (opts.nodes) modules.nodes.push(node);\n    }\n  }\n\n  walk.recursive(ast, null, {\n    Statement: visit,\n    Expression: visit\n  });\n  return modules;\n};","map":{"version":3,"sources":["/Users/seito/Documents/develop/count-jp/my-app/node_modules/detective/index.js"],"names":["acorn","require","walk","defined","requireRe","parse","src","opts","acornOpts","ranges","range","locations","loc","allowReserved","allowImportExportEverywhere","ecmaVersion","sourceType","allowHashBang","allowReturnOutsideFunction","exports","module","find","strings","word","undefined","String","isRequire","node","callee","type","name","modules","expressions","nodes","wordRe","RegExp","test","ast","visit","st","c","hasRequire","slice","start","end","base","arguments","length","arg","push","value","quasis","raw","recursive","Statement","Expression"],"mappings":"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","sourcesContent":["var acorn = require('acorn-node');\nvar walk = require('acorn-node/walk');\nvar defined = require('defined');\n\nvar requireRe = /\\brequire\\b/;\n\nfunction parse (src, opts) {\n    if (!opts) opts = {};\n    var acornOpts = {\n        ranges: defined(opts.ranges, opts.range),\n        locations: defined(opts.locations, opts.loc),\n        allowReserved: defined(opts.allowReserved, true),\n        allowImportExportEverywhere: defined(opts.allowImportExportEverywhere, false)\n    };\n\n    // Use acorn-node's defaults for the rest.\n    if (opts.ecmaVersion != null) acornOpts.ecmaVersion = opts.ecmaVersion;\n    if (opts.sourceType != null) acornOpts.sourceType = opts.sourceType;\n    if (opts.allowHashBang != null) acornOpts.allowHashBang = opts.allowHashBang;\n    if (opts.allowReturnOutsideFunction != null) acornOpts.allowReturnOutsideFunction = opts.allowReturnOutsideFunction;\n\n    return acorn.parse(src, acornOpts);\n}\n\nvar exports = module.exports = function (src, opts) {\n    return exports.find(src, opts).strings;\n};\n\nexports.find = function (src, opts) {\n    if (!opts) opts = {};\n    \n    var word = opts.word === undefined ? 'require' : opts.word;\n    if (typeof src !== 'string') src = String(src);\n    \n    var isRequire = opts.isRequire || function (node) {\n        return node.callee.type === 'Identifier'\n            && node.callee.name === word\n        ;\n    };\n    \n    var modules = { strings : [], expressions : [] };\n    if (opts.nodes) modules.nodes = [];\n    \n    var wordRe = word === 'require' ? requireRe : RegExp('\\\\b' + word + '\\\\b');\n    if (!wordRe.test(src)) return modules;\n    \n    var ast = parse(src, opts.parse);\n    \n    function visit(node, st, c) {\n        var hasRequire = wordRe.test(src.slice(node.start, node.end));\n        if (!hasRequire) return;\n        walk.base[node.type](node, st, c);\n        if (node.type !== 'CallExpression') return;\n        if (isRequire(node)) {\n            if (node.arguments.length) {\n                var arg = node.arguments[0];\n                if (arg.type === 'Literal') {\n                    modules.strings.push(arg.value);\n                }\n                else if (arg.type === 'TemplateLiteral'\n                        && arg.quasis.length === 1\n                        && arg.expressions.length === 0) {\n\n                    modules.strings.push(arg.quasis[0].value.raw);\n                }\n                else {\n                    modules.expressions.push(src.slice(arg.start, arg.end));\n                }\n            }\n            if (opts.nodes) modules.nodes.push(node);\n        }\n    }\n    \n    walk.recursive(ast, null, {\n        Statement: visit,\n        Expression: visit\n    });\n    \n    return modules;\n};\n"]},"metadata":{},"sourceType":"script"}