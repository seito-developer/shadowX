{"ast":null,"code":"import './lib/compatibility-check';\nimport 'weakmap-polyfill';\nimport Promise from 'native-promise-only';\nimport { storeCallback, getCallbacks, removeCallback, swapCallbacks } from './lib/callbacks';\nimport { getMethodName, isDomElement, isVimeoUrl, getVimeoUrl, isNode } from './lib/functions';\nimport { getOEmbedParameters, getOEmbedData, createEmbed, initializeEmbeds, resizeEmbeds } from './lib/embed';\nimport { parseMessageData, postMessage, processData } from './lib/postmessage';\nimport { initializeScreenfull } from './lib/screenfull.js';\nconst playerMap = new WeakMap();\nconst readyMap = new WeakMap();\nlet screenfull = {};\n\nclass Player {\n  /**\n   * Create a Player.\n   *\n   * @param {(HTMLIFrameElement|HTMLElement|string|jQuery)} element A reference to the Vimeo\n   *        player iframe, and id, or a jQuery object.\n   * @param {object} [options] oEmbed parameters to use when creating an embed in the element.\n   * @return {Player}\n   */\n  constructor(element, options = {}) {\n    /* global jQuery */\n    if (window.jQuery && element instanceof jQuery) {\n      if (element.length > 1 && window.console && console.warn) {\n        console.warn('A jQuery object with multiple elements was passed, using the first element.');\n      }\n\n      element = element[0];\n    } // Find an element by ID\n\n\n    if (typeof document !== 'undefined' && typeof element === 'string') {\n      element = document.getElementById(element);\n    } // Not an element!\n\n\n    if (!isDomElement(element)) {\n      throw new TypeError('You must pass either a valid element or a valid id.');\n    } // Already initialized an embed in this div, so grab the iframe\n\n\n    if (element.nodeName !== 'IFRAME') {\n      const iframe = element.querySelector('iframe');\n\n      if (iframe) {\n        element = iframe;\n      }\n    } // iframe url is not a Vimeo url\n\n\n    if (element.nodeName === 'IFRAME' && !isVimeoUrl(element.getAttribute('src') || '')) {\n      throw new Error('The player element passed isn’t a Vimeo embed.');\n    } // If there is already a player object in the map, return that\n\n\n    if (playerMap.has(element)) {\n      return playerMap.get(element);\n    }\n\n    this._window = element.ownerDocument.defaultView;\n    this.element = element;\n    this.origin = '*';\n    const readyPromise = new Promise((resolve, reject) => {\n      this._onMessage = event => {\n        if (!isVimeoUrl(event.origin) || this.element.contentWindow !== event.source) {\n          return;\n        }\n\n        if (this.origin === '*') {\n          this.origin = event.origin;\n        }\n\n        const data = parseMessageData(event.data);\n        const isError = data && data.event === 'error';\n        const isReadyError = isError && data.data && data.data.method === 'ready';\n\n        if (isReadyError) {\n          const error = new Error(data.data.message);\n          error.name = data.data.name;\n          reject(error);\n          return;\n        }\n\n        const isReadyEvent = data && data.event === 'ready';\n        const isPingResponse = data && data.method === 'ping';\n\n        if (isReadyEvent || isPingResponse) {\n          this.element.setAttribute('data-ready', 'true');\n          resolve();\n          return;\n        }\n\n        processData(this, data);\n      };\n\n      this._window.addEventListener('message', this._onMessage);\n\n      if (this.element.nodeName !== 'IFRAME') {\n        const params = getOEmbedParameters(element, options);\n        const url = getVimeoUrl(params);\n        getOEmbedData(url, params, element).then(data => {\n          const iframe = createEmbed(data, element); // Overwrite element with the new iframe,\n          // but store reference to the original element\n\n          this.element = iframe;\n          this._originalElement = element;\n          swapCallbacks(element, iframe);\n          playerMap.set(this.element, this);\n          return data;\n        }).catch(reject);\n      }\n    }); // Store a copy of this Player in the map\n\n    readyMap.set(this, readyPromise);\n    playerMap.set(this.element, this); // Send a ping to the iframe so the ready promise will be resolved if\n    // the player is already ready.\n\n    if (this.element.nodeName === 'IFRAME') {\n      postMessage(this, 'ping');\n    }\n\n    if (screenfull.isEnabled) {\n      const exitFullscreen = () => screenfull.exit();\n\n      screenfull.on('fullscreenchange', () => {\n        if (screenfull.isFullscreen) {\n          storeCallback(this, 'event:exitFullscreen', exitFullscreen);\n        } else {\n          removeCallback(this, 'event:exitFullscreen', exitFullscreen);\n        } // eslint-disable-next-line\n\n\n        this.ready().then(() => {\n          postMessage(this, 'fullscreenchange', screenfull.isFullscreen);\n        });\n      });\n    }\n\n    return this;\n  }\n  /**\n   * Get a promise for a method.\n   *\n   * @param {string} name The API method to call.\n   * @param {Object} [args={}] Arguments to send via postMessage.\n   * @return {Promise}\n   */\n\n\n  callMethod(name, args = {}) {\n    return new Promise((resolve, reject) => {\n      // We are storing the resolve/reject handlers to call later, so we\n      // can’t return here.\n      // eslint-disable-next-line promise/always-return\n      return this.ready().then(() => {\n        storeCallback(this, name, {\n          resolve,\n          reject\n        });\n        postMessage(this, name, args);\n      }).catch(reject);\n    });\n  }\n  /**\n   * Get a promise for the value of a player property.\n   *\n   * @param {string} name The property name\n   * @return {Promise}\n   */\n\n\n  get(name) {\n    return new Promise((resolve, reject) => {\n      name = getMethodName(name, 'get'); // We are storing the resolve/reject handlers to call later, so we\n      // can’t return here.\n      // eslint-disable-next-line promise/always-return\n\n      return this.ready().then(() => {\n        storeCallback(this, name, {\n          resolve,\n          reject\n        });\n        postMessage(this, name);\n      }).catch(reject);\n    });\n  }\n  /**\n   * Get a promise for setting the value of a player property.\n   *\n   * @param {string} name The API method to call.\n   * @param {mixed} value The value to set.\n   * @return {Promise}\n   */\n\n\n  set(name, value) {\n    return new Promise((resolve, reject) => {\n      name = getMethodName(name, 'set');\n\n      if (value === undefined || value === null) {\n        throw new TypeError('There must be a value to set.');\n      } // We are storing the resolve/reject handlers to call later, so we\n      // can’t return here.\n      // eslint-disable-next-line promise/always-return\n\n\n      return this.ready().then(() => {\n        storeCallback(this, name, {\n          resolve,\n          reject\n        });\n        postMessage(this, name, value);\n      }).catch(reject);\n    });\n  }\n  /**\n   * Add an event listener for the specified event. Will call the\n   * callback with a single parameter, `data`, that contains the data for\n   * that event.\n   *\n   * @param {string} eventName The name of the event.\n   * @param {function(*)} callback The function to call when the event fires.\n   * @return {void}\n   */\n\n\n  on(eventName, callback) {\n    if (!eventName) {\n      throw new TypeError('You must pass an event name.');\n    }\n\n    if (!callback) {\n      throw new TypeError('You must pass a callback function.');\n    }\n\n    if (typeof callback !== 'function') {\n      throw new TypeError('The callback must be a function.');\n    }\n\n    const callbacks = getCallbacks(this, `event:${eventName}`);\n\n    if (callbacks.length === 0) {\n      this.callMethod('addEventListener', eventName).catch(() => {// Ignore the error. There will be an error event fired that\n        // will trigger the error callback if they are listening.\n      });\n    }\n\n    storeCallback(this, `event:${eventName}`, callback);\n  }\n  /**\n   * Remove an event listener for the specified event. Will remove all\n   * listeners for that event if a `callback` isn’t passed, or only that\n   * specific callback if it is passed.\n   *\n   * @param {string} eventName The name of the event.\n   * @param {function} [callback] The specific callback to remove.\n   * @return {void}\n   */\n\n\n  off(eventName, callback) {\n    if (!eventName) {\n      throw new TypeError('You must pass an event name.');\n    }\n\n    if (callback && typeof callback !== 'function') {\n      throw new TypeError('The callback must be a function.');\n    }\n\n    const lastCallback = removeCallback(this, `event:${eventName}`, callback); // If there are no callbacks left, remove the listener\n\n    if (lastCallback) {\n      this.callMethod('removeEventListener', eventName).catch(e => {// Ignore the error. There will be an error event fired that\n        // will trigger the error callback if they are listening.\n      });\n    }\n  }\n  /**\n   * A promise to load a new video.\n   *\n   * @promise LoadVideoPromise\n   * @fulfill {number} The video with this id successfully loaded.\n   * @reject {TypeError} The id was not a number.\n   */\n\n  /**\n   * Load a new video into this embed. The promise will be resolved if\n   * the video is successfully loaded, or it will be rejected if it could\n   * not be loaded.\n   *\n   * @param {number|object} options The id of the video or an object with embed options.\n   * @return {LoadVideoPromise}\n   */\n\n\n  loadVideo(options) {\n    return this.callMethod('loadVideo', options);\n  }\n  /**\n   * A promise to perform an action when the Player is ready.\n   *\n   * @todo document errors\n   * @promise LoadVideoPromise\n   * @fulfill {void}\n   */\n\n  /**\n   * Trigger a function when the player iframe has initialized. You do not\n   * need to wait for `ready` to trigger to begin adding event listeners\n   * or calling other methods.\n   *\n   * @return {ReadyPromise}\n   */\n\n\n  ready() {\n    const readyPromise = readyMap.get(this) || new Promise((resolve, reject) => {\n      reject(new Error('Unknown player. Probably unloaded.'));\n    });\n    return Promise.resolve(readyPromise);\n  }\n  /**\n   * A promise to add a cue point to the player.\n   *\n   * @promise AddCuePointPromise\n   * @fulfill {string} The id of the cue point to use for removeCuePoint.\n   * @reject {RangeError} the time was less than 0 or greater than the\n   *         video’s duration.\n   * @reject {UnsupportedError} Cue points are not supported with the current\n   *         player or browser.\n   */\n\n  /**\n   * Add a cue point to the player.\n   *\n   * @param {number} time The time for the cue point.\n   * @param {object} [data] Arbitrary data to be returned with the cue point.\n   * @return {AddCuePointPromise}\n   */\n\n\n  addCuePoint(time, data = {}) {\n    return this.callMethod('addCuePoint', {\n      time,\n      data\n    });\n  }\n  /**\n   * A promise to remove a cue point from the player.\n   *\n   * @promise AddCuePointPromise\n   * @fulfill {string} The id of the cue point that was removed.\n   * @reject {InvalidCuePoint} The cue point with the specified id was not\n   *         found.\n   * @reject {UnsupportedError} Cue points are not supported with the current\n   *         player or browser.\n   */\n\n  /**\n   * Remove a cue point from the video.\n   *\n   * @param {string} id The id of the cue point to remove.\n   * @return {RemoveCuePointPromise}\n   */\n\n\n  removeCuePoint(id) {\n    return this.callMethod('removeCuePoint', id);\n  }\n  /**\n   * A representation of a text track on a video.\n   *\n   * @typedef {Object} VimeoTextTrack\n   * @property {string} language The ISO language code.\n   * @property {string} kind The kind of track it is (captions or subtitles).\n   * @property {string} label The human‐readable label for the track.\n   */\n\n  /**\n   * A promise to enable a text track.\n   *\n   * @promise EnableTextTrackPromise\n   * @fulfill {VimeoTextTrack} The text track that was enabled.\n   * @reject {InvalidTrackLanguageError} No track was available with the\n   *         specified language.\n   * @reject {InvalidTrackError} No track was available with the specified\n   *         language and kind.\n   */\n\n  /**\n   * Enable the text track with the specified language, and optionally the\n   * specified kind (captions or subtitles).\n   *\n   * When set via the API, the track language will not change the viewer’s\n   * stored preference.\n   *\n   * @param {string} language The two‐letter language code.\n   * @param {string} [kind] The kind of track to enable (captions or subtitles).\n   * @return {EnableTextTrackPromise}\n   */\n\n\n  enableTextTrack(language, kind) {\n    if (!language) {\n      throw new TypeError('You must pass a language.');\n    }\n\n    return this.callMethod('enableTextTrack', {\n      language,\n      kind\n    });\n  }\n  /**\n   * A promise to disable the active text track.\n   *\n   * @promise DisableTextTrackPromise\n   * @fulfill {void} The track was disabled.\n   */\n\n  /**\n   * Disable the currently-active text track.\n   *\n   * @return {DisableTextTrackPromise}\n   */\n\n\n  disableTextTrack() {\n    return this.callMethod('disableTextTrack');\n  }\n  /**\n   * A promise to pause the video.\n   *\n   * @promise PausePromise\n   * @fulfill {void} The video was paused.\n   */\n\n  /**\n   * Pause the video if it’s playing.\n   *\n   * @return {PausePromise}\n   */\n\n\n  pause() {\n    return this.callMethod('pause');\n  }\n  /**\n   * A promise to play the video.\n   *\n   * @promise PlayPromise\n   * @fulfill {void} The video was played.\n   */\n\n  /**\n   * Play the video if it’s paused. **Note:** on iOS and some other\n   * mobile devices, you cannot programmatically trigger play. Once the\n   * viewer has tapped on the play button in the player, however, you\n   * will be able to use this function.\n   *\n   * @return {PlayPromise}\n   */\n\n\n  play() {\n    return this.callMethod('play');\n  }\n  /**\n   * Request that the player enters fullscreen.\n   * @return {Promise}\n   */\n\n\n  requestFullscreen() {\n    if (screenfull.isEnabled) {\n      return screenfull.request(this.element);\n    }\n\n    return this.callMethod('requestFullscreen');\n  }\n  /**\n   * Request that the player exits fullscreen.\n   * @return {Promise}\n   */\n\n\n  exitFullscreen() {\n    if (screenfull.isEnabled) {\n      return screenfull.exit();\n    }\n\n    return this.callMethod('exitFullscreen');\n  }\n  /**\n   * Returns true if the player is currently fullscreen.\n   * @return {Promise}\n   */\n\n\n  getFullscreen() {\n    if (screenfull.isEnabled) {\n      return Promise.resolve(screenfull.isFullscreen);\n    }\n\n    return this.get('fullscreen');\n  }\n  /**\n   * Request that the player enters picture-in-picture.\n   * @return {Promise}\n   */\n\n\n  requestPictureInPicture() {\n    return this.callMethod('requestPictureInPicture');\n  }\n  /**\n   * Request that the player exits picture-in-picture.\n   * @return {Promise}\n   */\n\n\n  exitPictureInPicture() {\n    return this.callMethod('exitPictureInPicture');\n  }\n  /**\n   * Returns true if the player is currently picture-in-picture.\n   * @return {Promise}\n   */\n\n\n  getPictureInPicture() {\n    return this.get('pictureInPicture');\n  }\n  /**\n   * A promise to unload the video.\n   *\n   * @promise UnloadPromise\n   * @fulfill {void} The video was unloaded.\n   */\n\n  /**\n   * Return the player to its initial state.\n   *\n   * @return {UnloadPromise}\n   */\n\n\n  unload() {\n    return this.callMethod('unload');\n  }\n  /**\n   * Cleanup the player and remove it from the DOM\n   *\n   * It won't be usable and a new one should be constructed\n   *  in order to do any operations.\n   *\n   * @return {Promise}\n   */\n\n\n  destroy() {\n    return new Promise(resolve => {\n      readyMap.delete(this);\n      playerMap.delete(this.element);\n\n      if (this._originalElement) {\n        playerMap.delete(this._originalElement);\n\n        this._originalElement.removeAttribute('data-vimeo-initialized');\n      }\n\n      if (this.element && this.element.nodeName === 'IFRAME' && this.element.parentNode) {\n        // If we've added an additional wrapper div, remove that from the DOM.\n        // If not, just remove the iframe element.\n        if (this.element.parentNode.parentNode && this._originalElement && this._originalElement !== this.element.parentNode) {\n          this.element.parentNode.parentNode.removeChild(this.element.parentNode);\n        } else {\n          this.element.parentNode.removeChild(this.element);\n        }\n      } // If the clip is private there is a case where the element stays the\n      // div element. Destroy should reset the div and remove the iframe child.\n\n\n      if (this.element && this.element.nodeName === 'DIV' && this.element.parentNode) {\n        this.element.removeAttribute('data-vimeo-initialized');\n        const iframe = this.element.querySelector('iframe');\n\n        if (iframe && iframe.parentNode) {\n          // If we've added an additional wrapper div, remove that from the DOM.\n          // If not, just remove the iframe element.\n          if (iframe.parentNode.parentNode && this._originalElement && this._originalElement !== iframe.parentNode) {\n            iframe.parentNode.parentNode.removeChild(iframe.parentNode);\n          } else {\n            iframe.parentNode.removeChild(iframe);\n          }\n        }\n      }\n\n      this._window.removeEventListener('message', this._onMessage);\n\n      resolve();\n    });\n  }\n  /**\n   * A promise to get the autopause behavior of the video.\n   *\n   * @promise GetAutopausePromise\n   * @fulfill {boolean} Whether autopause is turned on or off.\n   * @reject {UnsupportedError} Autopause is not supported with the current\n   *         player or browser.\n   */\n\n  /**\n   * Get the autopause behavior for this player.\n   *\n   * @return {GetAutopausePromise}\n   */\n\n\n  getAutopause() {\n    return this.get('autopause');\n  }\n  /**\n   * A promise to set the autopause behavior of the video.\n   *\n   * @promise SetAutopausePromise\n   * @fulfill {boolean} Whether autopause is turned on or off.\n   * @reject {UnsupportedError} Autopause is not supported with the current\n   *         player or browser.\n   */\n\n  /**\n   * Enable or disable the autopause behavior of this player.\n   *\n   * By default, when another video is played in the same browser, this\n   * player will automatically pause. Unless you have a specific reason\n   * for doing so, we recommend that you leave autopause set to the\n   * default (`true`).\n   *\n   * @param {boolean} autopause\n   * @return {SetAutopausePromise}\n   */\n\n\n  setAutopause(autopause) {\n    return this.set('autopause', autopause);\n  }\n  /**\n   * A promise to get the buffered property of the video.\n   *\n   * @promise GetBufferedPromise\n   * @fulfill {Array} Buffered Timeranges converted to an Array.\n   */\n\n  /**\n   * Get the buffered property of the video.\n   *\n   * @return {GetBufferedPromise}\n   */\n\n\n  getBuffered() {\n    return this.get('buffered');\n  }\n  /**\n   * @typedef {Object} CameraProperties\n   * @prop {number} props.yaw - Number between 0 and 360.\n   * @prop {number} props.pitch - Number between -90 and 90.\n   * @prop {number} props.roll - Number between -180 and 180.\n   * @prop {number} props.fov - The field of view in degrees.\n   */\n\n  /**\n   * A promise to get the camera properties of the player.\n   *\n   * @promise GetCameraPromise\n   * @fulfill {CameraProperties} The camera properties.\n   */\n\n  /**\n   * For 360° videos get the camera properties for this player.\n   *\n   * @return {GetCameraPromise}\n   */\n\n\n  getCameraProps() {\n    return this.get('cameraProps');\n  }\n  /**\n   * A promise to set the camera properties of the player.\n   *\n   * @promise SetCameraPromise\n   * @fulfill {Object} The camera was successfully set.\n   * @reject {RangeError} The range was out of bounds.\n   */\n\n  /**\n   * For 360° videos set the camera properties for this player.\n   *\n   * @param {CameraProperties} camera The camera properties\n   * @return {SetCameraPromise}\n   */\n\n\n  setCameraProps(camera) {\n    return this.set('cameraProps', camera);\n  }\n  /**\n   * A representation of a chapter.\n   *\n   * @typedef {Object} VimeoChapter\n   * @property {number} startTime The start time of the chapter.\n   * @property {object} title The title of the chapter.\n   * @property {number} index The place in the order of Chapters. Starts at 1.\n   */\n\n  /**\n   * A promise to get chapters for the video.\n   *\n   * @promise GetChaptersPromise\n   * @fulfill {VimeoChapter[]} The chapters for the video.\n   */\n\n  /**\n   * Get an array of all the chapters for the video.\n   *\n   * @return {GetChaptersPromise}\n   */\n\n\n  getChapters() {\n    return this.get('chapters');\n  }\n  /**\n   * A promise to get the currently active chapter.\n   *\n   * @promise GetCurrentChaptersPromise\n   * @fulfill {VimeoChapter|undefined} The current chapter for the video.\n   */\n\n  /**\n   * Get the currently active chapter for the video.\n   *\n   * @return {GetCurrentChaptersPromise}\n   */\n\n\n  getCurrentChapter() {\n    return this.get('currentChapter');\n  }\n  /**\n   * A promise to get the color of the player.\n   *\n   * @promise GetColorPromise\n   * @fulfill {string} The hex color of the player.\n   */\n\n  /**\n   * Get the color for this player.\n   *\n   * @return {GetColorPromise}\n   */\n\n\n  getColor() {\n    return this.get('color');\n  }\n  /**\n   * A promise to set the color of the player.\n   *\n   * @promise SetColorPromise\n   * @fulfill {string} The color was successfully set.\n   * @reject {TypeError} The string was not a valid hex or rgb color.\n   * @reject {ContrastError} The color was set, but the contrast is\n   *         outside of the acceptable range.\n   * @reject {EmbedSettingsError} The owner of the player has chosen to\n   *         use a specific color.\n   */\n\n  /**\n   * Set the color of this player to a hex or rgb string. Setting the\n   * color may fail if the owner of the video has set their embed\n   * preferences to force a specific color.\n   *\n   * @param {string} color The hex or rgb color string to set.\n   * @return {SetColorPromise}\n   */\n\n\n  setColor(color) {\n    return this.set('color', color);\n  }\n  /**\n   * A representation of a cue point.\n   *\n   * @typedef {Object} VimeoCuePoint\n   * @property {number} time The time of the cue point.\n   * @property {object} data The data passed when adding the cue point.\n   * @property {string} id The unique id for use with removeCuePoint.\n   */\n\n  /**\n   * A promise to get the cue points of a video.\n   *\n   * @promise GetCuePointsPromise\n   * @fulfill {VimeoCuePoint[]} The cue points added to the video.\n   * @reject {UnsupportedError} Cue points are not supported with the current\n   *         player or browser.\n   */\n\n  /**\n   * Get an array of the cue points added to the video.\n   *\n   * @return {GetCuePointsPromise}\n   */\n\n\n  getCuePoints() {\n    return this.get('cuePoints');\n  }\n  /**\n   * A promise to get the current time of the video.\n   *\n   * @promise GetCurrentTimePromise\n   * @fulfill {number} The current time in seconds.\n   */\n\n  /**\n   * Get the current playback position in seconds.\n   *\n   * @return {GetCurrentTimePromise}\n   */\n\n\n  getCurrentTime() {\n    return this.get('currentTime');\n  }\n  /**\n   * A promise to set the current time of the video.\n   *\n   * @promise SetCurrentTimePromise\n   * @fulfill {number} The actual current time that was set.\n   * @reject {RangeError} the time was less than 0 or greater than the\n   *         video’s duration.\n   */\n\n  /**\n   * Set the current playback position in seconds. If the player was\n   * paused, it will remain paused. Likewise, if the player was playing,\n   * it will resume playing once the video has buffered.\n   *\n   * You can provide an accurate time and the player will attempt to seek\n   * to as close to that time as possible. The exact time will be the\n   * fulfilled value of the promise.\n   *\n   * @param {number} currentTime\n   * @return {SetCurrentTimePromise}\n   */\n\n\n  setCurrentTime(currentTime) {\n    return this.set('currentTime', currentTime);\n  }\n  /**\n   * A promise to get the duration of the video.\n   *\n   * @promise GetDurationPromise\n   * @fulfill {number} The duration in seconds.\n   */\n\n  /**\n   * Get the duration of the video in seconds. It will be rounded to the\n   * nearest second before playback begins, and to the nearest thousandth\n   * of a second after playback begins.\n   *\n   * @return {GetDurationPromise}\n   */\n\n\n  getDuration() {\n    return this.get('duration');\n  }\n  /**\n   * A promise to get the ended state of the video.\n   *\n   * @promise GetEndedPromise\n   * @fulfill {boolean} Whether or not the video has ended.\n   */\n\n  /**\n   * Get the ended state of the video. The video has ended if\n   * `currentTime === duration`.\n   *\n   * @return {GetEndedPromise}\n   */\n\n\n  getEnded() {\n    return this.get('ended');\n  }\n  /**\n   * A promise to get the loop state of the player.\n   *\n   * @promise GetLoopPromise\n   * @fulfill {boolean} Whether or not the player is set to loop.\n   */\n\n  /**\n   * Get the loop state of the player.\n   *\n   * @return {GetLoopPromise}\n   */\n\n\n  getLoop() {\n    return this.get('loop');\n  }\n  /**\n   * A promise to set the loop state of the player.\n   *\n   * @promise SetLoopPromise\n   * @fulfill {boolean} The loop state that was set.\n   */\n\n  /**\n   * Set the loop state of the player. When set to `true`, the player\n   * will start over immediately once playback ends.\n   *\n   * @param {boolean} loop\n   * @return {SetLoopPromise}\n   */\n\n\n  setLoop(loop) {\n    return this.set('loop', loop);\n  }\n  /**\n   * A promise to set the muted state of the player.\n   *\n   * @promise SetMutedPromise\n   * @fulfill {boolean} The muted state that was set.\n   */\n\n  /**\n   * Set the muted state of the player. When set to `true`, the player\n   * volume will be muted.\n   *\n   * @param {boolean} muted\n   * @return {SetMutedPromise}\n   */\n\n\n  setMuted(muted) {\n    return this.set('muted', muted);\n  }\n  /**\n   * A promise to get the muted state of the player.\n   *\n   * @promise GetMutedPromise\n   * @fulfill {boolean} Whether or not the player is muted.\n   */\n\n  /**\n   * Get the muted state of the player.\n   *\n   * @return {GetMutedPromise}\n   */\n\n\n  getMuted() {\n    return this.get('muted');\n  }\n  /**\n   * A promise to get the paused state of the player.\n   *\n   * @promise GetLoopPromise\n   * @fulfill {boolean} Whether or not the video is paused.\n   */\n\n  /**\n   * Get the paused state of the player.\n   *\n   * @return {GetLoopPromise}\n   */\n\n\n  getPaused() {\n    return this.get('paused');\n  }\n  /**\n   * A promise to get the playback rate of the player.\n   *\n   * @promise GetPlaybackRatePromise\n   * @fulfill {number} The playback rate of the player on a scale from 0.5 to 2.\n   */\n\n  /**\n   * Get the playback rate of the player on a scale from `0.5` to `2`.\n   *\n   * @return {GetPlaybackRatePromise}\n   */\n\n\n  getPlaybackRate() {\n    return this.get('playbackRate');\n  }\n  /**\n   * A promise to set the playbackrate of the player.\n   *\n   * @promise SetPlaybackRatePromise\n   * @fulfill {number} The playback rate was set.\n   * @reject {RangeError} The playback rate was less than 0.5 or greater than 2.\n   */\n\n  /**\n   * Set the playback rate of the player on a scale from `0.5` to `2`. When set\n   * via the API, the playback rate will not be synchronized to other\n   * players or stored as the viewer's preference.\n   *\n   * @param {number} playbackRate\n   * @return {SetPlaybackRatePromise}\n   */\n\n\n  setPlaybackRate(playbackRate) {\n    return this.set('playbackRate', playbackRate);\n  }\n  /**\n   * A promise to get the played property of the video.\n   *\n   * @promise GetPlayedPromise\n   * @fulfill {Array} Played Timeranges converted to an Array.\n   */\n\n  /**\n   * Get the played property of the video.\n   *\n   * @return {GetPlayedPromise}\n   */\n\n\n  getPlayed() {\n    return this.get('played');\n  }\n  /**\n   * A promise to get the qualities available of the current video.\n   *\n   * @promise GetQualitiesPromise\n   * @fulfill {Array} The qualities of the video.\n   */\n\n  /**\n   * Get the qualities of the current video.\n   *\n   * @return {GetQualitiesPromise}\n   */\n\n\n  getQualities() {\n    return this.get('qualities');\n  }\n  /**\n   * A promise to get the current set quality of the video.\n   *\n   * @promise GetQualityPromise\n   * @fulfill {string} The current set quality.\n   */\n\n  /**\n   * Get the current set quality of the video.\n   *\n   * @return {GetQualityPromise}\n   */\n\n\n  getQuality() {\n    return this.get('quality');\n  }\n  /**\n   * A promise to set the video quality.\n   *\n   * @promise SetQualityPromise\n   * @fulfill {number} The quality was set.\n   * @reject {RangeError} The quality is not available.\n   */\n\n  /**\n   * Set a video quality.\n   *\n   * @param {string} quality\n   * @return {SetQualityPromise}\n   */\n\n\n  setQuality(quality) {\n    return this.set('quality', quality);\n  }\n  /**\n   * A promise to get the seekable property of the video.\n   *\n   * @promise GetSeekablePromise\n   * @fulfill {Array} Seekable Timeranges converted to an Array.\n   */\n\n  /**\n   * Get the seekable property of the video.\n   *\n   * @return {GetSeekablePromise}\n   */\n\n\n  getSeekable() {\n    return this.get('seekable');\n  }\n  /**\n   * A promise to get the seeking property of the player.\n   *\n   * @promise GetSeekingPromise\n   * @fulfill {boolean} Whether or not the player is currently seeking.\n   */\n\n  /**\n   * Get if the player is currently seeking.\n   *\n   * @return {GetSeekingPromise}\n   */\n\n\n  getSeeking() {\n    return this.get('seeking');\n  }\n  /**\n   * A promise to get the text tracks of a video.\n   *\n   * @promise GetTextTracksPromise\n   * @fulfill {VimeoTextTrack[]} The text tracks associated with the video.\n   */\n\n  /**\n   * Get an array of the text tracks that exist for the video.\n   *\n   * @return {GetTextTracksPromise}\n   */\n\n\n  getTextTracks() {\n    return this.get('textTracks');\n  }\n  /**\n   * A promise to get the embed code for the video.\n   *\n   * @promise GetVideoEmbedCodePromise\n   * @fulfill {string} The `<iframe>` embed code for the video.\n   */\n\n  /**\n   * Get the `<iframe>` embed code for the video.\n   *\n   * @return {GetVideoEmbedCodePromise}\n   */\n\n\n  getVideoEmbedCode() {\n    return this.get('videoEmbedCode');\n  }\n  /**\n   * A promise to get the id of the video.\n   *\n   * @promise GetVideoIdPromise\n   * @fulfill {number} The id of the video.\n   */\n\n  /**\n   * Get the id of the video.\n   *\n   * @return {GetVideoIdPromise}\n   */\n\n\n  getVideoId() {\n    return this.get('videoId');\n  }\n  /**\n   * A promise to get the title of the video.\n   *\n   * @promise GetVideoTitlePromise\n   * @fulfill {number} The title of the video.\n   */\n\n  /**\n   * Get the title of the video.\n   *\n   * @return {GetVideoTitlePromise}\n   */\n\n\n  getVideoTitle() {\n    return this.get('videoTitle');\n  }\n  /**\n   * A promise to get the native width of the video.\n   *\n   * @promise GetVideoWidthPromise\n   * @fulfill {number} The native width of the video.\n   */\n\n  /**\n   * Get the native width of the currently‐playing video. The width of\n   * the highest‐resolution available will be used before playback begins.\n   *\n   * @return {GetVideoWidthPromise}\n   */\n\n\n  getVideoWidth() {\n    return this.get('videoWidth');\n  }\n  /**\n   * A promise to get the native height of the video.\n   *\n   * @promise GetVideoHeightPromise\n   * @fulfill {number} The native height of the video.\n   */\n\n  /**\n   * Get the native height of the currently‐playing video. The height of\n   * the highest‐resolution available will be used before playback begins.\n   *\n   * @return {GetVideoHeightPromise}\n   */\n\n\n  getVideoHeight() {\n    return this.get('videoHeight');\n  }\n  /**\n   * A promise to get the vimeo.com url for the video.\n   *\n   * @promise GetVideoUrlPromise\n   * @fulfill {number} The vimeo.com url for the video.\n   * @reject {PrivacyError} The url isn’t available because of the video’s privacy setting.\n   */\n\n  /**\n   * Get the vimeo.com url for the video.\n   *\n   * @return {GetVideoUrlPromise}\n   */\n\n\n  getVideoUrl() {\n    return this.get('videoUrl');\n  }\n  /**\n   * A promise to get the volume level of the player.\n   *\n   * @promise GetVolumePromise\n   * @fulfill {number} The volume level of the player on a scale from 0 to 1.\n   */\n\n  /**\n   * Get the current volume level of the player on a scale from `0` to `1`.\n   *\n   * Most mobile devices do not support an independent volume from the\n   * system volume. In those cases, this method will always return `1`.\n   *\n   * @return {GetVolumePromise}\n   */\n\n\n  getVolume() {\n    return this.get('volume');\n  }\n  /**\n   * A promise to set the volume level of the player.\n   *\n   * @promise SetVolumePromise\n   * @fulfill {number} The volume was set.\n   * @reject {RangeError} The volume was less than 0 or greater than 1.\n   */\n\n  /**\n   * Set the volume of the player on a scale from `0` to `1`. When set\n   * via the API, the volume level will not be synchronized to other\n   * players or stored as the viewer’s preference.\n   *\n   * Most mobile devices do not support setting the volume. An error will\n   * *not* be triggered in that situation.\n   *\n   * @param {number} volume\n   * @return {SetVolumePromise}\n   */\n\n\n  setVolume(volume) {\n    return this.set('volume', volume);\n  }\n\n} // Setup embed only if this is not a node environment\n\n\nif (!isNode) {\n  screenfull = initializeScreenfull();\n  initializeEmbeds();\n  resizeEmbeds();\n}\n\nexport default Player;","map":{"version":3,"sources":["/Users/seito/Documents/develop/shadowX/my-app/node_modules/@vimeo/player/src/player.js"],"names":["Promise","storeCallback","getCallbacks","removeCallback","swapCallbacks","getMethodName","isDomElement","isVimeoUrl","getVimeoUrl","isNode","getOEmbedParameters","getOEmbedData","createEmbed","initializeEmbeds","resizeEmbeds","parseMessageData","postMessage","processData","initializeScreenfull","playerMap","WeakMap","readyMap","screenfull","Player","constructor","element","options","window","jQuery","length","console","warn","document","getElementById","TypeError","nodeName","iframe","querySelector","getAttribute","Error","has","get","_window","ownerDocument","defaultView","origin","readyPromise","resolve","reject","_onMessage","event","contentWindow","source","data","isError","isReadyError","method","error","message","name","isReadyEvent","isPingResponse","setAttribute","addEventListener","params","url","then","_originalElement","set","catch","isEnabled","exitFullscreen","exit","on","isFullscreen","ready","callMethod","args","value","undefined","eventName","callback","callbacks","off","lastCallback","e","loadVideo","addCuePoint","time","removeCuePoint","id","enableTextTrack","language","kind","disableTextTrack","pause","play","requestFullscreen","request","getFullscreen","requestPictureInPicture","exitPictureInPicture","getPictureInPicture","unload","destroy","delete","removeAttribute","parentNode","removeChild","removeEventListener","getAutopause","setAutopause","autopause","getBuffered","getCameraProps","setCameraProps","camera","getChapters","getCurrentChapter","getColor","setColor","color","getCuePoints","getCurrentTime","setCurrentTime","currentTime","getDuration","getEnded","getLoop","setLoop","loop","setMuted","muted","getMuted","getPaused","getPlaybackRate","setPlaybackRate","playbackRate","getPlayed","getQualities","getQuality","setQuality","quality","getSeekable","getSeeking","getTextTracks","getVideoEmbedCode","getVideoId","getVideoTitle","getVideoWidth","getVideoHeight","getVideoUrl","getVolume","setVolume","volume"],"mappings":"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A;AACA;;;AACIsE,EAAAA,YAAY,CAACC,SAAD,EAAY;AACpB,WAAO,KAAK5C,GAAL,CAAS,WAAT,EAAsB4C,SAAtB,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;AACI;AACJ;AACA;AACA;AACA;;;AACIC,EAAAA,WAAW,GAAG;AACV,WAAO,KAAKxE,GAAL,CAAS,UAAT,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;;AACI;AACJ;AACA;AACA;AACA;AACA;;AACI;AACJ;AACA;AACA;AACA;;;AACIyE,EAAAA,cAAc,GAAG;AACb,WAAO,KAAKzE,GAAL,CAAS,aAAT,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;;AACI;AACJ;AACA;AACA;AACA;AACA;;;AACI0E,EAAAA,cAAc,CAACC,MAAD,EAAS;AACnB,WAAO,KAAKhD,GAAL,CAAS,aAAT,EAAwBgD,MAAxB,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AACI;AACJ;AACA;AACA;AACA;AACA;;AACI;AACJ;AACA;AACA;AACA;;;AACIC,EAAAA,WAAW,GAAG;AACV,WAAO,KAAK5E,GAAL,CAAS,UAAT,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;AACI;AACJ;AACA;AACA;AACA;;;AACI6E,EAAAA,iBAAiB,GAAG;AAChB,WAAO,KAAK7E,GAAL,CAAS,gBAAT,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;AACI;AACJ;AACA;AACA;AACA;;;AACI8E,EAAAA,QAAQ,GAAG;AACP,WAAO,KAAK9E,GAAL,CAAS,OAAT,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI+E,EAAAA,QAAQ,CAACC,KAAD,EAAQ;AACZ,WAAO,KAAKrD,GAAL,CAAS,OAAT,EAAkBqD,KAAlB,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AACI;AACJ;AACA;AACA;AACA;;;AACIC,EAAAA,YAAY,GAAG;AACX,WAAO,KAAKjF,GAAL,CAAS,WAAT,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;AACI;AACJ;AACA;AACA;AACA;;;AACIkF,EAAAA,cAAc,GAAG;AACb,WAAO,KAAKlF,GAAL,CAAS,aAAT,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACImF,EAAAA,cAAc,CAACC,WAAD,EAAc;AACxB,WAAO,KAAKzD,GAAL,CAAS,aAAT,EAAwByD,WAAxB,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;AACI;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACIC,EAAAA,WAAW,GAAG;AACV,WAAO,KAAKrF,GAAL,CAAS,UAAT,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;AACI;AACJ;AACA;AACA;AACA;AACA;;;AACIsF,EAAAA,QAAQ,GAAG;AACP,WAAO,KAAKtF,GAAL,CAAS,OAAT,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;AACI;AACJ;AACA;AACA;AACA;;;AACIuF,EAAAA,OAAO,GAAG;AACN,WAAO,KAAKvF,GAAL,CAAS,MAAT,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;AACI;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACIwF,EAAAA,OAAO,CAACC,IAAD,EAAO;AACV,WAAO,KAAK9D,GAAL,CAAS,MAAT,EAAiB8D,IAAjB,CAAP;AACH;AAGD;AACJ;AACA;AACA;AACA;AACA;;AACI;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACIC,EAAAA,QAAQ,CAACC,KAAD,EAAQ;AACZ,WAAO,KAAKhE,GAAL,CAAS,OAAT,EAAkBgE,KAAlB,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;AACI;AACJ;AACA;AACA;AACA;;;AACIC,EAAAA,QAAQ,GAAG;AACP,WAAO,KAAK5F,GAAL,CAAS,OAAT,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;AACI;AACJ;AACA;AACA;AACA;;;AACI6F,EAAAA,SAAS,GAAG;AACR,WAAO,KAAK7F,GAAL,CAAS,QAAT,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;AACI;AACJ;AACA;AACA;AACA;;;AACI8F,EAAAA,eAAe,GAAG;AACd,WAAO,KAAK9F,GAAL,CAAS,cAAT,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;;AACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI+F,EAAAA,eAAe,CAACC,YAAD,EAAe;AAC1B,WAAO,KAAKrE,GAAL,CAAS,cAAT,EAAyBqE,YAAzB,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;AACI;AACJ;AACA;AACA;AACA;;;AACIC,EAAAA,SAAS,GAAG;AACR,WAAO,KAAKjG,GAAL,CAAS,QAAT,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;AACI;AACJ;AACA;AACA;AACA;;;AACIkG,EAAAA,YAAY,GAAG;AACX,WAAO,KAAKlG,GAAL,CAAS,WAAT,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;AACI;AACJ;AACA;AACA;AACA;;;AACImG,EAAAA,UAAU,GAAG;AACT,WAAO,KAAKnG,GAAL,CAAS,SAAT,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;;AACI;AACJ;AACA;AACA;AACA;AACA;;;AACIoG,EAAAA,UAAU,CAACC,OAAD,EAAU;AAChB,WAAO,KAAK1E,GAAL,CAAS,SAAT,EAAoB0E,OAApB,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;AACI;AACJ;AACA;AACA;AACA;;;AACIC,EAAAA,WAAW,GAAG;AACV,WAAO,KAAKtG,GAAL,CAAS,UAAT,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;AACI;AACJ;AACA;AACA;AACA;;;AACIuG,EAAAA,UAAU,GAAG;AACT,WAAO,KAAKvG,GAAL,CAAS,SAAT,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;AACI;AACJ;AACA;AACA;AACA;;;AACIwG,EAAAA,aAAa,GAAG;AACZ,WAAO,KAAKxG,GAAL,CAAS,YAAT,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;AACI;AACJ;AACA;AACA;AACA;;;AACIyG,EAAAA,iBAAiB,GAAG;AAChB,WAAO,KAAKzG,GAAL,CAAS,gBAAT,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;AACI;AACJ;AACA;AACA;AACA;;;AACI0G,EAAAA,UAAU,GAAG;AACT,WAAO,KAAK1G,GAAL,CAAS,SAAT,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;AACI;AACJ;AACA;AACA;AACA;;;AACI2G,EAAAA,aAAa,GAAG;AACZ,WAAO,KAAK3G,GAAL,CAAS,YAAT,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;AACI;AACJ;AACA;AACA;AACA;AACA;;;AACI4G,EAAAA,aAAa,GAAG;AACZ,WAAO,KAAK5G,GAAL,CAAS,YAAT,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;AACI;AACJ;AACA;AACA;AACA;AACA;;;AACI6G,EAAAA,cAAc,GAAG;AACb,WAAO,KAAK7G,GAAL,CAAS,aAAT,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;;AACI;AACJ;AACA;AACA;AACA;;;AACI8G,EAAAA,WAAW,GAAG;AACV,WAAO,KAAK9G,GAAL,CAAS,UAAT,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;AACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI+G,EAAAA,SAAS,GAAG;AACR,WAAO,KAAK/G,GAAL,CAAS,QAAT,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;;AACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIgH,EAAAA,SAAS,CAACC,MAAD,EAAS;AACd,WAAO,KAAKtF,GAAL,CAAS,QAAT,EAAmBsF,MAAnB,CAAP;AACH;;AAhqCQ,C,CAmqCb;;;AACA,IAAI,CAACjJ,MAAL,EAAa;AACTa,EAAAA,UAAU,GAAGJ,oBAAoB,EAAjC;AACAL,EAAAA,gBAAgB;AAChBC,EAAAA,YAAY;AACf;;AAED,eAAeS,MAAf","sourcesContent":["import './lib/compatibility-check';\n\nimport 'weakmap-polyfill';\nimport Promise from 'native-promise-only';\n\nimport { storeCallback, getCallbacks, removeCallback, swapCallbacks } from './lib/callbacks';\nimport { getMethodName, isDomElement, isVimeoUrl, getVimeoUrl, isNode } from './lib/functions';\nimport { getOEmbedParameters, getOEmbedData, createEmbed, initializeEmbeds, resizeEmbeds } from './lib/embed';\nimport { parseMessageData, postMessage, processData } from './lib/postmessage';\nimport { initializeScreenfull } from './lib/screenfull.js';\n\nconst playerMap = new WeakMap();\nconst readyMap = new WeakMap();\nlet screenfull = {};\n\nclass Player {\n    /**\n     * Create a Player.\n     *\n     * @param {(HTMLIFrameElement|HTMLElement|string|jQuery)} element A reference to the Vimeo\n     *        player iframe, and id, or a jQuery object.\n     * @param {object} [options] oEmbed parameters to use when creating an embed in the element.\n     * @return {Player}\n     */\n    constructor(element, options = {}) {\n        /* global jQuery */\n        if (window.jQuery && element instanceof jQuery) {\n            if (element.length > 1 && window.console && console.warn) {\n                console.warn('A jQuery object with multiple elements was passed, using the first element.');\n            }\n\n            element = element[0];\n        }\n\n        // Find an element by ID\n        if (typeof document !== 'undefined' && typeof element === 'string') {\n            element = document.getElementById(element);\n        }\n\n        // Not an element!\n        if (!isDomElement(element)) {\n            throw new TypeError('You must pass either a valid element or a valid id.');\n        }\n\n        // Already initialized an embed in this div, so grab the iframe\n        if (element.nodeName !== 'IFRAME') {\n            const iframe = element.querySelector('iframe');\n\n            if (iframe) {\n                element = iframe;\n            }\n        }\n\n        // iframe url is not a Vimeo url\n        if (element.nodeName === 'IFRAME' && !isVimeoUrl(element.getAttribute('src') || '')) {\n            throw new Error('The player element passed isn’t a Vimeo embed.');\n        }\n\n        // If there is already a player object in the map, return that\n        if (playerMap.has(element)) {\n            return playerMap.get(element);\n        }\n\n        this._window = element.ownerDocument.defaultView;\n        this.element = element;\n        this.origin = '*';\n\n        const readyPromise = new Promise((resolve, reject) => {\n            this._onMessage = (event) => {\n                if (!isVimeoUrl(event.origin) || this.element.contentWindow !== event.source) {\n                    return;\n                }\n\n                if (this.origin === '*') {\n                    this.origin = event.origin;\n                }\n\n                const data = parseMessageData(event.data);\n                const isError = data && data.event === 'error';\n                const isReadyError = isError && data.data && data.data.method === 'ready';\n\n                if (isReadyError) {\n                    const error = new Error(data.data.message);\n                    error.name = data.data.name;\n                    reject(error);\n                    return;\n                }\n\n                const isReadyEvent = data && data.event === 'ready';\n                const isPingResponse = data && data.method === 'ping';\n\n                if (isReadyEvent || isPingResponse) {\n                    this.element.setAttribute('data-ready', 'true');\n                    resolve();\n                    return;\n                }\n\n                processData(this, data);\n            };\n\n            this._window.addEventListener('message', this._onMessage);\n\n            if (this.element.nodeName !== 'IFRAME') {\n                const params = getOEmbedParameters(element, options);\n                const url = getVimeoUrl(params);\n\n                getOEmbedData(url, params, element).then((data) => {\n                    const iframe = createEmbed(data, element);\n                    // Overwrite element with the new iframe,\n                    // but store reference to the original element\n                    this.element = iframe;\n                    this._originalElement = element;\n\n                    swapCallbacks(element, iframe);\n                    playerMap.set(this.element, this);\n\n                    return data;\n                }).catch(reject);\n            }\n        });\n\n        // Store a copy of this Player in the map\n        readyMap.set(this, readyPromise);\n        playerMap.set(this.element, this);\n\n        // Send a ping to the iframe so the ready promise will be resolved if\n        // the player is already ready.\n        if (this.element.nodeName === 'IFRAME') {\n            postMessage(this, 'ping');\n        }\n\n        if (screenfull.isEnabled) {\n            const exitFullscreen = () => screenfull.exit();\n\n            screenfull.on('fullscreenchange', () => {\n                if (screenfull.isFullscreen) {\n                    storeCallback(this, 'event:exitFullscreen', exitFullscreen);\n                }\n                else {\n                    removeCallback(this, 'event:exitFullscreen', exitFullscreen);\n                }\n                // eslint-disable-next-line\n                this.ready().then(() => {\n                    postMessage(this, 'fullscreenchange', screenfull.isFullscreen);\n                });\n            });\n        }\n\n        return this;\n    }\n\n    /**\n     * Get a promise for a method.\n     *\n     * @param {string} name The API method to call.\n     * @param {Object} [args={}] Arguments to send via postMessage.\n     * @return {Promise}\n     */\n    callMethod(name, args = {}) {\n        return new Promise((resolve, reject) => {\n            // We are storing the resolve/reject handlers to call later, so we\n            // can’t return here.\n            // eslint-disable-next-line promise/always-return\n            return this.ready().then(() => {\n                storeCallback(this, name, {\n                    resolve,\n                    reject\n                });\n\n                postMessage(this, name, args);\n            }).catch(reject);\n        });\n    }\n\n    /**\n     * Get a promise for the value of a player property.\n     *\n     * @param {string} name The property name\n     * @return {Promise}\n     */\n    get(name) {\n        return new Promise((resolve, reject) => {\n            name = getMethodName(name, 'get');\n\n            // We are storing the resolve/reject handlers to call later, so we\n            // can’t return here.\n            // eslint-disable-next-line promise/always-return\n            return this.ready().then(() => {\n                storeCallback(this, name, {\n                    resolve,\n                    reject\n                });\n\n                postMessage(this, name);\n            }).catch(reject);\n        });\n    }\n\n    /**\n     * Get a promise for setting the value of a player property.\n     *\n     * @param {string} name The API method to call.\n     * @param {mixed} value The value to set.\n     * @return {Promise}\n     */\n    set(name, value) {\n        return new Promise((resolve, reject) => {\n            name = getMethodName(name, 'set');\n\n            if (value === undefined || value === null) {\n                throw new TypeError('There must be a value to set.');\n            }\n\n            // We are storing the resolve/reject handlers to call later, so we\n            // can’t return here.\n            // eslint-disable-next-line promise/always-return\n            return this.ready().then(() => {\n                storeCallback(this, name, {\n                    resolve,\n                    reject\n                });\n\n                postMessage(this, name, value);\n            }).catch(reject);\n        });\n    }\n\n    /**\n     * Add an event listener for the specified event. Will call the\n     * callback with a single parameter, `data`, that contains the data for\n     * that event.\n     *\n     * @param {string} eventName The name of the event.\n     * @param {function(*)} callback The function to call when the event fires.\n     * @return {void}\n     */\n    on(eventName, callback) {\n        if (!eventName) {\n            throw new TypeError('You must pass an event name.');\n        }\n\n        if (!callback) {\n            throw new TypeError('You must pass a callback function.');\n        }\n\n        if (typeof callback !== 'function') {\n            throw new TypeError('The callback must be a function.');\n        }\n\n        const callbacks = getCallbacks(this, `event:${eventName}`);\n        if (callbacks.length === 0) {\n            this.callMethod('addEventListener', eventName).catch(() => {\n                // Ignore the error. There will be an error event fired that\n                // will trigger the error callback if they are listening.\n            });\n        }\n\n        storeCallback(this, `event:${eventName}`, callback);\n    }\n\n    /**\n     * Remove an event listener for the specified event. Will remove all\n     * listeners for that event if a `callback` isn’t passed, or only that\n     * specific callback if it is passed.\n     *\n     * @param {string} eventName The name of the event.\n     * @param {function} [callback] The specific callback to remove.\n     * @return {void}\n     */\n    off(eventName, callback) {\n        if (!eventName) {\n            throw new TypeError('You must pass an event name.');\n        }\n\n        if (callback && typeof callback !== 'function') {\n            throw new TypeError('The callback must be a function.');\n        }\n\n        const lastCallback = removeCallback(this, `event:${eventName}`, callback);\n\n        // If there are no callbacks left, remove the listener\n        if (lastCallback) {\n            this.callMethod('removeEventListener', eventName).catch((e) => {\n                // Ignore the error. There will be an error event fired that\n                // will trigger the error callback if they are listening.\n            });\n        }\n    }\n\n    /**\n     * A promise to load a new video.\n     *\n     * @promise LoadVideoPromise\n     * @fulfill {number} The video with this id successfully loaded.\n     * @reject {TypeError} The id was not a number.\n     */\n    /**\n     * Load a new video into this embed. The promise will be resolved if\n     * the video is successfully loaded, or it will be rejected if it could\n     * not be loaded.\n     *\n     * @param {number|object} options The id of the video or an object with embed options.\n     * @return {LoadVideoPromise}\n     */\n    loadVideo(options) {\n        return this.callMethod('loadVideo', options);\n    }\n\n    /**\n     * A promise to perform an action when the Player is ready.\n     *\n     * @todo document errors\n     * @promise LoadVideoPromise\n     * @fulfill {void}\n     */\n    /**\n     * Trigger a function when the player iframe has initialized. You do not\n     * need to wait for `ready` to trigger to begin adding event listeners\n     * or calling other methods.\n     *\n     * @return {ReadyPromise}\n     */\n    ready() {\n        const readyPromise = readyMap.get(this) || new Promise((resolve, reject) => {\n            reject(new Error('Unknown player. Probably unloaded.'));\n        });\n        return Promise.resolve(readyPromise);\n    }\n\n    /**\n     * A promise to add a cue point to the player.\n     *\n     * @promise AddCuePointPromise\n     * @fulfill {string} The id of the cue point to use for removeCuePoint.\n     * @reject {RangeError} the time was less than 0 or greater than the\n     *         video’s duration.\n     * @reject {UnsupportedError} Cue points are not supported with the current\n     *         player or browser.\n     */\n    /**\n     * Add a cue point to the player.\n     *\n     * @param {number} time The time for the cue point.\n     * @param {object} [data] Arbitrary data to be returned with the cue point.\n     * @return {AddCuePointPromise}\n     */\n    addCuePoint(time, data = {}) {\n        return this.callMethod('addCuePoint', { time, data });\n    }\n\n    /**\n     * A promise to remove a cue point from the player.\n     *\n     * @promise AddCuePointPromise\n     * @fulfill {string} The id of the cue point that was removed.\n     * @reject {InvalidCuePoint} The cue point with the specified id was not\n     *         found.\n     * @reject {UnsupportedError} Cue points are not supported with the current\n     *         player or browser.\n     */\n    /**\n     * Remove a cue point from the video.\n     *\n     * @param {string} id The id of the cue point to remove.\n     * @return {RemoveCuePointPromise}\n     */\n    removeCuePoint(id) {\n        return this.callMethod('removeCuePoint', id);\n    }\n\n    /**\n     * A representation of a text track on a video.\n     *\n     * @typedef {Object} VimeoTextTrack\n     * @property {string} language The ISO language code.\n     * @property {string} kind The kind of track it is (captions or subtitles).\n     * @property {string} label The human‐readable label for the track.\n     */\n    /**\n     * A promise to enable a text track.\n     *\n     * @promise EnableTextTrackPromise\n     * @fulfill {VimeoTextTrack} The text track that was enabled.\n     * @reject {InvalidTrackLanguageError} No track was available with the\n     *         specified language.\n     * @reject {InvalidTrackError} No track was available with the specified\n     *         language and kind.\n     */\n    /**\n     * Enable the text track with the specified language, and optionally the\n     * specified kind (captions or subtitles).\n     *\n     * When set via the API, the track language will not change the viewer’s\n     * stored preference.\n     *\n     * @param {string} language The two‐letter language code.\n     * @param {string} [kind] The kind of track to enable (captions or subtitles).\n     * @return {EnableTextTrackPromise}\n     */\n    enableTextTrack(language, kind) {\n        if (!language) {\n            throw new TypeError('You must pass a language.');\n        }\n\n        return this.callMethod('enableTextTrack', {\n            language,\n            kind\n        });\n    }\n\n    /**\n     * A promise to disable the active text track.\n     *\n     * @promise DisableTextTrackPromise\n     * @fulfill {void} The track was disabled.\n     */\n    /**\n     * Disable the currently-active text track.\n     *\n     * @return {DisableTextTrackPromise}\n     */\n    disableTextTrack() {\n        return this.callMethod('disableTextTrack');\n    }\n\n    /**\n     * A promise to pause the video.\n     *\n     * @promise PausePromise\n     * @fulfill {void} The video was paused.\n     */\n    /**\n     * Pause the video if it’s playing.\n     *\n     * @return {PausePromise}\n     */\n    pause() {\n        return this.callMethod('pause');\n    }\n\n    /**\n     * A promise to play the video.\n     *\n     * @promise PlayPromise\n     * @fulfill {void} The video was played.\n     */\n    /**\n     * Play the video if it’s paused. **Note:** on iOS and some other\n     * mobile devices, you cannot programmatically trigger play. Once the\n     * viewer has tapped on the play button in the player, however, you\n     * will be able to use this function.\n     *\n     * @return {PlayPromise}\n     */\n    play() {\n        return this.callMethod('play');\n    }\n\n    /**\n     * Request that the player enters fullscreen.\n     * @return {Promise}\n     */\n    requestFullscreen() {\n        if (screenfull.isEnabled) {\n            return screenfull.request(this.element);\n        }\n        return this.callMethod('requestFullscreen');\n    }\n\n    /**\n     * Request that the player exits fullscreen.\n     * @return {Promise}\n     */\n    exitFullscreen() {\n        if (screenfull.isEnabled) {\n            return screenfull.exit();\n        }\n        return this.callMethod('exitFullscreen');\n    }\n\n    /**\n     * Returns true if the player is currently fullscreen.\n     * @return {Promise}\n     */\n    getFullscreen() {\n        if (screenfull.isEnabled) {\n            return Promise.resolve(screenfull.isFullscreen);\n        }\n        return this.get('fullscreen');\n    }\n\n    /**\n     * Request that the player enters picture-in-picture.\n     * @return {Promise}\n     */\n    requestPictureInPicture() {\n        return this.callMethod('requestPictureInPicture');\n    }\n\n    /**\n     * Request that the player exits picture-in-picture.\n     * @return {Promise}\n     */\n    exitPictureInPicture() {\n        return this.callMethod('exitPictureInPicture');\n    }\n\n    /**\n     * Returns true if the player is currently picture-in-picture.\n     * @return {Promise}\n     */\n    getPictureInPicture() {\n        return this.get('pictureInPicture');\n    }\n\n    /**\n     * A promise to unload the video.\n     *\n     * @promise UnloadPromise\n     * @fulfill {void} The video was unloaded.\n     */\n    /**\n     * Return the player to its initial state.\n     *\n     * @return {UnloadPromise}\n     */\n    unload() {\n        return this.callMethod('unload');\n    }\n\n    /**\n     * Cleanup the player and remove it from the DOM\n     *\n     * It won't be usable and a new one should be constructed\n     *  in order to do any operations.\n     *\n     * @return {Promise}\n     */\n    destroy() {\n        return new Promise((resolve) => {\n            readyMap.delete(this);\n            playerMap.delete(this.element);\n\n            if (this._originalElement) {\n                playerMap.delete(this._originalElement);\n                this._originalElement.removeAttribute('data-vimeo-initialized');\n            }\n\n            if (this.element && this.element.nodeName === 'IFRAME' && this.element.parentNode) {\n                // If we've added an additional wrapper div, remove that from the DOM.\n                // If not, just remove the iframe element.\n                if (this.element.parentNode.parentNode && this._originalElement && this._originalElement !== this.element.parentNode) {\n                    this.element.parentNode.parentNode.removeChild(this.element.parentNode);\n                } else {\n                    this.element.parentNode.removeChild(this.element);\n                }\n            }\n\n            // If the clip is private there is a case where the element stays the\n            // div element. Destroy should reset the div and remove the iframe child.\n            if (this.element && this.element.nodeName === 'DIV' && this.element.parentNode) {\n                this.element.removeAttribute('data-vimeo-initialized');\n                const iframe = this.element.querySelector('iframe');\n                if (iframe && iframe.parentNode) {\n                    // If we've added an additional wrapper div, remove that from the DOM.\n                    // If not, just remove the iframe element.\n                    if (iframe.parentNode.parentNode && this._originalElement && this._originalElement !== iframe.parentNode) {\n                        iframe.parentNode.parentNode.removeChild(iframe.parentNode);\n                    } else {\n                        iframe.parentNode.removeChild(iframe);\n                    }\n                }\n            }\n\n            this._window.removeEventListener('message', this._onMessage);\n\n            resolve();\n        });\n    }\n\n    /**\n     * A promise to get the autopause behavior of the video.\n     *\n     * @promise GetAutopausePromise\n     * @fulfill {boolean} Whether autopause is turned on or off.\n     * @reject {UnsupportedError} Autopause is not supported with the current\n     *         player or browser.\n     */\n    /**\n     * Get the autopause behavior for this player.\n     *\n     * @return {GetAutopausePromise}\n     */\n    getAutopause() {\n        return this.get('autopause');\n    }\n\n    /**\n     * A promise to set the autopause behavior of the video.\n     *\n     * @promise SetAutopausePromise\n     * @fulfill {boolean} Whether autopause is turned on or off.\n     * @reject {UnsupportedError} Autopause is not supported with the current\n     *         player or browser.\n     */\n    /**\n     * Enable or disable the autopause behavior of this player.\n     *\n     * By default, when another video is played in the same browser, this\n     * player will automatically pause. Unless you have a specific reason\n     * for doing so, we recommend that you leave autopause set to the\n     * default (`true`).\n     *\n     * @param {boolean} autopause\n     * @return {SetAutopausePromise}\n     */\n    setAutopause(autopause) {\n        return this.set('autopause', autopause);\n    }\n\n    /**\n     * A promise to get the buffered property of the video.\n     *\n     * @promise GetBufferedPromise\n     * @fulfill {Array} Buffered Timeranges converted to an Array.\n     */\n    /**\n     * Get the buffered property of the video.\n     *\n     * @return {GetBufferedPromise}\n     */\n    getBuffered() {\n        return this.get('buffered');\n    }\n\n    /**\n     * @typedef {Object} CameraProperties\n     * @prop {number} props.yaw - Number between 0 and 360.\n     * @prop {number} props.pitch - Number between -90 and 90.\n     * @prop {number} props.roll - Number between -180 and 180.\n     * @prop {number} props.fov - The field of view in degrees.\n     */\n    /**\n     * A promise to get the camera properties of the player.\n     *\n     * @promise GetCameraPromise\n     * @fulfill {CameraProperties} The camera properties.\n     */\n    /**\n     * For 360° videos get the camera properties for this player.\n     *\n     * @return {GetCameraPromise}\n     */\n    getCameraProps() {\n        return this.get('cameraProps');\n    }\n\n    /**\n     * A promise to set the camera properties of the player.\n     *\n     * @promise SetCameraPromise\n     * @fulfill {Object} The camera was successfully set.\n     * @reject {RangeError} The range was out of bounds.\n     */\n    /**\n     * For 360° videos set the camera properties for this player.\n     *\n     * @param {CameraProperties} camera The camera properties\n     * @return {SetCameraPromise}\n     */\n    setCameraProps(camera) {\n        return this.set('cameraProps', camera);\n    }\n\n    /**\n     * A representation of a chapter.\n     *\n     * @typedef {Object} VimeoChapter\n     * @property {number} startTime The start time of the chapter.\n     * @property {object} title The title of the chapter.\n     * @property {number} index The place in the order of Chapters. Starts at 1.\n     */\n    /**\n     * A promise to get chapters for the video.\n     *\n     * @promise GetChaptersPromise\n     * @fulfill {VimeoChapter[]} The chapters for the video.\n     */\n    /**\n     * Get an array of all the chapters for the video.\n     *\n     * @return {GetChaptersPromise}\n     */\n    getChapters() {\n        return this.get('chapters');\n    }\n\n    /**\n     * A promise to get the currently active chapter.\n     *\n     * @promise GetCurrentChaptersPromise\n     * @fulfill {VimeoChapter|undefined} The current chapter for the video.\n     */\n    /**\n     * Get the currently active chapter for the video.\n     *\n     * @return {GetCurrentChaptersPromise}\n     */\n    getCurrentChapter() {\n        return this.get('currentChapter');\n    }\n\n    /**\n     * A promise to get the color of the player.\n     *\n     * @promise GetColorPromise\n     * @fulfill {string} The hex color of the player.\n     */\n    /**\n     * Get the color for this player.\n     *\n     * @return {GetColorPromise}\n     */\n    getColor() {\n        return this.get('color');\n    }\n\n    /**\n     * A promise to set the color of the player.\n     *\n     * @promise SetColorPromise\n     * @fulfill {string} The color was successfully set.\n     * @reject {TypeError} The string was not a valid hex or rgb color.\n     * @reject {ContrastError} The color was set, but the contrast is\n     *         outside of the acceptable range.\n     * @reject {EmbedSettingsError} The owner of the player has chosen to\n     *         use a specific color.\n     */\n    /**\n     * Set the color of this player to a hex or rgb string. Setting the\n     * color may fail if the owner of the video has set their embed\n     * preferences to force a specific color.\n     *\n     * @param {string} color The hex or rgb color string to set.\n     * @return {SetColorPromise}\n     */\n    setColor(color) {\n        return this.set('color', color);\n    }\n\n    /**\n     * A representation of a cue point.\n     *\n     * @typedef {Object} VimeoCuePoint\n     * @property {number} time The time of the cue point.\n     * @property {object} data The data passed when adding the cue point.\n     * @property {string} id The unique id for use with removeCuePoint.\n     */\n    /**\n     * A promise to get the cue points of a video.\n     *\n     * @promise GetCuePointsPromise\n     * @fulfill {VimeoCuePoint[]} The cue points added to the video.\n     * @reject {UnsupportedError} Cue points are not supported with the current\n     *         player or browser.\n     */\n    /**\n     * Get an array of the cue points added to the video.\n     *\n     * @return {GetCuePointsPromise}\n     */\n    getCuePoints() {\n        return this.get('cuePoints');\n    }\n\n    /**\n     * A promise to get the current time of the video.\n     *\n     * @promise GetCurrentTimePromise\n     * @fulfill {number} The current time in seconds.\n     */\n    /**\n     * Get the current playback position in seconds.\n     *\n     * @return {GetCurrentTimePromise}\n     */\n    getCurrentTime() {\n        return this.get('currentTime');\n    }\n\n    /**\n     * A promise to set the current time of the video.\n     *\n     * @promise SetCurrentTimePromise\n     * @fulfill {number} The actual current time that was set.\n     * @reject {RangeError} the time was less than 0 or greater than the\n     *         video’s duration.\n     */\n    /**\n     * Set the current playback position in seconds. If the player was\n     * paused, it will remain paused. Likewise, if the player was playing,\n     * it will resume playing once the video has buffered.\n     *\n     * You can provide an accurate time and the player will attempt to seek\n     * to as close to that time as possible. The exact time will be the\n     * fulfilled value of the promise.\n     *\n     * @param {number} currentTime\n     * @return {SetCurrentTimePromise}\n     */\n    setCurrentTime(currentTime) {\n        return this.set('currentTime', currentTime);\n    }\n\n    /**\n     * A promise to get the duration of the video.\n     *\n     * @promise GetDurationPromise\n     * @fulfill {number} The duration in seconds.\n     */\n    /**\n     * Get the duration of the video in seconds. It will be rounded to the\n     * nearest second before playback begins, and to the nearest thousandth\n     * of a second after playback begins.\n     *\n     * @return {GetDurationPromise}\n     */\n    getDuration() {\n        return this.get('duration');\n    }\n\n    /**\n     * A promise to get the ended state of the video.\n     *\n     * @promise GetEndedPromise\n     * @fulfill {boolean} Whether or not the video has ended.\n     */\n    /**\n     * Get the ended state of the video. The video has ended if\n     * `currentTime === duration`.\n     *\n     * @return {GetEndedPromise}\n     */\n    getEnded() {\n        return this.get('ended');\n    }\n\n    /**\n     * A promise to get the loop state of the player.\n     *\n     * @promise GetLoopPromise\n     * @fulfill {boolean} Whether or not the player is set to loop.\n     */\n    /**\n     * Get the loop state of the player.\n     *\n     * @return {GetLoopPromise}\n     */\n    getLoop() {\n        return this.get('loop');\n    }\n\n    /**\n     * A promise to set the loop state of the player.\n     *\n     * @promise SetLoopPromise\n     * @fulfill {boolean} The loop state that was set.\n     */\n    /**\n     * Set the loop state of the player. When set to `true`, the player\n     * will start over immediately once playback ends.\n     *\n     * @param {boolean} loop\n     * @return {SetLoopPromise}\n     */\n    setLoop(loop) {\n        return this.set('loop', loop);\n    }\n\n\n    /**\n     * A promise to set the muted state of the player.\n     *\n     * @promise SetMutedPromise\n     * @fulfill {boolean} The muted state that was set.\n     */\n    /**\n     * Set the muted state of the player. When set to `true`, the player\n     * volume will be muted.\n     *\n     * @param {boolean} muted\n     * @return {SetMutedPromise}\n     */\n    setMuted(muted) {\n        return this.set('muted', muted);\n    }\n\n    /**\n     * A promise to get the muted state of the player.\n     *\n     * @promise GetMutedPromise\n     * @fulfill {boolean} Whether or not the player is muted.\n     */\n    /**\n     * Get the muted state of the player.\n     *\n     * @return {GetMutedPromise}\n     */\n    getMuted() {\n        return this.get('muted');\n    }\n\n    /**\n     * A promise to get the paused state of the player.\n     *\n     * @promise GetLoopPromise\n     * @fulfill {boolean} Whether or not the video is paused.\n     */\n    /**\n     * Get the paused state of the player.\n     *\n     * @return {GetLoopPromise}\n     */\n    getPaused() {\n        return this.get('paused');\n    }\n\n    /**\n     * A promise to get the playback rate of the player.\n     *\n     * @promise GetPlaybackRatePromise\n     * @fulfill {number} The playback rate of the player on a scale from 0.5 to 2.\n     */\n    /**\n     * Get the playback rate of the player on a scale from `0.5` to `2`.\n     *\n     * @return {GetPlaybackRatePromise}\n     */\n    getPlaybackRate() {\n        return this.get('playbackRate');\n    }\n\n    /**\n     * A promise to set the playbackrate of the player.\n     *\n     * @promise SetPlaybackRatePromise\n     * @fulfill {number} The playback rate was set.\n     * @reject {RangeError} The playback rate was less than 0.5 or greater than 2.\n     */\n    /**\n     * Set the playback rate of the player on a scale from `0.5` to `2`. When set\n     * via the API, the playback rate will not be synchronized to other\n     * players or stored as the viewer's preference.\n     *\n     * @param {number} playbackRate\n     * @return {SetPlaybackRatePromise}\n     */\n    setPlaybackRate(playbackRate) {\n        return this.set('playbackRate', playbackRate);\n    }\n\n    /**\n     * A promise to get the played property of the video.\n     *\n     * @promise GetPlayedPromise\n     * @fulfill {Array} Played Timeranges converted to an Array.\n     */\n    /**\n     * Get the played property of the video.\n     *\n     * @return {GetPlayedPromise}\n     */\n    getPlayed() {\n        return this.get('played');\n    }\n\n    /**\n     * A promise to get the qualities available of the current video.\n     *\n     * @promise GetQualitiesPromise\n     * @fulfill {Array} The qualities of the video.\n     */\n    /**\n     * Get the qualities of the current video.\n     *\n     * @return {GetQualitiesPromise}\n     */\n    getQualities() {\n        return this.get('qualities');\n    }\n\n    /**\n     * A promise to get the current set quality of the video.\n     *\n     * @promise GetQualityPromise\n     * @fulfill {string} The current set quality.\n     */\n    /**\n     * Get the current set quality of the video.\n     *\n     * @return {GetQualityPromise}\n     */\n    getQuality() {\n        return this.get('quality');\n    }\n\n    /**\n     * A promise to set the video quality.\n     *\n     * @promise SetQualityPromise\n     * @fulfill {number} The quality was set.\n     * @reject {RangeError} The quality is not available.\n     */\n    /**\n     * Set a video quality.\n     *\n     * @param {string} quality\n     * @return {SetQualityPromise}\n     */\n    setQuality(quality) {\n        return this.set('quality', quality);\n    }\n\n    /**\n     * A promise to get the seekable property of the video.\n     *\n     * @promise GetSeekablePromise\n     * @fulfill {Array} Seekable Timeranges converted to an Array.\n     */\n    /**\n     * Get the seekable property of the video.\n     *\n     * @return {GetSeekablePromise}\n     */\n    getSeekable() {\n        return this.get('seekable');\n    }\n\n    /**\n     * A promise to get the seeking property of the player.\n     *\n     * @promise GetSeekingPromise\n     * @fulfill {boolean} Whether or not the player is currently seeking.\n     */\n    /**\n     * Get if the player is currently seeking.\n     *\n     * @return {GetSeekingPromise}\n     */\n    getSeeking() {\n        return this.get('seeking');\n    }\n\n    /**\n     * A promise to get the text tracks of a video.\n     *\n     * @promise GetTextTracksPromise\n     * @fulfill {VimeoTextTrack[]} The text tracks associated with the video.\n     */\n    /**\n     * Get an array of the text tracks that exist for the video.\n     *\n     * @return {GetTextTracksPromise}\n     */\n    getTextTracks() {\n        return this.get('textTracks');\n    }\n\n    /**\n     * A promise to get the embed code for the video.\n     *\n     * @promise GetVideoEmbedCodePromise\n     * @fulfill {string} The `<iframe>` embed code for the video.\n     */\n    /**\n     * Get the `<iframe>` embed code for the video.\n     *\n     * @return {GetVideoEmbedCodePromise}\n     */\n    getVideoEmbedCode() {\n        return this.get('videoEmbedCode');\n    }\n\n    /**\n     * A promise to get the id of the video.\n     *\n     * @promise GetVideoIdPromise\n     * @fulfill {number} The id of the video.\n     */\n    /**\n     * Get the id of the video.\n     *\n     * @return {GetVideoIdPromise}\n     */\n    getVideoId() {\n        return this.get('videoId');\n    }\n\n    /**\n     * A promise to get the title of the video.\n     *\n     * @promise GetVideoTitlePromise\n     * @fulfill {number} The title of the video.\n     */\n    /**\n     * Get the title of the video.\n     *\n     * @return {GetVideoTitlePromise}\n     */\n    getVideoTitle() {\n        return this.get('videoTitle');\n    }\n\n    /**\n     * A promise to get the native width of the video.\n     *\n     * @promise GetVideoWidthPromise\n     * @fulfill {number} The native width of the video.\n     */\n    /**\n     * Get the native width of the currently‐playing video. The width of\n     * the highest‐resolution available will be used before playback begins.\n     *\n     * @return {GetVideoWidthPromise}\n     */\n    getVideoWidth() {\n        return this.get('videoWidth');\n    }\n\n    /**\n     * A promise to get the native height of the video.\n     *\n     * @promise GetVideoHeightPromise\n     * @fulfill {number} The native height of the video.\n     */\n    /**\n     * Get the native height of the currently‐playing video. The height of\n     * the highest‐resolution available will be used before playback begins.\n     *\n     * @return {GetVideoHeightPromise}\n     */\n    getVideoHeight() {\n        return this.get('videoHeight');\n    }\n\n    /**\n     * A promise to get the vimeo.com url for the video.\n     *\n     * @promise GetVideoUrlPromise\n     * @fulfill {number} The vimeo.com url for the video.\n     * @reject {PrivacyError} The url isn’t available because of the video’s privacy setting.\n     */\n    /**\n     * Get the vimeo.com url for the video.\n     *\n     * @return {GetVideoUrlPromise}\n     */\n    getVideoUrl() {\n        return this.get('videoUrl');\n    }\n\n    /**\n     * A promise to get the volume level of the player.\n     *\n     * @promise GetVolumePromise\n     * @fulfill {number} The volume level of the player on a scale from 0 to 1.\n     */\n    /**\n     * Get the current volume level of the player on a scale from `0` to `1`.\n     *\n     * Most mobile devices do not support an independent volume from the\n     * system volume. In those cases, this method will always return `1`.\n     *\n     * @return {GetVolumePromise}\n     */\n    getVolume() {\n        return this.get('volume');\n    }\n\n    /**\n     * A promise to set the volume level of the player.\n     *\n     * @promise SetVolumePromise\n     * @fulfill {number} The volume was set.\n     * @reject {RangeError} The volume was less than 0 or greater than 1.\n     */\n    /**\n     * Set the volume of the player on a scale from `0` to `1`. When set\n     * via the API, the volume level will not be synchronized to other\n     * players or stored as the viewer’s preference.\n     *\n     * Most mobile devices do not support setting the volume. An error will\n     * *not* be triggered in that situation.\n     *\n     * @param {number} volume\n     * @return {SetVolumePromise}\n     */\n    setVolume(volume) {\n        return this.set('volume', volume);\n    }\n}\n\n// Setup embed only if this is not a node environment\nif (!isNode) {\n    screenfull = initializeScreenfull();\n    initializeEmbeds();\n    resizeEmbeds();\n}\n\nexport default Player;\n"]},"metadata":{},"sourceType":"module"}