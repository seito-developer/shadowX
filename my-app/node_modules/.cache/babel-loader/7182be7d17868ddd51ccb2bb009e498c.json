{"ast":null,"code":"const fs = require('fs');\n\nconst url = require('url');\n\nconst os = require('os');\n\nconst path = require('path');\n\nconst crypto = require('crypto');\n\nconst chokidar = require('chokidar');\n\nconst postcss = require('postcss');\n\nconst hash = require('object-hash');\n\nconst dlv = require('dlv');\n\nconst selectorParser = require('postcss-selector-parser');\n\nconst LRU = require('quick-lru');\n\nconst normalizePath = require('normalize-path');\n\nconst transformThemeValue = require('../../lib/util/transformThemeValue').default;\n\nconst parseObjectStyles = require('../../lib/util/parseObjectStyles').default;\n\nconst getModuleDependencies = require('../../lib/lib/getModuleDependencies').default;\n\nconst prefixSelector = require('../../lib/util/prefixSelector').default;\n\nconst resolveConfig = require('../../resolveConfig');\n\nconst sharedState = require('./sharedState');\n\nconst corePlugins = require('../corePlugins');\n\nconst {\n  isPlainObject,\n  escapeClassName\n} = require('./utils');\n\nlet contextMap = sharedState.contextMap;\nlet configContextMap = sharedState.configContextMap;\nlet contextSourcesMap = sharedState.contextSourcesMap;\nlet env = sharedState.env; // Earmarks a directory for our touch files.\n// If the directory already exists we delete any existing touch files,\n// invalidating any caches associated with them.\n\nconst touchDir = env.TAILWIND_TOUCH_DIR || path.join(os.homedir() || os.tmpdir(), '.tailwindcss', 'touch');\n\nif (!sharedState.env.TAILWIND_DISABLE_TOUCH) {\n  if (fs.existsSync(touchDir)) {\n    for (let file of fs.readdirSync(touchDir)) {\n      try {\n        fs.unlinkSync(path.join(touchDir, file));\n      } catch (_err) {}\n    }\n  } else {\n    fs.mkdirSync(touchDir, {\n      recursive: true\n    });\n  }\n} // This is used to trigger rebuilds. Just updating the timestamp\n// is significantly faster than actually writing to the file (10x).\n\n\nfunction touch(filename) {\n  let time = new Date();\n\n  try {\n    fs.utimesSync(filename, time, time);\n  } catch (err) {\n    fs.closeSync(fs.openSync(filename, 'w'));\n  }\n}\n\nfunction isObject(value) {\n  return typeof value === 'object' && value !== null;\n}\n\nfunction isEmpty(obj) {\n  return Object.keys(obj).length === 0;\n}\n\nfunction isString(value) {\n  return typeof value === 'string' || value instanceof String;\n}\n\nfunction toPath(value) {\n  if (Array.isArray(value)) {\n    return value;\n  }\n\n  let inBrackets = false;\n  let parts = [];\n  let chunk = '';\n\n  for (let i = 0; i < value.length; i++) {\n    let char = value[i];\n\n    if (char === '[') {\n      inBrackets = true;\n      parts.push(chunk);\n      chunk = '';\n      continue;\n    }\n\n    if (char === ']' && inBrackets) {\n      inBrackets = false;\n      parts.push(chunk);\n      chunk = '';\n      continue;\n    }\n\n    if (char === '.' && !inBrackets && chunk.length > 0) {\n      parts.push(chunk);\n      chunk = '';\n      continue;\n    }\n\n    chunk = chunk + char;\n  }\n\n  if (chunk.length > 0) {\n    parts.push(chunk);\n  }\n\n  return parts;\n}\n\nfunction resolveConfigPath(pathOrConfig) {\n  // require('tailwindcss')({ theme: ..., variants: ... })\n  if (isObject(pathOrConfig) && pathOrConfig.config === undefined && !isEmpty(pathOrConfig)) {\n    return null;\n  } // require('tailwindcss')({ config: 'custom-config.js' })\n\n\n  if (isObject(pathOrConfig) && pathOrConfig.config !== undefined && isString(pathOrConfig.config)) {\n    return path.resolve(pathOrConfig.config);\n  } // require('tailwindcss')({ config: { theme: ..., variants: ... } })\n\n\n  if (isObject(pathOrConfig) && pathOrConfig.config !== undefined && isObject(pathOrConfig.config)) {\n    return null;\n  } // require('tailwindcss')('custom-config.js')\n\n\n  if (isString(pathOrConfig)) {\n    return path.resolve(pathOrConfig);\n  } // require('tailwindcss')\n\n\n  for (const configFile of ['./tailwind.config.js', './tailwind.config.cjs']) {\n    try {\n      const configPath = path.resolve(configFile);\n      fs.accessSync(configPath);\n      return configPath;\n    } catch (err) {}\n  }\n\n  return null;\n}\n\nlet configPathCache = new LRU({\n  maxSize: 100\n}); // Get the config object based on a path\n\nfunction getTailwindConfig(configOrPath) {\n  let userConfigPath = resolveConfigPath(configOrPath);\n\n  if (sharedState.env.TAILWIND_DISABLE_TOUCH) {\n    if (userConfigPath !== null) {\n      let [prevConfig, prevConfigHash, prevDeps, prevModified] = configPathCache.get(userConfigPath) || [];\n      let newDeps = getModuleDependencies(userConfigPath).map(dep => dep.file);\n      let modified = false;\n      let newModified = new Map();\n\n      for (let file of newDeps) {\n        let time = fs.statSync(file).mtimeMs;\n        newModified.set(file, time);\n\n        if (!prevModified || !prevModified.has(file) || time > prevModified.get(file)) {\n          modified = true;\n        }\n      } // It hasn't changed (based on timestamps)\n\n\n      if (!modified) {\n        return [prevConfig, userConfigPath, prevConfigHash, prevDeps];\n      } // It has changed (based on timestamps), or first run\n\n\n      for (let file of newDeps) {\n        delete require.cache[file];\n      }\n\n      let newConfig = resolveConfig(require(userConfigPath));\n      let newHash = hash(newConfig);\n      configPathCache.set(userConfigPath, [newConfig, newHash, newDeps, newModified]);\n      return [newConfig, userConfigPath, newHash, newDeps];\n    } // It's a plain object, not a path\n\n\n    let newConfig = resolveConfig(configOrPath.config === undefined ? configOrPath : configOrPath.config);\n    return [newConfig, null, hash(newConfig), []];\n  }\n\n  if (userConfigPath !== null) {\n    let [prevConfig, prevModified = -Infinity, prevConfigHash] = configPathCache.get(userConfigPath) || [];\n    let modified = fs.statSync(userConfigPath).mtimeMs; // It hasn't changed (based on timestamp)\n\n    if (modified <= prevModified) {\n      return [prevConfig, userConfigPath, prevConfigHash];\n    } // It has changed (based on timestamp), or first run\n\n\n    delete require.cache[userConfigPath];\n    let newConfig = resolveConfig(require(userConfigPath));\n    let newHash = hash(newConfig);\n    configPathCache.set(userConfigPath, [newConfig, modified, newHash]);\n    return [newConfig, userConfigPath, newHash];\n  } // It's a plain object, not a path\n\n\n  let newConfig = resolveConfig(configOrPath.config === undefined ? configOrPath : configOrPath.config);\n  return [newConfig, null, hash(newConfig)];\n}\n\nlet fileModifiedMap = new Map();\n\nfunction trackModified(files) {\n  let changed = false;\n\n  for (let file of files) {\n    if (!file) continue;\n    let pathname = url.parse(file).pathname;\n    let newModified = fs.statSync(decodeURIComponent(pathname)).mtimeMs;\n\n    if (!fileModifiedMap.has(file) || newModified > fileModifiedMap.get(file)) {\n      changed = true;\n    }\n\n    fileModifiedMap.set(file, newModified);\n  }\n\n  return changed;\n}\n\nfunction generateTouchFileName() {\n  let chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';\n  let randomChars = '';\n  let randomCharsLength = 12;\n  let bytes = null;\n\n  try {\n    bytes = crypto.randomBytes(randomCharsLength);\n  } catch (_error) {\n    bytes = crypto.pseudoRandomBytes(randomCharsLength);\n  }\n\n  for (let i = 0; i < randomCharsLength; i++) {\n    randomChars += chars[bytes[i] % chars.length];\n  }\n\n  return path.join(touchDir, `touch-${process.pid}-${randomChars}`);\n}\n\nfunction rebootWatcher(context) {\n  if (env.TAILWIND_DISABLE_TOUCH) {\n    return;\n  }\n\n  if (context.touchFile === null) {\n    context.touchFile = generateTouchFileName();\n    touch(context.touchFile);\n  }\n\n  if (env.TAILWIND_MODE === 'build') {\n    return;\n  }\n\n  if (env.TAILWIND_MODE === 'watch' || env.TAILWIND_MODE === undefined && env.NODE_ENV === 'development') {\n    Promise.resolve(context.watcher ? context.watcher.close() : null).then(() => {\n      context.watcher = chokidar.watch([...context.candidateFiles, ...context.configDependencies], {\n        ignoreInitial: true\n      });\n      context.watcher.on('add', file => {\n        context.changedFiles.add(path.resolve('.', file));\n        touch(context.touchFile);\n      });\n      context.watcher.on('change', file => {\n        // If it was a config dependency, touch the config file to trigger a new context.\n        // This is not really that clean of a solution but it's the fastest, because we\n        // can do a very quick check on each build to see if the config has changed instead\n        // of having to get all of the module dependencies and check every timestamp each\n        // time.\n        if (context.configDependencies.has(file)) {\n          for (let dependency of context.configDependencies) {\n            delete require.cache[require.resolve(dependency)];\n          }\n\n          touch(context.configPath);\n        } else {\n          context.changedFiles.add(path.resolve('.', file));\n          touch(context.touchFile);\n        }\n      });\n      context.watcher.on('unlink', file => {\n        // Touch the config file if any of the dependencies are deleted.\n        if (context.configDependencies.has(file)) {\n          for (let dependency of context.configDependencies) {\n            delete require.cache[require.resolve(dependency)];\n          }\n\n          touch(context.configPath);\n        }\n      });\n    });\n  }\n}\n\nfunction insertInto(list, value, {\n  before = []\n} = {}) {\n  before = [].concat(before);\n\n  if (before.length <= 0) {\n    list.push(value);\n    return;\n  }\n\n  let idx = list.length - 1;\n\n  for (let other of before) {\n    let iidx = list.indexOf(other);\n    if (iidx === -1) continue;\n    idx = Math.min(idx, iidx);\n  }\n\n  list.splice(idx, 0, value);\n}\n\nfunction parseStyles(styles) {\n  if (!Array.isArray(styles)) {\n    return parseStyles([styles]);\n  }\n\n  return styles.flatMap(style => {\n    let isNode = !Array.isArray(style) && !isPlainObject(style);\n    return isNode ? style : parseObjectStyles(style);\n  });\n}\n\nfunction getClasses(selector) {\n  let parser = selectorParser(selectors => {\n    let allClasses = [];\n    selectors.walkClasses(classNode => {\n      allClasses.push(classNode.value);\n    });\n    return allClasses;\n  });\n  return parser.transformSync(selector);\n}\n\nfunction extractCandidates(node) {\n  let classes = node.type === 'rule' ? getClasses(node.selector) : [];\n\n  if (node.type === 'atrule') {\n    node.walkRules(rule => {\n      classes = [...classes, ...getClasses(rule.selector)];\n    });\n  }\n\n  return classes;\n}\n\nfunction withIdentifiers(styles) {\n  return parseStyles(styles).flatMap(node => {\n    let nodeMap = new Map();\n    let candidates = extractCandidates(node); // If this isn't \"on-demandable\", assign it a universal candidate.\n\n    if (candidates.length === 0) {\n      return [['*', node]];\n    }\n\n    return candidates.map(c => {\n      if (!nodeMap.has(node)) {\n        nodeMap.set(node, node);\n      }\n\n      return [c, nodeMap.get(node)];\n    });\n  });\n}\n\nfunction buildPluginApi(tailwindConfig, context, {\n  variantList,\n  variantMap,\n  offsets\n}) {\n  function getConfigValue(path, defaultValue) {\n    return path ? dlv(tailwindConfig, path, defaultValue) : tailwindConfig;\n  }\n\n  function applyConfiguredPrefix(selector) {\n    return prefixSelector(tailwindConfig.prefix, selector);\n  }\n\n  function prefixIdentifier(identifier, options) {\n    if (identifier === '*') {\n      return '*';\n    }\n\n    if (!options.respectPrefix) {\n      return identifier;\n    }\n\n    if (typeof context.tailwindConfig.prefix === 'function') {\n      return prefixSelector(context.tailwindConfig.prefix, `.${identifier}`).substr(1);\n    }\n\n    return context.tailwindConfig.prefix + identifier;\n  }\n\n  return {\n    addVariant(variantName, applyThisVariant, options = {}) {\n      insertInto(variantList, variantName, options);\n      variantMap.set(variantName, applyThisVariant);\n    },\n\n    postcss,\n    prefix: applyConfiguredPrefix,\n    e: escapeClassName,\n    config: getConfigValue,\n\n    theme(path, defaultValue) {\n      const [pathRoot, ...subPaths] = toPath(path);\n      const value = getConfigValue(['theme', pathRoot, ...subPaths], defaultValue);\n      return transformThemeValue(pathRoot)(value);\n    },\n\n    corePlugins: path => {\n      if (Array.isArray(tailwindConfig.corePlugins)) {\n        return tailwindConfig.corePlugins.includes(path);\n      }\n\n      return getConfigValue(['corePlugins', path], true);\n    },\n    variants: (path, defaultValue) => {\n      if (Array.isArray(tailwindConfig.variants)) {\n        return tailwindConfig.variants;\n      }\n\n      return getConfigValue(['variants', path], defaultValue);\n    },\n\n    addBase(base) {\n      for (let [identifier, rule] of withIdentifiers(base)) {\n        let prefixedIdentifier = prefixIdentifier(identifier, {});\n        let offset = offsets.base++;\n\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n\n        context.candidateRuleMap.get(prefixedIdentifier).push([{\n          sort: offset,\n          layer: 'base'\n        }, rule]);\n      }\n    },\n\n    addComponents(components, options) {\n      let defaultOptions = {\n        variants: [],\n        respectPrefix: true,\n        respectImportant: false,\n        respectVariants: true\n      };\n      options = Object.assign({}, defaultOptions, Array.isArray(options) ? {\n        variants: options\n      } : options);\n\n      for (let [identifier, rule] of withIdentifiers(components)) {\n        let prefixedIdentifier = prefixIdentifier(identifier, options);\n        let offset = offsets.components++;\n\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n\n        context.candidateRuleMap.get(prefixedIdentifier).push([{\n          sort: offset,\n          layer: 'components',\n          options\n        }, rule]);\n      }\n    },\n\n    addUtilities(utilities, options) {\n      let defaultOptions = {\n        variants: [],\n        respectPrefix: true,\n        respectImportant: true,\n        respectVariants: true\n      };\n      options = Object.assign({}, defaultOptions, Array.isArray(options) ? {\n        variants: options\n      } : options);\n\n      for (let [identifier, rule] of withIdentifiers(utilities)) {\n        let prefixedIdentifier = prefixIdentifier(identifier, options);\n        let offset = offsets.utilities++;\n\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n\n        context.candidateRuleMap.get(prefixedIdentifier).push([{\n          sort: offset,\n          layer: 'utilities',\n          options\n        }, rule]);\n      }\n    },\n\n    matchBase: function (base) {\n      let offset = offsets.base++;\n\n      for (let identifier in base) {\n        let prefixedIdentifier = prefixIdentifier(identifier, options);\n        let value = [].concat(base[identifier]);\n        let withOffsets = value.map(rule => [{\n          sort: offset,\n          layer: 'base'\n        }, rule]);\n\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n\n        context.candidateRuleMap.get(prefixedIdentifier).push(...withOffsets);\n      }\n    },\n    matchUtilities: function (utilities, options) {\n      let defaultOptions = {\n        variants: [],\n        respectPrefix: true,\n        respectImportant: true,\n        respectVariants: true\n      };\n      options = { ...defaultOptions,\n        ...options\n      };\n      let offset = offsets.utilities++;\n\n      for (let identifier in utilities) {\n        let prefixedIdentifier = prefixIdentifier(identifier, options);\n        let value = [].concat(utilities[identifier]);\n        let withOffsets = value.map(rule => [{\n          sort: offset,\n          layer: 'utilities',\n          options\n        }, rule]);\n\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n\n        context.candidateRuleMap.get(prefixedIdentifier).push(...withOffsets);\n      }\n    },\n    // ---\n    jit: {\n      e: escapeClassName,\n      config: tailwindConfig,\n      theme: tailwindConfig.theme,\n\n      addVariant(variantName, applyVariant, options = {}) {\n        insertInto(variantList, variantName, options);\n        variantMap.set(variantName, applyVariant);\n      }\n\n    }\n  };\n}\n\nfunction extractVariantAtRules(node) {\n  node.walkAtRules(atRule => {\n    if (['responsive', 'variants'].includes(atRule.name)) {\n      extractVariantAtRules(atRule);\n      atRule.before(atRule.nodes);\n      atRule.remove();\n    }\n  });\n}\n\nfunction collectLayerPlugins(root) {\n  let layerPlugins = [];\n  root.each(node => {\n    if (node.type === 'atrule' && ['responsive', 'variants'].includes(node.name)) {\n      node.name = 'layer';\n      node.params = 'utilities';\n    }\n  }); // Walk @layer rules and treat them like plugins\n\n  root.walkAtRules('layer', layerNode => {\n    extractVariantAtRules(layerNode);\n\n    if (layerNode.params === 'base') {\n      for (let node of layerNode.nodes) {\n        layerPlugins.push(function ({\n          addBase\n        }) {\n          addBase(node, {\n            respectPrefix: false\n          });\n        });\n      }\n    } else if (layerNode.params === 'components') {\n      for (let node of layerNode.nodes) {\n        layerPlugins.push(function ({\n          addComponents\n        }) {\n          addComponents(node, {\n            respectPrefix: false\n          });\n        });\n      }\n    } else if (layerNode.params === 'utilities') {\n      for (let node of layerNode.nodes) {\n        layerPlugins.push(function ({\n          addUtilities\n        }) {\n          addUtilities(node, {\n            respectPrefix: false\n          });\n        });\n      }\n    }\n  });\n  return layerPlugins;\n}\n\nfunction registerPlugins(tailwindConfig, plugins, context) {\n  let variantList = [];\n  let variantMap = new Map();\n  let offsets = {\n    base: 0n,\n    components: 0n,\n    utilities: 0n\n  };\n  let pluginApi = buildPluginApi(tailwindConfig, context, {\n    variantList,\n    variantMap,\n    offsets\n  });\n\n  for (let plugin of plugins) {\n    if (Array.isArray(plugin)) {\n      for (let pluginItem of plugin) {\n        pluginItem(pluginApi);\n      }\n    } else {\n      plugin(pluginApi);\n    }\n  }\n\n  let highestOffset = (args => args.reduce((m, e) => e > m ? e : m))([offsets.base, offsets.components, offsets.utilities]);\n\n  let reservedBits = BigInt(highestOffset.toString(2).length);\n  context.layerOrder = {\n    base: 1n << reservedBits << 0n,\n    components: 1n << reservedBits << 1n,\n    utilities: 1n << reservedBits << 2n\n  };\n  reservedBits += 3n;\n  context.variantOrder = variantList.reduce((map, variant, i) => map.set(variant, 1n << BigInt(i) << reservedBits), new Map());\n  context.minimumScreen = [...context.variantOrder.values()].shift(); // Build variantMap\n\n  for (let [variantName, variantFunction] of variantMap.entries()) {\n    let sort = context.variantOrder.get(variantName);\n    context.variantMap.set(variantName, [sort, variantFunction]);\n  }\n}\n\nfunction cleanupContext(context) {\n  if (context.watcher) {\n    context.watcher.close();\n  }\n} // Retrieve an existing context from cache if possible (since contexts are unique per\n// source path), or set up a new one (including setting up watchers and registering\n// plugins) then return it\n\n\nfunction setupContext(configOrPath) {\n  return (result, root) => {\n    let foundTailwind = false;\n    root.walkAtRules('tailwind', () => {\n      foundTailwind = true;\n    });\n    let sourcePath = result.opts.from;\n    let [tailwindConfig, userConfigPath, tailwindConfigHash, configDependencies] = getTailwindConfig(configOrPath);\n    let isConfigFile = userConfigPath !== null;\n    let contextDependencies = new Set(sharedState.env.TAILWIND_DISABLE_TOUCH ? configDependencies : []); // If there are no @tailwind rules, we don't consider this CSS file or it's dependencies\n    // to be dependencies of the context. Can reuse the context even if they change.\n    // We may want to think about `@layer` being part of this trigger too, but it's tough\n    // because it's impossible for a layer in one file to end up in the actual @tailwind rule\n    // in another file since independent sources are effectively isolated.\n\n    if (foundTailwind) {\n      contextDependencies.add(sourcePath);\n\n      for (let message of result.messages) {\n        if (message.type === 'dependency') {\n          contextDependencies.add(message.file);\n        }\n      }\n    }\n\n    if (sharedState.env.TAILWIND_DISABLE_TOUCH) {\n      for (let file of configDependencies) {\n        result.messages.push({\n          type: 'dependency',\n          plugin: 'tailwindcss-jit',\n          parent: result.opts.from,\n          file\n        });\n      }\n    } else {\n      if (isConfigFile) {\n        contextDependencies.add(userConfigPath);\n      }\n    }\n\n    let contextDependenciesChanged = trackModified([...contextDependencies]);\n    process.env.DEBUG && console.log('Source path:', sourcePath);\n\n    if (!contextDependenciesChanged) {\n      // If this file already has a context in the cache and we don't need to\n      // reset the context, return the cached context.\n      if (isConfigFile && contextMap.has(sourcePath)) {\n        return contextMap.get(sourcePath);\n      } // If the config used already exists in the cache, return that.\n\n\n      if (configContextMap.has(tailwindConfigHash)) {\n        let context = configContextMap.get(tailwindConfigHash);\n        contextSourcesMap.get(context).add(sourcePath);\n        contextMap.set(sourcePath, context);\n        return context;\n      }\n    } // If this source is in the context map, get the old context.\n    // Remove this source from the context sources for the old context,\n    // and clean up that context if no one else is using it. This can be\n    // called by many processes in rapid succession, so we check for presence\n    // first because the first process to run this code will wipe it out first.\n\n\n    if (contextMap.has(sourcePath)) {\n      let oldContext = contextMap.get(sourcePath);\n\n      if (contextSourcesMap.has(oldContext)) {\n        contextSourcesMap.get(oldContext).delete(sourcePath);\n\n        if (contextSourcesMap.get(oldContext).size === 0) {\n          contextSourcesMap.delete(oldContext);\n          cleanupContext(oldContext);\n        }\n      }\n    }\n\n    process.env.DEBUG && console.log('Setting up new context...');\n    let context = {\n      changedFiles: new Set(),\n      ruleCache: new Set(),\n      watcher: null,\n      scannedContent: false,\n      touchFile: null,\n      classCache: new Map(),\n      applyClassCache: new Map(),\n      notClassCache: new Set(),\n      postCssNodeCache: new Map(),\n      candidateRuleMap: new Map(),\n      configPath: userConfigPath,\n      tailwindConfig: tailwindConfig,\n      configDependencies: new Set(),\n      candidateFiles: (Array.isArray(tailwindConfig.purge) ? tailwindConfig.purge : tailwindConfig.purge.content).map(path => normalizePath(path)),\n      variantMap: new Map(),\n      stylesheetCache: null,\n      fileModifiedMap: new Map()\n    }; // ---\n    // Update all context tracking state\n\n    configContextMap.set(tailwindConfigHash, context);\n    contextMap.set(sourcePath, context);\n\n    if (!contextSourcesMap.has(context)) {\n      contextSourcesMap.set(context, new Set());\n    }\n\n    contextSourcesMap.get(context).add(sourcePath); // ---\n\n    if (isConfigFile && !sharedState.env.TAILWIND_DISABLE_TOUCH) {\n      for (let dependency of getModuleDependencies(userConfigPath)) {\n        if (dependency.file === userConfigPath) {\n          continue;\n        }\n\n        context.configDependencies.add(dependency.file);\n      }\n    }\n\n    rebootWatcher(context);\n    let corePluginList = Object.entries(corePlugins).map(([name, plugin]) => {\n      if (!tailwindConfig.corePlugins.includes(name)) {\n        return null;\n      }\n\n      return plugin;\n    }).filter(Boolean);\n    let userPlugins = tailwindConfig.plugins.map(plugin => {\n      if (plugin.__isOptionsFunction) {\n        plugin = plugin();\n      }\n\n      return typeof plugin === 'function' ? plugin : plugin.handler;\n    });\n    let layerPlugins = collectLayerPlugins(root); // TODO: This is a workaround for backwards compatibility, since custom variants\n    // were historically sorted before screen/stackable variants.\n\n    let beforeVariants = [corePlugins['pseudoClassVariants']];\n    let afterVariants = [corePlugins['directionVariants'], corePlugins['reducedMotionVariants'], corePlugins['darkVariants'], corePlugins['screenVariants']];\n    registerPlugins(context.tailwindConfig, [...corePluginList, ...beforeVariants, ...userPlugins, ...afterVariants, ...layerPlugins], context);\n    return context;\n  };\n}\n\nmodule.exports = setupContext;","map":{"version":3,"sources":["/Users/seito/Documents/develop/count-jp/my-app/node_modules/tailwindcss/jit/lib/setupContext.js"],"names":["fs","require","url","os","path","crypto","chokidar","postcss","hash","dlv","selectorParser","LRU","normalizePath","transformThemeValue","default","parseObjectStyles","getModuleDependencies","prefixSelector","resolveConfig","sharedState","corePlugins","isPlainObject","escapeClassName","contextMap","configContextMap","contextSourcesMap","env","touchDir","TAILWIND_TOUCH_DIR","join","homedir","tmpdir","TAILWIND_DISABLE_TOUCH","existsSync","file","readdirSync","unlinkSync","_err","mkdirSync","recursive","touch","filename","time","Date","utimesSync","err","closeSync","openSync","isObject","value","isEmpty","obj","Object","keys","length","isString","String","toPath","Array","isArray","inBrackets","parts","chunk","i","char","push","resolveConfigPath","pathOrConfig","config","undefined","resolve","configFile","configPath","accessSync","configPathCache","maxSize","getTailwindConfig","configOrPath","userConfigPath","prevConfig","prevConfigHash","prevDeps","prevModified","get","newDeps","map","dep","modified","newModified","Map","statSync","mtimeMs","set","has","cache","newConfig","newHash","Infinity","fileModifiedMap","trackModified","files","changed","pathname","parse","decodeURIComponent","generateTouchFileName","chars","randomChars","randomCharsLength","bytes","randomBytes","_error","pseudoRandomBytes","process","pid","rebootWatcher","context","touchFile","TAILWIND_MODE","NODE_ENV","Promise","watcher","close","then","watch","candidateFiles","configDependencies","ignoreInitial","on","changedFiles","add","dependency","insertInto","list","before","concat","idx","other","iidx","indexOf","Math","min","splice","parseStyles","styles","flatMap","style","isNode","getClasses","selector","parser","selectors","allClasses","walkClasses","classNode","transformSync","extractCandidates","node","classes","type","walkRules","rule","withIdentifiers","nodeMap","candidates","c","buildPluginApi","tailwindConfig","variantList","variantMap","offsets","getConfigValue","defaultValue","applyConfiguredPrefix","prefix","prefixIdentifier","identifier","options","respectPrefix","substr","addVariant","variantName","applyThisVariant","e","theme","pathRoot","subPaths","includes","variants","addBase","base","prefixedIdentifier","offset","candidateRuleMap","sort","layer","addComponents","components","defaultOptions","respectImportant","respectVariants","assign","addUtilities","utilities","matchBase","withOffsets","matchUtilities","jit","applyVariant","extractVariantAtRules","walkAtRules","atRule","name","nodes","remove","collectLayerPlugins","root","layerPlugins","each","params","layerNode","registerPlugins","plugins","pluginApi","plugin","pluginItem","highestOffset","args","reduce","m","reservedBits","BigInt","toString","layerOrder","variantOrder","variant","minimumScreen","values","shift","variantFunction","entries","cleanupContext","setupContext","result","foundTailwind","sourcePath","opts","from","tailwindConfigHash","isConfigFile","contextDependencies","Set","message","messages","parent","contextDependenciesChanged","DEBUG","console","log","oldContext","delete","size","ruleCache","scannedContent","classCache","applyClassCache","notClassCache","postCssNodeCache","purge","content","stylesheetCache","corePluginList","filter","Boolean","userPlugins","__isOptionsFunction","handler","beforeVariants","afterVariants","module","exports"],"mappings":"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","sourcesContent":["const fs = require('fs')\nconst url = require('url')\nconst os = require('os')\nconst path = require('path')\nconst crypto = require('crypto')\nconst chokidar = require('chokidar')\nconst postcss = require('postcss')\nconst hash = require('object-hash')\nconst dlv = require('dlv')\nconst selectorParser = require('postcss-selector-parser')\nconst LRU = require('quick-lru')\nconst normalizePath = require('normalize-path')\n\nconst transformThemeValue = require('../../lib/util/transformThemeValue').default\nconst parseObjectStyles = require('../../lib/util/parseObjectStyles').default\nconst getModuleDependencies = require('../../lib/lib/getModuleDependencies').default\nconst prefixSelector = require('../../lib/util/prefixSelector').default\n\nconst resolveConfig = require('../../resolveConfig')\n\nconst sharedState = require('./sharedState')\nconst corePlugins = require('../corePlugins')\nconst { isPlainObject, escapeClassName } = require('./utils')\n\nlet contextMap = sharedState.contextMap\nlet configContextMap = sharedState.configContextMap\nlet contextSourcesMap = sharedState.contextSourcesMap\nlet env = sharedState.env\n\n// Earmarks a directory for our touch files.\n// If the directory already exists we delete any existing touch files,\n// invalidating any caches associated with them.\nconst touchDir =\n  env.TAILWIND_TOUCH_DIR || path.join(os.homedir() || os.tmpdir(), '.tailwindcss', 'touch')\n\nif (!sharedState.env.TAILWIND_DISABLE_TOUCH) {\n  if (fs.existsSync(touchDir)) {\n    for (let file of fs.readdirSync(touchDir)) {\n      try {\n        fs.unlinkSync(path.join(touchDir, file))\n      } catch (_err) {}\n    }\n  } else {\n    fs.mkdirSync(touchDir, { recursive: true })\n  }\n}\n\n// This is used to trigger rebuilds. Just updating the timestamp\n// is significantly faster than actually writing to the file (10x).\n\nfunction touch(filename) {\n  let time = new Date()\n\n  try {\n    fs.utimesSync(filename, time, time)\n  } catch (err) {\n    fs.closeSync(fs.openSync(filename, 'w'))\n  }\n}\n\nfunction isObject(value) {\n  return typeof value === 'object' && value !== null\n}\n\nfunction isEmpty(obj) {\n  return Object.keys(obj).length === 0\n}\n\nfunction isString(value) {\n  return typeof value === 'string' || value instanceof String\n}\n\nfunction toPath(value) {\n  if (Array.isArray(value)) {\n    return value\n  }\n\n  let inBrackets = false\n  let parts = []\n  let chunk = ''\n\n  for (let i = 0; i < value.length; i++) {\n    let char = value[i]\n    if (char === '[') {\n      inBrackets = true\n      parts.push(chunk)\n      chunk = ''\n      continue\n    }\n    if (char === ']' && inBrackets) {\n      inBrackets = false\n      parts.push(chunk)\n      chunk = ''\n      continue\n    }\n    if (char === '.' && !inBrackets && chunk.length > 0) {\n      parts.push(chunk)\n      chunk = ''\n      continue\n    }\n    chunk = chunk + char\n  }\n\n  if (chunk.length > 0) {\n    parts.push(chunk)\n  }\n\n  return parts\n}\n\nfunction resolveConfigPath(pathOrConfig) {\n  // require('tailwindcss')({ theme: ..., variants: ... })\n  if (isObject(pathOrConfig) && pathOrConfig.config === undefined && !isEmpty(pathOrConfig)) {\n    return null\n  }\n\n  // require('tailwindcss')({ config: 'custom-config.js' })\n  if (\n    isObject(pathOrConfig) &&\n    pathOrConfig.config !== undefined &&\n    isString(pathOrConfig.config)\n  ) {\n    return path.resolve(pathOrConfig.config)\n  }\n\n  // require('tailwindcss')({ config: { theme: ..., variants: ... } })\n  if (\n    isObject(pathOrConfig) &&\n    pathOrConfig.config !== undefined &&\n    isObject(pathOrConfig.config)\n  ) {\n    return null\n  }\n\n  // require('tailwindcss')('custom-config.js')\n  if (isString(pathOrConfig)) {\n    return path.resolve(pathOrConfig)\n  }\n\n  // require('tailwindcss')\n  for (const configFile of ['./tailwind.config.js', './tailwind.config.cjs']) {\n    try {\n      const configPath = path.resolve(configFile)\n      fs.accessSync(configPath)\n      return configPath\n    } catch (err) {}\n  }\n\n  return null\n}\n\nlet configPathCache = new LRU({ maxSize: 100 })\n\n// Get the config object based on a path\nfunction getTailwindConfig(configOrPath) {\n  let userConfigPath = resolveConfigPath(configOrPath)\n\n  if (sharedState.env.TAILWIND_DISABLE_TOUCH) {\n    if (userConfigPath !== null) {\n      let [prevConfig, prevConfigHash, prevDeps, prevModified] =\n        configPathCache.get(userConfigPath) || []\n\n      let newDeps = getModuleDependencies(userConfigPath).map((dep) => dep.file)\n\n      let modified = false\n      let newModified = new Map()\n      for (let file of newDeps) {\n        let time = fs.statSync(file).mtimeMs\n        newModified.set(file, time)\n        if (!prevModified || !prevModified.has(file) || time > prevModified.get(file)) {\n          modified = true\n        }\n      }\n\n      // It hasn't changed (based on timestamps)\n      if (!modified) {\n        return [prevConfig, userConfigPath, prevConfigHash, prevDeps]\n      }\n\n      // It has changed (based on timestamps), or first run\n      for (let file of newDeps) {\n        delete require.cache[file]\n      }\n      let newConfig = resolveConfig(require(userConfigPath))\n      let newHash = hash(newConfig)\n      configPathCache.set(userConfigPath, [newConfig, newHash, newDeps, newModified])\n      return [newConfig, userConfigPath, newHash, newDeps]\n    }\n\n    // It's a plain object, not a path\n    let newConfig = resolveConfig(\n      configOrPath.config === undefined ? configOrPath : configOrPath.config\n    )\n\n    return [newConfig, null, hash(newConfig), []]\n  }\n\n  if (userConfigPath !== null) {\n    let [prevConfig, prevModified = -Infinity, prevConfigHash] =\n      configPathCache.get(userConfigPath) || []\n    let modified = fs.statSync(userConfigPath).mtimeMs\n\n    // It hasn't changed (based on timestamp)\n    if (modified <= prevModified) {\n      return [prevConfig, userConfigPath, prevConfigHash]\n    }\n\n    // It has changed (based on timestamp), or first run\n    delete require.cache[userConfigPath]\n    let newConfig = resolveConfig(require(userConfigPath))\n    let newHash = hash(newConfig)\n    configPathCache.set(userConfigPath, [newConfig, modified, newHash])\n    return [newConfig, userConfigPath, newHash]\n  }\n\n  // It's a plain object, not a path\n  let newConfig = resolveConfig(\n    configOrPath.config === undefined ? configOrPath : configOrPath.config\n  )\n\n  return [newConfig, null, hash(newConfig)]\n}\n\nlet fileModifiedMap = new Map()\n\nfunction trackModified(files) {\n  let changed = false\n\n  for (let file of files) {\n    if (!file) continue\n\n    let pathname = url.parse(file).pathname\n    let newModified = fs.statSync(decodeURIComponent(pathname)).mtimeMs\n\n    if (!fileModifiedMap.has(file) || newModified > fileModifiedMap.get(file)) {\n      changed = true\n    }\n\n    fileModifiedMap.set(file, newModified)\n  }\n\n  return changed\n}\n\nfunction generateTouchFileName() {\n  let chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\n  let randomChars = ''\n  let randomCharsLength = 12\n  let bytes = null\n\n  try {\n    bytes = crypto.randomBytes(randomCharsLength)\n  } catch (_error) {\n    bytes = crypto.pseudoRandomBytes(randomCharsLength)\n  }\n\n  for (let i = 0; i < randomCharsLength; i++) {\n    randomChars += chars[bytes[i] % chars.length]\n  }\n\n  return path.join(touchDir, `touch-${process.pid}-${randomChars}`)\n}\n\nfunction rebootWatcher(context) {\n  if (env.TAILWIND_DISABLE_TOUCH) {\n    return\n  }\n\n  if (context.touchFile === null) {\n    context.touchFile = generateTouchFileName()\n    touch(context.touchFile)\n  }\n\n  if (env.TAILWIND_MODE === 'build') {\n    return\n  }\n\n  if (\n    env.TAILWIND_MODE === 'watch' ||\n    (env.TAILWIND_MODE === undefined && env.NODE_ENV === 'development')\n  ) {\n    Promise.resolve(context.watcher ? context.watcher.close() : null).then(() => {\n      context.watcher = chokidar.watch([...context.candidateFiles, ...context.configDependencies], {\n        ignoreInitial: true,\n      })\n\n      context.watcher.on('add', (file) => {\n        context.changedFiles.add(path.resolve('.', file))\n        touch(context.touchFile)\n      })\n\n      context.watcher.on('change', (file) => {\n        // If it was a config dependency, touch the config file to trigger a new context.\n        // This is not really that clean of a solution but it's the fastest, because we\n        // can do a very quick check on each build to see if the config has changed instead\n        // of having to get all of the module dependencies and check every timestamp each\n        // time.\n        if (context.configDependencies.has(file)) {\n          for (let dependency of context.configDependencies) {\n            delete require.cache[require.resolve(dependency)]\n          }\n          touch(context.configPath)\n        } else {\n          context.changedFiles.add(path.resolve('.', file))\n          touch(context.touchFile)\n        }\n      })\n\n      context.watcher.on('unlink', (file) => {\n        // Touch the config file if any of the dependencies are deleted.\n        if (context.configDependencies.has(file)) {\n          for (let dependency of context.configDependencies) {\n            delete require.cache[require.resolve(dependency)]\n          }\n          touch(context.configPath)\n        }\n      })\n    })\n  }\n}\n\nfunction insertInto(list, value, { before = [] } = {}) {\n  before = [].concat(before)\n\n  if (before.length <= 0) {\n    list.push(value)\n    return\n  }\n\n  let idx = list.length - 1\n  for (let other of before) {\n    let iidx = list.indexOf(other)\n    if (iidx === -1) continue\n    idx = Math.min(idx, iidx)\n  }\n\n  list.splice(idx, 0, value)\n}\n\nfunction parseStyles(styles) {\n  if (!Array.isArray(styles)) {\n    return parseStyles([styles])\n  }\n\n  return styles.flatMap((style) => {\n    let isNode = !Array.isArray(style) && !isPlainObject(style)\n    return isNode ? style : parseObjectStyles(style)\n  })\n}\n\nfunction getClasses(selector) {\n  let parser = selectorParser((selectors) => {\n    let allClasses = []\n    selectors.walkClasses((classNode) => {\n      allClasses.push(classNode.value)\n    })\n    return allClasses\n  })\n  return parser.transformSync(selector)\n}\n\nfunction extractCandidates(node) {\n  let classes = node.type === 'rule' ? getClasses(node.selector) : []\n\n  if (node.type === 'atrule') {\n    node.walkRules((rule) => {\n      classes = [...classes, ...getClasses(rule.selector)]\n    })\n  }\n\n  return classes\n}\n\nfunction withIdentifiers(styles) {\n  return parseStyles(styles).flatMap((node) => {\n    let nodeMap = new Map()\n    let candidates = extractCandidates(node)\n\n    // If this isn't \"on-demandable\", assign it a universal candidate.\n    if (candidates.length === 0) {\n      return [['*', node]]\n    }\n\n    return candidates.map((c) => {\n      if (!nodeMap.has(node)) {\n        nodeMap.set(node, node)\n      }\n      return [c, nodeMap.get(node)]\n    })\n  })\n}\n\nfunction buildPluginApi(tailwindConfig, context, { variantList, variantMap, offsets }) {\n  function getConfigValue(path, defaultValue) {\n    return path ? dlv(tailwindConfig, path, defaultValue) : tailwindConfig\n  }\n\n  function applyConfiguredPrefix(selector) {\n    return prefixSelector(tailwindConfig.prefix, selector)\n  }\n\n  function prefixIdentifier(identifier, options) {\n    if (identifier === '*') {\n      return '*'\n    }\n\n    if (!options.respectPrefix) {\n      return identifier\n    }\n\n    if (typeof context.tailwindConfig.prefix === 'function') {\n      return prefixSelector(context.tailwindConfig.prefix, `.${identifier}`).substr(1)\n    }\n\n    return context.tailwindConfig.prefix + identifier\n  }\n\n  return {\n    addVariant(variantName, applyThisVariant, options = {}) {\n      insertInto(variantList, variantName, options)\n      variantMap.set(variantName, applyThisVariant)\n    },\n    postcss,\n    prefix: applyConfiguredPrefix,\n    e: escapeClassName,\n    config: getConfigValue,\n    theme(path, defaultValue) {\n      const [pathRoot, ...subPaths] = toPath(path)\n      const value = getConfigValue(['theme', pathRoot, ...subPaths], defaultValue)\n      return transformThemeValue(pathRoot)(value)\n    },\n    corePlugins: (path) => {\n      if (Array.isArray(tailwindConfig.corePlugins)) {\n        return tailwindConfig.corePlugins.includes(path)\n      }\n\n      return getConfigValue(['corePlugins', path], true)\n    },\n    variants: (path, defaultValue) => {\n      if (Array.isArray(tailwindConfig.variants)) {\n        return tailwindConfig.variants\n      }\n\n      return getConfigValue(['variants', path], defaultValue)\n    },\n    addBase(base) {\n      for (let [identifier, rule] of withIdentifiers(base)) {\n        let prefixedIdentifier = prefixIdentifier(identifier, {})\n        let offset = offsets.base++\n\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, [])\n        }\n\n        context.candidateRuleMap\n          .get(prefixedIdentifier)\n          .push([{ sort: offset, layer: 'base' }, rule])\n      }\n    },\n    addComponents(components, options) {\n      let defaultOptions = {\n        variants: [],\n        respectPrefix: true,\n        respectImportant: false,\n        respectVariants: true,\n      }\n\n      options = Object.assign(\n        {},\n        defaultOptions,\n        Array.isArray(options) ? { variants: options } : options\n      )\n\n      for (let [identifier, rule] of withIdentifiers(components)) {\n        let prefixedIdentifier = prefixIdentifier(identifier, options)\n        let offset = offsets.components++\n\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, [])\n        }\n\n        context.candidateRuleMap\n          .get(prefixedIdentifier)\n          .push([{ sort: offset, layer: 'components', options }, rule])\n      }\n    },\n    addUtilities(utilities, options) {\n      let defaultOptions = {\n        variants: [],\n        respectPrefix: true,\n        respectImportant: true,\n        respectVariants: true,\n      }\n\n      options = Object.assign(\n        {},\n        defaultOptions,\n        Array.isArray(options) ? { variants: options } : options\n      )\n\n      for (let [identifier, rule] of withIdentifiers(utilities)) {\n        let prefixedIdentifier = prefixIdentifier(identifier, options)\n        let offset = offsets.utilities++\n\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, [])\n        }\n\n        context.candidateRuleMap\n          .get(prefixedIdentifier)\n          .push([{ sort: offset, layer: 'utilities', options }, rule])\n      }\n    },\n    matchBase: function (base) {\n      let offset = offsets.base++\n\n      for (let identifier in base) {\n        let prefixedIdentifier = prefixIdentifier(identifier, options)\n        let value = [].concat(base[identifier])\n\n        let withOffsets = value.map((rule) => [{ sort: offset, layer: 'base' }, rule])\n\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, [])\n        }\n\n        context.candidateRuleMap.get(prefixedIdentifier).push(...withOffsets)\n      }\n    },\n    matchUtilities: function (utilities, options) {\n      let defaultOptions = {\n        variants: [],\n        respectPrefix: true,\n        respectImportant: true,\n        respectVariants: true,\n      }\n\n      options = { ...defaultOptions, ...options }\n\n      let offset = offsets.utilities++\n\n      for (let identifier in utilities) {\n        let prefixedIdentifier = prefixIdentifier(identifier, options)\n        let value = [].concat(utilities[identifier])\n\n        let withOffsets = value.map((rule) => [{ sort: offset, layer: 'utilities', options }, rule])\n\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, [])\n        }\n\n        context.candidateRuleMap.get(prefixedIdentifier).push(...withOffsets)\n      }\n    },\n    // ---\n    jit: {\n      e: escapeClassName,\n      config: tailwindConfig,\n      theme: tailwindConfig.theme,\n      addVariant(variantName, applyVariant, options = {}) {\n        insertInto(variantList, variantName, options)\n        variantMap.set(variantName, applyVariant)\n      },\n    },\n  }\n}\n\nfunction extractVariantAtRules(node) {\n  node.walkAtRules((atRule) => {\n    if (['responsive', 'variants'].includes(atRule.name)) {\n      extractVariantAtRules(atRule)\n      atRule.before(atRule.nodes)\n      atRule.remove()\n    }\n  })\n}\n\nfunction collectLayerPlugins(root) {\n  let layerPlugins = []\n\n  root.each((node) => {\n    if (node.type === 'atrule' && ['responsive', 'variants'].includes(node.name)) {\n      node.name = 'layer'\n      node.params = 'utilities'\n    }\n  })\n\n  // Walk @layer rules and treat them like plugins\n  root.walkAtRules('layer', (layerNode) => {\n    extractVariantAtRules(layerNode)\n\n    if (layerNode.params === 'base') {\n      for (let node of layerNode.nodes) {\n        layerPlugins.push(function ({ addBase }) {\n          addBase(node, { respectPrefix: false })\n        })\n      }\n    } else if (layerNode.params === 'components') {\n      for (let node of layerNode.nodes) {\n        layerPlugins.push(function ({ addComponents }) {\n          addComponents(node, { respectPrefix: false })\n        })\n      }\n    } else if (layerNode.params === 'utilities') {\n      for (let node of layerNode.nodes) {\n        layerPlugins.push(function ({ addUtilities }) {\n          addUtilities(node, { respectPrefix: false })\n        })\n      }\n    }\n  })\n\n  return layerPlugins\n}\n\nfunction registerPlugins(tailwindConfig, plugins, context) {\n  let variantList = []\n  let variantMap = new Map()\n  let offsets = {\n    base: 0n,\n    components: 0n,\n    utilities: 0n,\n  }\n\n  let pluginApi = buildPluginApi(tailwindConfig, context, {\n    variantList,\n    variantMap,\n    offsets,\n  })\n\n  for (let plugin of plugins) {\n    if (Array.isArray(plugin)) {\n      for (let pluginItem of plugin) {\n        pluginItem(pluginApi)\n      }\n    } else {\n      plugin(pluginApi)\n    }\n  }\n\n  let highestOffset = ((args) => args.reduce((m, e) => (e > m ? e : m)))([\n    offsets.base,\n    offsets.components,\n    offsets.utilities,\n  ])\n  let reservedBits = BigInt(highestOffset.toString(2).length)\n\n  context.layerOrder = {\n    base: (1n << reservedBits) << 0n,\n    components: (1n << reservedBits) << 1n,\n    utilities: (1n << reservedBits) << 2n,\n  }\n\n  reservedBits += 3n\n  context.variantOrder = variantList.reduce(\n    (map, variant, i) => map.set(variant, (1n << BigInt(i)) << reservedBits),\n    new Map()\n  )\n\n  context.minimumScreen = [...context.variantOrder.values()].shift()\n\n  // Build variantMap\n  for (let [variantName, variantFunction] of variantMap.entries()) {\n    let sort = context.variantOrder.get(variantName)\n    context.variantMap.set(variantName, [sort, variantFunction])\n  }\n}\n\nfunction cleanupContext(context) {\n  if (context.watcher) {\n    context.watcher.close()\n  }\n}\n\n// Retrieve an existing context from cache if possible (since contexts are unique per\n// source path), or set up a new one (including setting up watchers and registering\n// plugins) then return it\nfunction setupContext(configOrPath) {\n  return (result, root) => {\n    let foundTailwind = false\n\n    root.walkAtRules('tailwind', () => {\n      foundTailwind = true\n    })\n\n    let sourcePath = result.opts.from\n    let [\n      tailwindConfig,\n      userConfigPath,\n      tailwindConfigHash,\n      configDependencies,\n    ] = getTailwindConfig(configOrPath)\n    let isConfigFile = userConfigPath !== null\n\n    let contextDependencies = new Set(\n      sharedState.env.TAILWIND_DISABLE_TOUCH ? configDependencies : []\n    )\n\n    // If there are no @tailwind rules, we don't consider this CSS file or it's dependencies\n    // to be dependencies of the context. Can reuse the context even if they change.\n    // We may want to think about `@layer` being part of this trigger too, but it's tough\n    // because it's impossible for a layer in one file to end up in the actual @tailwind rule\n    // in another file since independent sources are effectively isolated.\n    if (foundTailwind) {\n      contextDependencies.add(sourcePath)\n      for (let message of result.messages) {\n        if (message.type === 'dependency') {\n          contextDependencies.add(message.file)\n        }\n      }\n    }\n\n    if (sharedState.env.TAILWIND_DISABLE_TOUCH) {\n      for (let file of configDependencies) {\n        result.messages.push({\n          type: 'dependency',\n          plugin: 'tailwindcss-jit',\n          parent: result.opts.from,\n          file,\n        })\n      }\n    } else {\n      if (isConfigFile) {\n        contextDependencies.add(userConfigPath)\n      }\n    }\n\n    let contextDependenciesChanged = trackModified([...contextDependencies])\n\n    process.env.DEBUG && console.log('Source path:', sourcePath)\n\n    if (!contextDependenciesChanged) {\n      // If this file already has a context in the cache and we don't need to\n      // reset the context, return the cached context.\n      if (isConfigFile && contextMap.has(sourcePath)) {\n        return contextMap.get(sourcePath)\n      }\n\n      // If the config used already exists in the cache, return that.\n      if (configContextMap.has(tailwindConfigHash)) {\n        let context = configContextMap.get(tailwindConfigHash)\n        contextSourcesMap.get(context).add(sourcePath)\n        contextMap.set(sourcePath, context)\n        return context\n      }\n    }\n\n    // If this source is in the context map, get the old context.\n    // Remove this source from the context sources for the old context,\n    // and clean up that context if no one else is using it. This can be\n    // called by many processes in rapid succession, so we check for presence\n    // first because the first process to run this code will wipe it out first.\n    if (contextMap.has(sourcePath)) {\n      let oldContext = contextMap.get(sourcePath)\n      if (contextSourcesMap.has(oldContext)) {\n        contextSourcesMap.get(oldContext).delete(sourcePath)\n        if (contextSourcesMap.get(oldContext).size === 0) {\n          contextSourcesMap.delete(oldContext)\n          cleanupContext(oldContext)\n        }\n      }\n    }\n\n    process.env.DEBUG && console.log('Setting up new context...')\n\n    let context = {\n      changedFiles: new Set(),\n      ruleCache: new Set(),\n      watcher: null,\n      scannedContent: false,\n      touchFile: null,\n      classCache: new Map(),\n      applyClassCache: new Map(),\n      notClassCache: new Set(),\n      postCssNodeCache: new Map(),\n      candidateRuleMap: new Map(),\n      configPath: userConfigPath,\n      tailwindConfig: tailwindConfig,\n      configDependencies: new Set(),\n      candidateFiles: (Array.isArray(tailwindConfig.purge)\n        ? tailwindConfig.purge\n        : tailwindConfig.purge.content\n      ).map((path) => normalizePath(path)),\n      variantMap: new Map(),\n      stylesheetCache: null,\n      fileModifiedMap: new Map(),\n    }\n\n    // ---\n\n    // Update all context tracking state\n\n    configContextMap.set(tailwindConfigHash, context)\n    contextMap.set(sourcePath, context)\n\n    if (!contextSourcesMap.has(context)) {\n      contextSourcesMap.set(context, new Set())\n    }\n\n    contextSourcesMap.get(context).add(sourcePath)\n\n    // ---\n\n    if (isConfigFile && !sharedState.env.TAILWIND_DISABLE_TOUCH) {\n      for (let dependency of getModuleDependencies(userConfigPath)) {\n        if (dependency.file === userConfigPath) {\n          continue\n        }\n\n        context.configDependencies.add(dependency.file)\n      }\n    }\n\n    rebootWatcher(context)\n\n    let corePluginList = Object.entries(corePlugins)\n      .map(([name, plugin]) => {\n        if (!tailwindConfig.corePlugins.includes(name)) {\n          return null\n        }\n\n        return plugin\n      })\n      .filter(Boolean)\n\n    let userPlugins = tailwindConfig.plugins.map((plugin) => {\n      if (plugin.__isOptionsFunction) {\n        plugin = plugin()\n      }\n\n      return typeof plugin === 'function' ? plugin : plugin.handler\n    })\n\n    let layerPlugins = collectLayerPlugins(root)\n\n    // TODO: This is a workaround for backwards compatibility, since custom variants\n    // were historically sorted before screen/stackable variants.\n    let beforeVariants = [corePlugins['pseudoClassVariants']]\n    let afterVariants = [\n      corePlugins['directionVariants'],\n      corePlugins['reducedMotionVariants'],\n      corePlugins['darkVariants'],\n      corePlugins['screenVariants'],\n    ]\n\n    registerPlugins(\n      context.tailwindConfig,\n      [...corePluginList, ...beforeVariants, ...userPlugins, ...afterVariants, ...layerPlugins],\n      context\n    )\n\n    return context\n  }\n}\n\nmodule.exports = setupContext\n"]},"metadata":{},"sourceType":"script"}