{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.default = tokenizer;\nvar SINGLE_QUOTE = 39;\nvar DOUBLE_QUOTE = 34;\nvar BACKSLASH = 92;\nvar SLASH = 47;\nvar NEWLINE = 10;\nvar SPACE = 32;\nvar FEED = 12;\nvar TAB = 9;\nvar CR = 13;\nvar OPEN_SQUARE = 91;\nvar CLOSE_SQUARE = 93;\nvar OPEN_PARENTHESES = 40;\nvar CLOSE_PARENTHESES = 41;\nvar OPEN_CURLY = 123;\nvar CLOSE_CURLY = 125;\nvar SEMICOLON = 59;\nvar ASTERISK = 42;\nvar COLON = 58;\nvar AT = 64;\nvar RE_AT_END = /[ \\n\\t\\r\\f\\{\\}\\(\\)'\"\\\\;/\\[\\]#]/g;\nvar RE_WORD_END = /[ \\n\\t\\r\\f\\(\\)\\{\\}:;@!'\"\\\\\\]\\[#]|\\/(?=\\*)/g;\nvar RE_BAD_BRACKET = /.[\\\\\\/\\(\"'\\n]/;\nvar RE_HEX_ESCAPE = /[a-f0-9]/i;\n\nfunction tokenizer(input) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var css = input.css.valueOf();\n  var ignore = options.ignoreErrors;\n  var code = void 0,\n      next = void 0,\n      quote = void 0,\n      lines = void 0,\n      last = void 0,\n      content = void 0,\n      escape = void 0,\n      nextLine = void 0,\n      nextOffset = void 0,\n      escaped = void 0,\n      escapePos = void 0,\n      prev = void 0,\n      n = void 0,\n      currentToken = void 0;\n  var length = css.length;\n  var offset = -1;\n  var line = 1;\n  var pos = 0;\n  var buffer = [];\n  var returned = [];\n\n  function unclosed(what) {\n    throw input.error('Unclosed ' + what, line, pos - offset);\n  }\n\n  function endOfFile() {\n    return returned.length === 0 && pos >= length;\n  }\n\n  function nextToken() {\n    if (returned.length) return returned.pop();\n    if (pos >= length) return;\n    code = css.charCodeAt(pos);\n\n    if (code === NEWLINE || code === FEED || code === CR && css.charCodeAt(pos + 1) !== NEWLINE) {\n      offset = pos;\n      line += 1;\n    }\n\n    switch (code) {\n      case NEWLINE:\n      case SPACE:\n      case TAB:\n      case CR:\n      case FEED:\n        next = pos;\n\n        do {\n          next += 1;\n          code = css.charCodeAt(next);\n\n          if (code === NEWLINE) {\n            offset = next;\n            line += 1;\n          }\n        } while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);\n\n        currentToken = ['space', css.slice(pos, next)];\n        pos = next - 1;\n        break;\n\n      case OPEN_SQUARE:\n        currentToken = ['[', '[', line, pos - offset];\n        break;\n\n      case CLOSE_SQUARE:\n        currentToken = [']', ']', line, pos - offset];\n        break;\n\n      case OPEN_CURLY:\n        currentToken = ['{', '{', line, pos - offset];\n        break;\n\n      case CLOSE_CURLY:\n        currentToken = ['}', '}', line, pos - offset];\n        break;\n\n      case COLON:\n        currentToken = [':', ':', line, pos - offset];\n        break;\n\n      case SEMICOLON:\n        currentToken = [';', ';', line, pos - offset];\n        break;\n\n      case OPEN_PARENTHESES:\n        prev = buffer.length ? buffer.pop()[1] : '';\n        n = css.charCodeAt(pos + 1);\n\n        if (prev === 'url' && n !== SINGLE_QUOTE && n !== DOUBLE_QUOTE && n !== SPACE && n !== NEWLINE && n !== TAB && n !== FEED && n !== CR) {\n          next = pos;\n\n          do {\n            escaped = false;\n            next = css.indexOf(')', next + 1);\n\n            if (next === -1) {\n              if (ignore) {\n                next = pos;\n                break;\n              } else {\n                unclosed('bracket');\n              }\n            }\n\n            escapePos = next;\n\n            while (css.charCodeAt(escapePos - 1) === BACKSLASH) {\n              escapePos -= 1;\n              escaped = !escaped;\n            }\n          } while (escaped);\n\n          currentToken = ['brackets', css.slice(pos, next + 1), line, pos - offset, line, next - offset];\n          pos = next;\n        } else {\n          next = css.indexOf(')', pos + 1);\n          content = css.slice(pos, next + 1);\n\n          if (next === -1 || RE_BAD_BRACKET.test(content)) {\n            currentToken = ['(', '(', line, pos - offset];\n          } else {\n            currentToken = ['brackets', content, line, pos - offset, line, next - offset];\n            pos = next;\n          }\n        }\n\n        break;\n\n      case CLOSE_PARENTHESES:\n        currentToken = [')', ')', line, pos - offset];\n        break;\n\n      case SINGLE_QUOTE:\n      case DOUBLE_QUOTE:\n        quote = code === SINGLE_QUOTE ? '\\'' : '\"';\n        next = pos;\n\n        do {\n          escaped = false;\n          next = css.indexOf(quote, next + 1);\n\n          if (next === -1) {\n            if (ignore) {\n              next = pos + 1;\n              break;\n            } else {\n              unclosed('string');\n            }\n          }\n\n          escapePos = next;\n\n          while (css.charCodeAt(escapePos - 1) === BACKSLASH) {\n            escapePos -= 1;\n            escaped = !escaped;\n          }\n        } while (escaped);\n\n        content = css.slice(pos, next + 1);\n        lines = content.split('\\n');\n        last = lines.length - 1;\n\n        if (last > 0) {\n          nextLine = line + last;\n          nextOffset = next - lines[last].length;\n        } else {\n          nextLine = line;\n          nextOffset = offset;\n        }\n\n        currentToken = ['string', css.slice(pos, next + 1), line, pos - offset, nextLine, next - nextOffset];\n        offset = nextOffset;\n        line = nextLine;\n        pos = next;\n        break;\n\n      case AT:\n        RE_AT_END.lastIndex = pos + 1;\n        RE_AT_END.test(css);\n\n        if (RE_AT_END.lastIndex === 0) {\n          next = css.length - 1;\n        } else {\n          next = RE_AT_END.lastIndex - 2;\n        }\n\n        currentToken = ['at-word', css.slice(pos, next + 1), line, pos - offset, line, next - offset];\n        pos = next;\n        break;\n\n      case BACKSLASH:\n        next = pos;\n        escape = true;\n\n        while (css.charCodeAt(next + 1) === BACKSLASH) {\n          next += 1;\n          escape = !escape;\n        }\n\n        code = css.charCodeAt(next + 1);\n\n        if (escape && code !== SLASH && code !== SPACE && code !== NEWLINE && code !== TAB && code !== CR && code !== FEED) {\n          next += 1;\n\n          if (RE_HEX_ESCAPE.test(css.charAt(next))) {\n            while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {\n              next += 1;\n            }\n\n            if (css.charCodeAt(next + 1) === SPACE) {\n              next += 1;\n            }\n          }\n        }\n\n        currentToken = ['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset];\n        pos = next;\n        break;\n\n      default:\n        if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {\n          next = css.indexOf('*/', pos + 2) + 1;\n\n          if (next === 0) {\n            if (ignore) {\n              next = css.length;\n            } else {\n              unclosed('comment');\n            }\n          }\n\n          content = css.slice(pos, next + 1);\n          lines = content.split('\\n');\n          last = lines.length - 1;\n\n          if (last > 0) {\n            nextLine = line + last;\n            nextOffset = next - lines[last].length;\n          } else {\n            nextLine = line;\n            nextOffset = offset;\n          }\n\n          currentToken = ['comment', content, line, pos - offset, nextLine, next - nextOffset];\n          offset = nextOffset;\n          line = nextLine;\n          pos = next;\n        } else {\n          RE_WORD_END.lastIndex = pos + 1;\n          RE_WORD_END.test(css);\n\n          if (RE_WORD_END.lastIndex === 0) {\n            next = css.length - 1;\n          } else {\n            next = RE_WORD_END.lastIndex - 2;\n          }\n\n          currentToken = ['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset];\n          buffer.push(currentToken);\n          pos = next;\n        }\n\n        break;\n    }\n\n    pos++;\n    return currentToken;\n  }\n\n  function back(token) {\n    returned.push(token);\n  }\n\n  return {\n    back: back,\n    nextToken: nextToken,\n    endOfFile: endOfFile\n  };\n}\n\nmodule.exports = exports['default'];","map":{"version":3,"sources":["tokenize.es6"],"names":["SINGLE_QUOTE","DOUBLE_QUOTE","BACKSLASH","SLASH","NEWLINE","SPACE","FEED","TAB","CR","OPEN_SQUARE","CLOSE_SQUARE","OPEN_PARENTHESES","CLOSE_PARENTHESES","OPEN_CURLY","CLOSE_CURLY","SEMICOLON","ASTERISK","COLON","AT","RE_AT_END","RE_WORD_END","RE_BAD_BRACKET","RE_HEX_ESCAPE","tokenizer","options","css","input","ignore","code","next","quote","lines","last","content","escape","nextLine","nextOffset","escaped","escapePos","prev","n","currentToken","length","offset","line","pos","buffer","returned","unclosed","back","nextToken","endOfFile"],"mappings":"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","sourcesContent":["const SINGLE_QUOTE      = '\\''.charCodeAt(0);\nconst DOUBLE_QUOTE      =  '\"'.charCodeAt(0);\nconst BACKSLASH         = '\\\\'.charCodeAt(0);\nconst SLASH             =  '/'.charCodeAt(0);\nconst NEWLINE           = '\\n'.charCodeAt(0);\nconst SPACE             =  ' '.charCodeAt(0);\nconst FEED              = '\\f'.charCodeAt(0);\nconst TAB               = '\\t'.charCodeAt(0);\nconst CR                = '\\r'.charCodeAt(0);\nconst OPEN_SQUARE       =  '['.charCodeAt(0);\nconst CLOSE_SQUARE      =  ']'.charCodeAt(0);\nconst OPEN_PARENTHESES  =  '('.charCodeAt(0);\nconst CLOSE_PARENTHESES =  ')'.charCodeAt(0);\nconst OPEN_CURLY        =  '{'.charCodeAt(0);\nconst CLOSE_CURLY       =  '}'.charCodeAt(0);\nconst SEMICOLON         =  ';'.charCodeAt(0);\nconst ASTERISK          =  '*'.charCodeAt(0);\nconst COLON             =  ':'.charCodeAt(0);\nconst AT                =  '@'.charCodeAt(0);\n\nconst RE_AT_END      = /[ \\n\\t\\r\\f\\{\\}\\(\\)'\"\\\\;/\\[\\]#]/g;\nconst RE_WORD_END    = /[ \\n\\t\\r\\f\\(\\)\\{\\}:;@!'\"\\\\\\]\\[#]|\\/(?=\\*)/g;\nconst RE_BAD_BRACKET = /.[\\\\\\/\\(\"'\\n]/;\nconst RE_HEX_ESCAPE  = /[a-f0-9]/i;\n\nexport default function tokenizer(input, options = {}) {\n    let css = input.css.valueOf();\n    let ignore = options.ignoreErrors;\n\n    let code, next, quote, lines, last, content, escape,\n        nextLine, nextOffset, escaped, escapePos, prev, n, currentToken;\n\n    let length = css.length;\n    let offset = -1;\n    let line = 1;\n    let pos = 0;\n    let buffer = [];\n    let returned = [];\n\n    function unclosed(what) {\n        throw input.error('Unclosed ' + what, line, pos - offset);\n    }\n\n    function endOfFile() {\n        return returned.length === 0 && pos >= length;\n    }\n\n    function nextToken() {\n        if ( returned.length ) return returned.pop();\n        if ( pos >= length ) return;\n\n        code = css.charCodeAt(pos);\n        if ( code === NEWLINE || code === FEED ||\n             code === CR && css.charCodeAt(pos + 1) !== NEWLINE ) {\n            offset = pos;\n            line += 1;\n        }\n\n        switch ( code ) {\n        case NEWLINE:\n        case SPACE:\n        case TAB:\n        case CR:\n        case FEED:\n            next = pos;\n            do {\n                next += 1;\n                code = css.charCodeAt(next);\n                if ( code === NEWLINE ) {\n                    offset = next;\n                    line += 1;\n                }\n            } while ( code === SPACE   ||\n                      code === NEWLINE ||\n                      code === TAB     ||\n                      code === CR      ||\n                      code === FEED );\n\n            currentToken = ['space', css.slice(pos, next)];\n            pos = next - 1;\n            break;\n\n        case OPEN_SQUARE:\n            currentToken = ['[', '[', line, pos - offset];\n            break;\n\n        case CLOSE_SQUARE:\n            currentToken = [']', ']', line, pos - offset];\n            break;\n\n        case OPEN_CURLY:\n            currentToken = ['{', '{', line, pos - offset];\n            break;\n\n        case CLOSE_CURLY:\n            currentToken = ['}', '}', line, pos - offset];\n            break;\n\n        case COLON:\n            currentToken = [':', ':', line, pos - offset];\n            break;\n\n        case SEMICOLON:\n            currentToken = [';', ';', line, pos - offset];\n            break;\n\n        case OPEN_PARENTHESES:\n            prev = buffer.length ? buffer.pop()[1] : '';\n            n    = css.charCodeAt(pos + 1);\n            if ( prev === 'url' &&\n                 n !== SINGLE_QUOTE && n !== DOUBLE_QUOTE &&\n                 n !== SPACE && n !== NEWLINE && n !== TAB &&\n                 n !== FEED && n !== CR ) {\n                next = pos;\n                do {\n                    escaped = false;\n                    next    = css.indexOf(')', next + 1);\n                    if ( next === -1 ) {\n                        if ( ignore ) {\n                            next = pos;\n                            break;\n                        } else {\n                            unclosed('bracket');\n                        }\n                    }\n                    escapePos = next;\n                    while ( css.charCodeAt(escapePos - 1) === BACKSLASH ) {\n                        escapePos -= 1;\n                        escaped = !escaped;\n                    }\n                } while ( escaped );\n\n                currentToken = ['brackets', css.slice(pos, next + 1),\n                    line, pos  - offset,\n                    line, next - offset\n                ];\n\n                pos = next;\n\n            } else {\n                next    = css.indexOf(')', pos + 1);\n                content = css.slice(pos, next + 1);\n\n                if ( next === -1 || RE_BAD_BRACKET.test(content) ) {\n                    currentToken = ['(', '(', line, pos - offset];\n                } else {\n                    currentToken = ['brackets', content,\n                        line, pos  - offset,\n                        line, next - offset\n                    ];\n                    pos = next;\n                }\n            }\n\n            break;\n\n        case CLOSE_PARENTHESES:\n            currentToken = [')', ')', line, pos - offset];\n            break;\n\n        case SINGLE_QUOTE:\n        case DOUBLE_QUOTE:\n            quote = code === SINGLE_QUOTE ? '\\'' : '\"';\n            next  = pos;\n            do {\n                escaped = false;\n                next    = css.indexOf(quote, next + 1);\n                if ( next === -1 ) {\n                    if ( ignore ) {\n                        next = pos + 1;\n                        break;\n                    } else {\n                        unclosed('string');\n                    }\n                }\n                escapePos = next;\n                while ( css.charCodeAt(escapePos - 1) === BACKSLASH ) {\n                    escapePos -= 1;\n                    escaped = !escaped;\n                }\n            } while ( escaped );\n\n            content = css.slice(pos, next + 1);\n            lines   = content.split('\\n');\n            last    = lines.length - 1;\n\n            if ( last > 0 ) {\n                nextLine   = line + last;\n                nextOffset = next - lines[last].length;\n            } else {\n                nextLine   = line;\n                nextOffset = offset;\n            }\n\n            currentToken = ['string', css.slice(pos, next + 1),\n                line, pos  - offset,\n                nextLine, next - nextOffset\n            ];\n\n            offset = nextOffset;\n            line   = nextLine;\n            pos    = next;\n            break;\n\n        case AT:\n            RE_AT_END.lastIndex = pos + 1;\n            RE_AT_END.test(css);\n            if ( RE_AT_END.lastIndex === 0 ) {\n                next = css.length - 1;\n            } else {\n                next = RE_AT_END.lastIndex - 2;\n            }\n\n            currentToken = ['at-word', css.slice(pos, next + 1),\n                line, pos  - offset,\n                line, next - offset\n            ];\n\n            pos = next;\n            break;\n\n        case BACKSLASH:\n            next   = pos;\n            escape = true;\n            while ( css.charCodeAt(next + 1) === BACKSLASH ) {\n                next  += 1;\n                escape = !escape;\n            }\n            code = css.charCodeAt(next + 1);\n            if ( escape && (code !== SLASH   &&\n                            code !== SPACE   &&\n                            code !== NEWLINE &&\n                            code !== TAB     &&\n                            code !== CR      &&\n                            code !== FEED ) ) {\n                next += 1;\n                if ( RE_HEX_ESCAPE.test(css.charAt(next)) ) {\n                    while ( RE_HEX_ESCAPE.test(css.charAt(next + 1)) ) {\n                        next += 1;\n                    }\n                    if ( css.charCodeAt(next + 1) === SPACE ) {\n                        next += 1;\n                    }\n                }\n            }\n\n            currentToken = ['word', css.slice(pos, next + 1),\n                line, pos  - offset,\n                line, next - offset\n            ];\n\n            pos = next;\n            break;\n\n        default:\n            if ( code === SLASH && css.charCodeAt(pos + 1) === ASTERISK ) {\n                next = css.indexOf('*/', pos + 2) + 1;\n                if ( next === 0 ) {\n                    if ( ignore ) {\n                        next = css.length;\n                    } else {\n                        unclosed('comment');\n                    }\n                }\n\n                content = css.slice(pos, next + 1);\n                lines   = content.split('\\n');\n                last    = lines.length - 1;\n\n                if ( last > 0 ) {\n                    nextLine   = line + last;\n                    nextOffset = next - lines[last].length;\n                } else {\n                    nextLine   = line;\n                    nextOffset = offset;\n                }\n\n                currentToken = ['comment', content,\n                    line,     pos  - offset,\n                    nextLine, next - nextOffset\n                ];\n\n                offset = nextOffset;\n                line   = nextLine;\n                pos    = next;\n\n            } else {\n                RE_WORD_END.lastIndex = pos + 1;\n                RE_WORD_END.test(css);\n                if ( RE_WORD_END.lastIndex === 0 ) {\n                    next = css.length - 1;\n                } else {\n                    next = RE_WORD_END.lastIndex - 2;\n                }\n\n                currentToken = ['word', css.slice(pos, next + 1),\n                    line, pos  - offset,\n                    line, next - offset\n                ];\n\n                buffer.push(currentToken);\n\n                pos = next;\n            }\n\n            break;\n        }\n\n        pos++;\n        return currentToken;\n    }\n\n    function back(token) {\n        returned.push(token);\n    }\n\n    return {\n        back,\n        nextToken,\n        endOfFile\n    };\n}\n"]},"metadata":{},"sourceType":"script"}