{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _mapGenerator = require('./map-generator');\n\nvar _mapGenerator2 = _interopRequireDefault(_mapGenerator);\n\nvar _stringify2 = require('./stringify');\n\nvar _stringify3 = _interopRequireDefault(_stringify2);\n\nvar _warnOnce = require('./warn-once');\n\nvar _warnOnce2 = _interopRequireDefault(_warnOnce);\n\nvar _result = require('./result');\n\nvar _result2 = _interopRequireDefault(_result);\n\nvar _parse = require('./parse');\n\nvar _parse2 = _interopRequireDefault(_parse);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction isPromise(obj) {\n  return (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && typeof obj.then === 'function';\n}\n/**\n * A Promise proxy for the result of PostCSS transformations.\n *\n * A `LazyResult` instance is returned by {@link Processor#process}.\n *\n * @example\n * const lazy = postcss([cssnext]).process(css);\n */\n\n\nvar LazyResult = function () {\n  function LazyResult(processor, css, opts) {\n    _classCallCheck(this, LazyResult);\n\n    this.stringified = false;\n    this.processed = false;\n    var root = void 0;\n\n    if ((typeof css === 'undefined' ? 'undefined' : _typeof(css)) === 'object' && css !== null && css.type === 'root') {\n      root = css;\n    } else if (css instanceof LazyResult || css instanceof _result2.default) {\n      root = css.root;\n\n      if (css.map) {\n        if (typeof opts.map === 'undefined') opts.map = {};\n        if (!opts.map.inline) opts.map.inline = false;\n        opts.map.prev = css.map;\n      }\n    } else {\n      var parser = _parse2.default;\n      if (opts.syntax) parser = opts.syntax.parse;\n      if (opts.parser) parser = opts.parser;\n      if (parser.parse) parser = parser.parse;\n\n      try {\n        root = parser(css, opts);\n      } catch (error) {\n        this.error = error;\n      }\n    }\n\n    this.result = new _result2.default(processor, root, opts);\n  }\n  /**\n   * Returns a {@link Processor} instance, which will be used\n   * for CSS transformations.\n   * @type {Processor}\n   */\n\n  /**\n   * Processes input CSS through synchronous plugins\n   * and calls {@link Result#warnings()}.\n   *\n   * @return {Warning[]} warnings from plugins\n   */\n\n\n  LazyResult.prototype.warnings = function warnings() {\n    return this.sync().warnings();\n  };\n  /**\n   * Alias for the {@link LazyResult#css} property.\n   *\n   * @example\n   * lazy + '' === lazy.css;\n   *\n   * @return {string} output CSS\n   */\n\n\n  LazyResult.prototype.toString = function toString() {\n    return this.css;\n  };\n  /**\n   * Processes input CSS through synchronous and asynchronous plugins\n   * and calls `onFulfilled` with a Result instance. If a plugin throws\n   * an error, the `onRejected` callback will be executed.\n   *\n   * It implements standard Promise API.\n   *\n   * @param {onFulfilled} onFulfilled - callback will be executed\n   *                                    when all plugins will finish work\n   * @param {onRejected}  onRejected  - callback will be executed on any error\n   *\n   * @return {Promise} Promise API to make queue\n   *\n   * @example\n   * postcss([cssnext]).process(css, { from: cssPath }).then(result => {\n   *   console.log(result.css);\n   * });\n   */\n\n\n  LazyResult.prototype.then = function then(onFulfilled, onRejected) {\n    if (!('from' in this.opts)) {\n      (0, _warnOnce2.default)('Without `from` option PostCSS could generate wrong ' + 'source map and will not find Browserslist config. ' + 'Set it to CSS file path or to `undefined` to prevent ' + 'this warning.');\n    }\n\n    return this.async().then(onFulfilled, onRejected);\n  };\n  /**\n   * Processes input CSS through synchronous and asynchronous plugins\n   * and calls onRejected for each error thrown in any plugin.\n   *\n   * It implements standard Promise API.\n   *\n   * @param {onRejected} onRejected - callback will be executed on any error\n   *\n   * @return {Promise} Promise API to make queue\n   *\n   * @example\n   * postcss([cssnext]).process(css).then(result => {\n   *   console.log(result.css);\n   * }).catch(error => {\n   *   console.error(error);\n   * });\n   */\n\n\n  LazyResult.prototype.catch = function _catch(onRejected) {\n    return this.async().catch(onRejected);\n  };\n\n  LazyResult.prototype.handleError = function handleError(error, plugin) {\n    try {\n      this.error = error;\n\n      if (error.name === 'CssSyntaxError' && !error.plugin) {\n        error.plugin = plugin.postcssPlugin;\n        error.setMessage();\n      } else if (plugin.postcssVersion) {\n        var pluginName = plugin.postcssPlugin;\n        var pluginVer = plugin.postcssVersion;\n        var runtimeVer = this.result.processor.version;\n        var a = pluginVer.split('.');\n        var b = runtimeVer.split('.');\n\n        if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {\n          console.error('Unknown error from PostCSS plugin. ' + 'Your current PostCSS version ' + 'is ' + runtimeVer + ', but ' + pluginName + ' ' + 'uses ' + pluginVer + '. Perhaps this is ' + 'the source of the error below.');\n        }\n      }\n    } catch (err) {\n      if (console && console.error) console.error(err);\n    }\n  };\n\n  LazyResult.prototype.asyncTick = function asyncTick(resolve, reject) {\n    var _this = this;\n\n    if (this.plugin >= this.processor.plugins.length) {\n      this.processed = true;\n      return resolve();\n    }\n\n    try {\n      var plugin = this.processor.plugins[this.plugin];\n      var promise = this.run(plugin);\n      this.plugin += 1;\n\n      if (isPromise(promise)) {\n        promise.then(function () {\n          _this.asyncTick(resolve, reject);\n        }).catch(function (error) {\n          _this.handleError(error, plugin);\n\n          _this.processed = true;\n          reject(error);\n        });\n      } else {\n        this.asyncTick(resolve, reject);\n      }\n    } catch (error) {\n      this.processed = true;\n      reject(error);\n    }\n  };\n\n  LazyResult.prototype.async = function async() {\n    var _this2 = this;\n\n    if (this.processed) {\n      return new Promise(function (resolve, reject) {\n        if (_this2.error) {\n          reject(_this2.error);\n        } else {\n          resolve(_this2.stringify());\n        }\n      });\n    }\n\n    if (this.processing) {\n      return this.processing;\n    }\n\n    this.processing = new Promise(function (resolve, reject) {\n      if (_this2.error) return reject(_this2.error);\n      _this2.plugin = 0;\n\n      _this2.asyncTick(resolve, reject);\n    }).then(function () {\n      _this2.processed = true;\n      return _this2.stringify();\n    });\n    return this.processing;\n  };\n\n  LazyResult.prototype.sync = function sync() {\n    if (this.processed) return this.result;\n    this.processed = true;\n\n    if (this.processing) {\n      throw new Error('Use process(css).then(cb) to work with async plugins');\n    }\n\n    if (this.error) throw this.error;\n\n    for (var _iterator = this.result.processor.plugins, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var plugin = _ref;\n      var promise = this.run(plugin);\n\n      if (isPromise(promise)) {\n        throw new Error('Use process(css).then(cb) to work with async plugins');\n      }\n    }\n\n    return this.result;\n  };\n\n  LazyResult.prototype.run = function run(plugin) {\n    this.result.lastPlugin = plugin;\n\n    try {\n      return plugin(this.result.root, this.result);\n    } catch (error) {\n      this.handleError(error, plugin);\n      throw error;\n    }\n  };\n\n  LazyResult.prototype.stringify = function stringify() {\n    if (this.stringified) return this.result;\n    this.stringified = true;\n    this.sync();\n    var opts = this.result.opts;\n    var str = _stringify3.default;\n    if (opts.syntax) str = opts.syntax.stringify;\n    if (opts.stringifier) str = opts.stringifier;\n    if (str.stringify) str = str.stringify;\n    var map = new _mapGenerator2.default(str, this.result.root, this.result.opts);\n    var data = map.generate();\n    this.result.css = data[0];\n    this.result.map = data[1];\n    return this.result;\n  };\n\n  _createClass(LazyResult, [{\n    key: 'processor',\n    get: function get() {\n      return this.result.processor;\n    }\n    /**\n     * Options from the {@link Processor#process} call.\n     * @type {processOptions}\n     */\n\n  }, {\n    key: 'opts',\n    get: function get() {\n      return this.result.opts;\n    }\n    /**\n     * Processes input CSS through synchronous plugins, converts `Root`\n     * to a CSS string and returns {@link Result#css}.\n     *\n     * This property will only work with synchronous plugins.\n     * If the processor contains any asynchronous plugins\n     * it will throw an error. This is why this method is only\n     * for debug purpose, you should always use {@link LazyResult#then}.\n     *\n     * @type {string}\n     * @see Result#css\n     */\n\n  }, {\n    key: 'css',\n    get: function get() {\n      return this.stringify().css;\n    }\n    /**\n     * An alias for the `css` property. Use it with syntaxes\n     * that generate non-CSS output.\n     *\n     * This property will only work with synchronous plugins.\n     * If the processor contains any asynchronous plugins\n     * it will throw an error. This is why this method is only\n     * for debug purpose, you should always use {@link LazyResult#then}.\n     *\n     * @type {string}\n     * @see Result#content\n     */\n\n  }, {\n    key: 'content',\n    get: function get() {\n      return this.stringify().content;\n    }\n    /**\n     * Processes input CSS through synchronous plugins\n     * and returns {@link Result#map}.\n     *\n     * This property will only work with synchronous plugins.\n     * If the processor contains any asynchronous plugins\n     * it will throw an error. This is why this method is only\n     * for debug purpose, you should always use {@link LazyResult#then}.\n     *\n     * @type {SourceMapGenerator}\n     * @see Result#map\n     */\n\n  }, {\n    key: 'map',\n    get: function get() {\n      return this.stringify().map;\n    }\n    /**\n     * Processes input CSS through synchronous plugins\n     * and returns {@link Result#root}.\n     *\n     * This property will only work with synchronous plugins. If the processor\n     * contains any asynchronous plugins it will throw an error.\n     *\n     * This is why this method is only for debug purpose,\n     * you should always use {@link LazyResult#then}.\n     *\n     * @type {Root}\n     * @see Result#root\n     */\n\n  }, {\n    key: 'root',\n    get: function get() {\n      return this.sync().root;\n    }\n    /**\n     * Processes input CSS through synchronous plugins\n     * and returns {@link Result#messages}.\n     *\n     * This property will only work with synchronous plugins. If the processor\n     * contains any asynchronous plugins it will throw an error.\n     *\n     * This is why this method is only for debug purpose,\n     * you should always use {@link LazyResult#then}.\n     *\n     * @type {Message[]}\n     * @see Result#messages\n     */\n\n  }, {\n    key: 'messages',\n    get: function get() {\n      return this.sync().messages;\n    }\n  }]);\n\n  return LazyResult;\n}();\n\nexports.default = LazyResult;\n/**\n * @callback onFulfilled\n * @param {Result} result\n */\n\n/**\n * @callback onRejected\n * @param {Error} error\n */\n\nmodule.exports = exports['default'];","map":{"version":3,"sources":["lazy-result.es6"],"names":["obj","LazyResult","root","css","Result","opts","parser","parse","warnings","toString","then","onFulfilled","onRejected","catch","handleError","error","plugin","pluginName","pluginVer","runtimeVer","a","b","parseInt","console","asyncTick","resolve","reject","promise","isPromise","async","sync","run","stringify","str","map","MapGenerator","data"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,aAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;;;AACA,IAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;;;AACA,IAAA,SAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;;;AACA,IAAA,OAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;;;AACA,IAAA,MAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;;;;;;;;;;;;;;;AAEA,SAAA,SAAA,CAAA,GAAA,EAAwB;AACpB,SAAO,CAAA,OAAA,GAAA,KAAA,WAAA,GAAA,WAAA,GAAA,OAAA,CAAA,GAAA,CAAA,MAAA,QAAA,IAA2B,OAAOA,GAAAA,CAAP,IAAA,KAAlC,UAAA;AACH;AAED;;;;;;;;;;IAQMC,U;AAEF,WAAA,UAAA,CAAA,SAAA,EAAA,GAAA,EAAA,IAAA,EAAkC;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,UAAA,CAAA;;AAC9B,SAAA,WAAA,GAAA,KAAA;AACA,SAAA,SAAA,GAAA,KAAA;AAEA,QAAIC,IAAAA,GAAAA,KAAJ,CAAA;;AACA,QAAK,CAAA,OAAA,GAAA,KAAA,WAAA,GAAA,WAAA,GAAA,OAAA,CAAA,GAAA,CAAA,MAAA,QAAA,IAA2BC,GAAAA,KAA3B,IAAA,IAA2CA,GAAAA,CAAAA,IAAAA,KAAhD,MAAA,EAAsE;AAClED,MAAAA,IAAAA,GAAAA,GAAAA;AADJ,KAAA,MAEO,IAAKC,GAAAA,YAAAA,UAAAA,IAA6BA,GAAAA,YAAeC,QAAAA,CAAjD,OAAA,EAA0D;AAC7DF,MAAAA,IAAAA,GAAOC,GAAAA,CAAPD,IAAAA;;AACA,UAAKC,GAAAA,CAAL,GAAA,EAAe;AACX,YAAK,OAAOE,IAAAA,CAAP,GAAA,KAAL,WAAA,EAAuCA,IAAAA,CAAAA,GAAAA,GAAAA,EAAAA;AACvC,YAAK,CAACA,IAAAA,CAAAA,GAAAA,CAAN,MAAA,EAAwBA,IAAAA,CAAAA,GAAAA,CAAAA,MAAAA,GAAAA,KAAAA;AACxBA,QAAAA,IAAAA,CAAAA,GAAAA,CAAAA,IAAAA,GAAgBF,GAAAA,CAAhBE,GAAAA;AACH;AANE,KAAA,MAOA;AACH,UAAIC,MAAAA,GAASC,OAAAA,CAAb,OAAA;AACA,UAAKF,IAAAA,CAAL,MAAA,EAAoBC,MAAAA,GAASD,IAAAA,CAAAA,MAAAA,CAATC,KAAAA;AACpB,UAAKD,IAAAA,CAAL,MAAA,EAAoBC,MAAAA,GAASD,IAAAA,CAATC,MAAAA;AACpB,UAAKA,MAAAA,CAAL,KAAA,EAAoBA,MAAAA,GAASA,MAAAA,CAATA,KAAAA;;AAEpB,UAAI;AACAJ,QAAAA,IAAAA,GAAOI,MAAAA,CAAAA,GAAAA,EAAPJ,IAAOI,CAAPJ;AADJ,OAAA,CAEE,OAAA,KAAA,EAAc;AACZ,aAAA,KAAA,GAAA,KAAA;AACH;AACJ;;AAED,SAAA,MAAA,GAAc,IAAIE,QAAAA,CAAJ,OAAA,CAAA,SAAA,EAAA,IAAA,EAAd,IAAc,CAAd;AACH;AAED;;;;;;AAmGA;;;;;;;;uBAMAI,Q,uBAAW;AACP,WAAO,KAAA,IAAA,GAAP,QAAO,EAAP;;AAGJ;;;;;;;;;;uBAQAC,Q,uBAAW;AACP,WAAO,KAAP,GAAA;;AAGJ;;;;;;;;;;;;;;;;;;;;uBAkBAC,I,iBAAKC,W,EAAaC,U,EAAY;AAC1B,QAAI,EAAE,UAAU,KAAhB,IAAI,CAAJ,EAA4B;AACxB,OAAA,GAAA,UAAA,CAAA,OAAA,EACI,wDAAA,oDAAA,GAAA,uDAAA,GADJ,eAAA;AAMH;;AACD,WAAO,KAAA,KAAA,GAAA,IAAA,CAAA,WAAA,EAAP,UAAO,CAAP;;AAGJ;;;;;;;;;;;;;;;;;;;uBAiBAC,K,mBAAMD,U,EAAY;AACd,WAAO,KAAA,KAAA,GAAA,KAAA,CAAP,UAAO,CAAP;;;uBAGJE,W,wBAAYC,K,EAAOC,M,EAAQ;AACvB,QAAI;AACA,WAAA,KAAA,GAAA,KAAA;;AACA,UAAKD,KAAAA,CAAAA,IAAAA,KAAAA,gBAAAA,IAAmC,CAACA,KAAAA,CAAzC,MAAA,EAAwD;AACpDA,QAAAA,KAAAA,CAAAA,MAAAA,GAAeC,MAAAA,CAAfD,aAAAA;AACAA,QAAAA,KAAAA,CAAAA,UAAAA;AAFJ,OAAA,MAGO,IAAKC,MAAAA,CAAL,cAAA,EAA6B;AAChC,YAAIC,UAAAA,GAAaD,MAAAA,CAAjB,aAAA;AACA,YAAIE,SAAAA,GAAaF,MAAAA,CAAjB,cAAA;AACA,YAAIG,UAAAA,GAAa,KAAA,MAAA,CAAA,SAAA,CAAjB,OAAA;AACA,YAAIC,CAAAA,GAAIF,SAAAA,CAAAA,KAAAA,CAAR,GAAQA,CAAR;AACA,YAAIG,CAAAA,GAAIF,UAAAA,CAAAA,KAAAA,CAAR,GAAQA,CAAR;;AAEA,YAAKC,CAAAA,CAAAA,CAAAA,CAAAA,KAASC,CAAAA,CAATD,CAASC,CAATD,IAAiBE,QAAAA,CAASF,CAAAA,CAATE,CAASF,CAATE,CAAAA,GAAiBA,QAAAA,CAASD,CAAAA,CAAhD,CAAgDA,CAATC,CAAvC,EAAwD;AACpDC,UAAAA,OAAAA,CAAAA,KAAAA,CACI,wCAAA,+BAAA,GAAA,KAAA,GAAA,UAAA,GAAA,QAAA,GAAA,UAAA,GAAA,GAAA,GAAA,OAAA,GAAA,SAAA,GAAA,oBAAA,GADJA,gCAAAA;AAMH;AACJ;AApBL,KAAA,CAqBE,OAAA,GAAA,EAAY;AACV,UAAKA,OAAAA,IAAWA,OAAAA,CAAhB,KAAA,EAAgCA,OAAAA,CAAAA,KAAAA,CAAAA,GAAAA;AACnC;;;uBAGLC,S,sBAAUC,O,EAASC,M,EAAQ;AAAA,QAAA,KAAA,GAAA,IAAA;;AACvB,QAAK,KAAA,MAAA,IAAe,KAAA,SAAA,CAAA,OAAA,CAApB,MAAA,EAAoD;AAChD,WAAA,SAAA,GAAA,IAAA;AACA,aAAOD,OAAP,EAAA;AACH;;AAED,QAAI;AACA,UAAIT,MAAAA,GAAU,KAAA,SAAA,CAAA,OAAA,CAAuB,KAArC,MAAc,CAAd;AACA,UAAIW,OAAAA,GAAU,KAAA,GAAA,CAAd,MAAc,CAAd;AACA,WAAA,MAAA,IAAA,CAAA;;AAEA,UAAKC,SAAAA,CAAL,OAAKA,CAAL,EAA0B;AACtBD,QAAAA,OAAAA,CAAAA,IAAAA,CAAc,YAAM;AAChB,UAAA,KAAA,CAAA,SAAA,CAAA,OAAA,EAAA,MAAA;AADJA,SAAAA,EAAAA,KAAAA,CAEU,UAAA,KAAA,EAAS;AACf,UAAA,KAAA,CAAA,WAAA,CAAA,KAAA,EAAA,MAAA;;AACA,UAAA,KAAA,CAAA,SAAA,GAAA,IAAA;AACAD,UAAAA,MAAAA,CAAAA,KAAAA,CAAAA;AALJC,SAAAA;AADJ,OAAA,MAQO;AACH,aAAA,SAAA,CAAA,OAAA,EAAA,MAAA;AACH;AAfL,KAAA,CAiBE,OAAA,KAAA,EAAc;AACZ,WAAA,SAAA,GAAA,IAAA;AACAD,MAAAA,MAAAA,CAAAA,KAAAA,CAAAA;AACH;;;uBAGLG,K,oBAAQ;AAAA,QAAA,MAAA,GAAA,IAAA;;AACJ,QAAK,KAAL,SAAA,EAAsB;AAClB,aAAO,IAAA,OAAA,CAAa,UAAA,OAAA,EAAA,MAAA,EAAqB;AACrC,YAAK,MAAA,CAAL,KAAA,EAAkB;AACdH,UAAAA,MAAAA,CAAO,MAAA,CAAPA,KAAAA,CAAAA;AADJ,SAAA,MAEO;AACHD,UAAAA,OAAAA,CAAQ,MAAA,CAARA,SAAQ,EAARA,CAAAA;AACH;AALL,OAAO,CAAP;AAOH;;AACD,QAAK,KAAL,UAAA,EAAuB;AACnB,aAAO,KAAP,UAAA;AACH;;AAED,SAAA,UAAA,GAAkB,IAAA,OAAA,CAAa,UAAA,OAAA,EAAA,MAAA,EAAqB;AAChD,UAAK,MAAA,CAAL,KAAA,EAAkB,OAAOC,MAAAA,CAAO,MAAA,CAAd,KAAOA,CAAP;AAClB,MAAA,MAAA,CAAA,MAAA,GAAA,CAAA;;AACA,MAAA,MAAA,CAAA,SAAA,CAAA,OAAA,EAAA,MAAA;AAHc,KAAA,EAAA,IAAA,CAIT,YAAM;AACX,MAAA,MAAA,CAAA,SAAA,GAAA,IAAA;AACA,aAAO,MAAA,CAAP,SAAO,EAAP;AANJ,KAAkB,CAAlB;AASA,WAAO,KAAP,UAAA;;;uBAGJI,I,mBAAO;AACH,QAAK,KAAL,SAAA,EAAsB,OAAO,KAAP,MAAA;AACtB,SAAA,SAAA,GAAA,IAAA;;AAEA,QAAK,KAAL,UAAA,EAAuB;AACnB,YAAM,IAAA,KAAA,CAAN,sDAAM,CAAN;AAEH;;AAED,QAAK,KAAL,KAAA,EAAkB,MAAM,KAAN,KAAA;;AAElB,SAAA,IAAA,SAAA,GAAoB,KAAA,MAAA,CAAA,SAAA,CAApB,OAAA,EAAA,QAAA,GAAA,KAAA,CAAA,OAAA,CAAA,SAAA,CAAA,EAAA,EAAA,GAAA,CAAA,EAAA,SAAA,GAAA,QAAA,GAAA,SAAA,GAAA,SAAA,CAAA,MAAA,CAAA,QAAA,CAAA,EAAA,IAAoD;AAAA,UAAA,IAAA;;AAAA,UAAA,QAAA,EAAA;AAAA,YAAA,EAAA,IAAA,SAAA,CAAA,MAAA,EAAA;AAAA,QAAA,IAAA,GAAA,SAAA,CAAA,EAAA,EAAA,CAAA;AAAA,OAAA,MAAA;AAAA,QAAA,EAAA,GAAA,SAAA,CAAA,IAAA,EAAA;AAAA,YAAA,EAAA,CAAA,IAAA,EAAA;AAAA,QAAA,IAAA,GAAA,EAAA,CAAA,KAAA;AAAA;;AAAA,UAA1Cd,MAA0C,GAAA,IAAA;AAChD,UAAIW,OAAAA,GAAU,KAAA,GAAA,CAAd,MAAc,CAAd;;AACA,UAAKC,SAAAA,CAAL,OAAKA,CAAL,EAA0B;AACtB,cAAM,IAAA,KAAA,CAAN,sDAAM,CAAN;AAEH;AACJ;;AAED,WAAO,KAAP,MAAA;;;uBAGJG,G,gBAAIf,M,EAAQ;AACR,SAAA,MAAA,CAAA,UAAA,GAAA,MAAA;;AAEA,QAAI;AACA,aAAOA,MAAAA,CAAO,KAAA,MAAA,CAAPA,IAAAA,EAAyB,KAAhC,MAAOA,CAAP;AADJ,KAAA,CAEE,OAAA,KAAA,EAAc;AACZ,WAAA,WAAA,CAAA,KAAA,EAAA,MAAA;AACA,YAAA,KAAA;AACH;;;uBAGLgB,S,wBAAY;AACR,QAAK,KAAL,WAAA,EAAwB,OAAO,KAAP,MAAA;AACxB,SAAA,WAAA,GAAA,IAAA;AAEA,SAAA,IAAA;AAEA,QAAI3B,IAAAA,GAAO,KAAA,MAAA,CAAX,IAAA;AACA,QAAI4B,GAAAA,GAAOD,WAAAA,CAAX,OAAA;AACA,QAAK3B,IAAAA,CAAL,MAAA,EAAwB4B,GAAAA,GAAM5B,IAAAA,CAAAA,MAAAA,CAAN4B,SAAAA;AACxB,QAAK5B,IAAAA,CAAL,WAAA,EAAwB4B,GAAAA,GAAM5B,IAAAA,CAAN4B,WAAAA;AACxB,QAAKA,GAAAA,CAAL,SAAA,EAAwBA,GAAAA,GAAMA,GAAAA,CAANA,SAAAA;AAExB,QAAIC,GAAAA,GAAO,IAAIC,cAAAA,CAAJ,OAAA,CAAA,GAAA,EAAsB,KAAA,MAAA,CAAtB,IAAA,EAAwC,KAAA,MAAA,CAAnD,IAAW,CAAX;AACA,QAAIC,IAAAA,GAAOF,GAAAA,CAAX,QAAWA,EAAX;AACA,SAAA,MAAA,CAAA,GAAA,GAAkBE,IAAAA,CAAlB,CAAkBA,CAAlB;AACA,SAAA,MAAA,CAAA,GAAA,GAAkBA,IAAAA,CAAlB,CAAkBA,CAAlB;AAEA,WAAO,KAAP,MAAA;;;;;wBA3SY;AACZ,aAAO,KAAA,MAAA,CAAP,SAAA;AACH;AAED;;;;;;;wBAIW;AACP,aAAO,KAAA,MAAA,CAAP,IAAA;AACH;AAED;;;;;;;;;;;;;;;wBAYU;AACN,aAAO,KAAA,SAAA,GAAP,GAAA;AACH;AAED;;;;;;;;;;;;;;;wBAYc;AACV,aAAO,KAAA,SAAA,GAAP,OAAA;AACH;AAED;;;;;;;;;;;;;;;wBAYU;AACN,aAAO,KAAA,SAAA,GAAP,GAAA;AACH;AAED;;;;;;;;;;;;;;;;wBAaW;AACP,aAAO,KAAA,IAAA,GAAP,IAAA;AACH;AAED;;;;;;;;;;;;;;;;wBAae;AACX,aAAO,KAAA,IAAA,GAAP,QAAA;AACH;;;;;;kBAoNUnC,U;AAEf;;;;;AAKA","sourcesContent":["import MapGenerator from './map-generator';\nimport stringify    from './stringify';\nimport warnOnce     from './warn-once';\nimport Result       from './result';\nimport parse        from './parse';\n\nfunction isPromise(obj) {\n    return typeof obj === 'object' && typeof obj.then === 'function';\n}\n\n/**\n * A Promise proxy for the result of PostCSS transformations.\n *\n * A `LazyResult` instance is returned by {@link Processor#process}.\n *\n * @example\n * const lazy = postcss([cssnext]).process(css);\n */\nclass LazyResult {\n\n    constructor(processor, css, opts) {\n        this.stringified = false;\n        this.processed   = false;\n\n        let root;\n        if ( typeof css === 'object' && css !== null && css.type === 'root' ) {\n            root = css;\n        } else if ( css instanceof LazyResult || css instanceof Result ) {\n            root = css.root;\n            if ( css.map ) {\n                if ( typeof opts.map === 'undefined' ) opts.map = { };\n                if ( !opts.map.inline ) opts.map.inline = false;\n                opts.map.prev = css.map;\n            }\n        } else {\n            let parser = parse;\n            if ( opts.syntax )  parser = opts.syntax.parse;\n            if ( opts.parser )  parser = opts.parser;\n            if ( parser.parse ) parser = parser.parse;\n\n            try {\n                root = parser(css, opts);\n            } catch (error) {\n                this.error = error;\n            }\n        }\n\n        this.result = new Result(processor, root, opts);\n    }\n\n    /**\n     * Returns a {@link Processor} instance, which will be used\n     * for CSS transformations.\n     * @type {Processor}\n     */\n    get processor() {\n        return this.result.processor;\n    }\n\n    /**\n     * Options from the {@link Processor#process} call.\n     * @type {processOptions}\n     */\n    get opts() {\n        return this.result.opts;\n    }\n\n    /**\n     * Processes input CSS through synchronous plugins, converts `Root`\n     * to a CSS string and returns {@link Result#css}.\n     *\n     * This property will only work with synchronous plugins.\n     * If the processor contains any asynchronous plugins\n     * it will throw an error. This is why this method is only\n     * for debug purpose, you should always use {@link LazyResult#then}.\n     *\n     * @type {string}\n     * @see Result#css\n     */\n    get css() {\n        return this.stringify().css;\n    }\n\n    /**\n     * An alias for the `css` property. Use it with syntaxes\n     * that generate non-CSS output.\n     *\n     * This property will only work with synchronous plugins.\n     * If the processor contains any asynchronous plugins\n     * it will throw an error. This is why this method is only\n     * for debug purpose, you should always use {@link LazyResult#then}.\n     *\n     * @type {string}\n     * @see Result#content\n     */\n    get content() {\n        return this.stringify().content;\n    }\n\n    /**\n     * Processes input CSS through synchronous plugins\n     * and returns {@link Result#map}.\n     *\n     * This property will only work with synchronous plugins.\n     * If the processor contains any asynchronous plugins\n     * it will throw an error. This is why this method is only\n     * for debug purpose, you should always use {@link LazyResult#then}.\n     *\n     * @type {SourceMapGenerator}\n     * @see Result#map\n     */\n    get map() {\n        return this.stringify().map;\n    }\n\n    /**\n     * Processes input CSS through synchronous plugins\n     * and returns {@link Result#root}.\n     *\n     * This property will only work with synchronous plugins. If the processor\n     * contains any asynchronous plugins it will throw an error.\n     *\n     * This is why this method is only for debug purpose,\n     * you should always use {@link LazyResult#then}.\n     *\n     * @type {Root}\n     * @see Result#root\n     */\n    get root() {\n        return this.sync().root;\n    }\n\n    /**\n     * Processes input CSS through synchronous plugins\n     * and returns {@link Result#messages}.\n     *\n     * This property will only work with synchronous plugins. If the processor\n     * contains any asynchronous plugins it will throw an error.\n     *\n     * This is why this method is only for debug purpose,\n     * you should always use {@link LazyResult#then}.\n     *\n     * @type {Message[]}\n     * @see Result#messages\n     */\n    get messages() {\n        return this.sync().messages;\n    }\n\n    /**\n     * Processes input CSS through synchronous plugins\n     * and calls {@link Result#warnings()}.\n     *\n     * @return {Warning[]} warnings from plugins\n     */\n    warnings() {\n        return this.sync().warnings();\n    }\n\n    /**\n     * Alias for the {@link LazyResult#css} property.\n     *\n     * @example\n     * lazy + '' === lazy.css;\n     *\n     * @return {string} output CSS\n     */\n    toString() {\n        return this.css;\n    }\n\n    /**\n     * Processes input CSS through synchronous and asynchronous plugins\n     * and calls `onFulfilled` with a Result instance. If a plugin throws\n     * an error, the `onRejected` callback will be executed.\n     *\n     * It implements standard Promise API.\n     *\n     * @param {onFulfilled} onFulfilled - callback will be executed\n     *                                    when all plugins will finish work\n     * @param {onRejected}  onRejected  - callback will be executed on any error\n     *\n     * @return {Promise} Promise API to make queue\n     *\n     * @example\n     * postcss([cssnext]).process(css, { from: cssPath }).then(result => {\n     *   console.log(result.css);\n     * });\n     */\n    then(onFulfilled, onRejected) {\n        if (!('from' in this.opts)) {\n            warnOnce(\n                'Without `from` option PostCSS could generate wrong ' +\n                'source map and will not find Browserslist config. ' +\n                'Set it to CSS file path or to `undefined` to prevent ' +\n                'this warning.'\n            );\n        }\n        return this.async().then(onFulfilled, onRejected);\n    }\n\n    /**\n     * Processes input CSS through synchronous and asynchronous plugins\n     * and calls onRejected for each error thrown in any plugin.\n     *\n     * It implements standard Promise API.\n     *\n     * @param {onRejected} onRejected - callback will be executed on any error\n     *\n     * @return {Promise} Promise API to make queue\n     *\n     * @example\n     * postcss([cssnext]).process(css).then(result => {\n     *   console.log(result.css);\n     * }).catch(error => {\n     *   console.error(error);\n     * });\n     */\n    catch(onRejected) {\n        return this.async().catch(onRejected);\n    }\n\n    handleError(error, plugin) {\n        try {\n            this.error = error;\n            if ( error.name === 'CssSyntaxError' && !error.plugin ) {\n                error.plugin = plugin.postcssPlugin;\n                error.setMessage();\n            } else if ( plugin.postcssVersion ) {\n                let pluginName = plugin.postcssPlugin;\n                let pluginVer  = plugin.postcssVersion;\n                let runtimeVer = this.result.processor.version;\n                let a = pluginVer.split('.');\n                let b = runtimeVer.split('.');\n\n                if ( a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1]) ) {\n                    console.error(\n                        'Unknown error from PostCSS plugin. ' +\n                        'Your current PostCSS version ' +\n                        'is ' + runtimeVer + ', but ' + pluginName + ' ' +\n                        'uses ' + pluginVer + '. Perhaps this is ' +\n                        'the source of the error below.');\n                }\n            }\n        } catch (err) {\n            if ( console && console.error ) console.error(err);\n        }\n    }\n\n    asyncTick(resolve, reject) {\n        if ( this.plugin >= this.processor.plugins.length ) {\n            this.processed = true;\n            return resolve();\n        }\n\n        try {\n            let plugin  = this.processor.plugins[this.plugin];\n            let promise = this.run(plugin);\n            this.plugin += 1;\n\n            if ( isPromise(promise) ) {\n                promise.then( () => {\n                    this.asyncTick(resolve, reject);\n                }).catch( error => {\n                    this.handleError(error, plugin);\n                    this.processed = true;\n                    reject(error);\n                });\n            } else {\n                this.asyncTick(resolve, reject);\n            }\n\n        } catch (error) {\n            this.processed = true;\n            reject(error);\n        }\n    }\n\n    async() {\n        if ( this.processed ) {\n            return new Promise( (resolve, reject) => {\n                if ( this.error ) {\n                    reject(this.error);\n                } else {\n                    resolve(this.stringify());\n                }\n            });\n        }\n        if ( this.processing ) {\n            return this.processing;\n        }\n\n        this.processing = new Promise( (resolve, reject) => {\n            if ( this.error ) return reject(this.error);\n            this.plugin = 0;\n            this.asyncTick(resolve, reject);\n        }).then( () => {\n            this.processed = true;\n            return this.stringify();\n        });\n\n        return this.processing;\n    }\n\n    sync() {\n        if ( this.processed ) return this.result;\n        this.processed = true;\n\n        if ( this.processing ) {\n            throw new Error(\n                'Use process(css).then(cb) to work with async plugins');\n        }\n\n        if ( this.error ) throw this.error;\n\n        for ( let plugin of this.result.processor.plugins ) {\n            let promise = this.run(plugin);\n            if ( isPromise(promise) ) {\n                throw new Error(\n                    'Use process(css).then(cb) to work with async plugins');\n            }\n        }\n\n        return this.result;\n    }\n\n    run(plugin) {\n        this.result.lastPlugin = plugin;\n\n        try {\n            return plugin(this.result.root, this.result);\n        } catch (error) {\n            this.handleError(error, plugin);\n            throw error;\n        }\n    }\n\n    stringify() {\n        if ( this.stringified ) return this.result;\n        this.stringified = true;\n\n        this.sync();\n\n        let opts = this.result.opts;\n        let str  = stringify;\n        if ( opts.syntax )      str = opts.syntax.stringify;\n        if ( opts.stringifier ) str = opts.stringifier;\n        if ( str.stringify )    str = str.stringify;\n\n        let map  = new MapGenerator(str, this.result.root, this.result.opts);\n        let data = map.generate();\n        this.result.css = data[0];\n        this.result.map = data[1];\n\n        return this.result;\n    }\n\n}\n\nexport default LazyResult;\n\n/**\n * @callback onFulfilled\n * @param {Result} result\n */\n\n/**\n * @callback onRejected\n * @param {Error} error\n */\n"]},"metadata":{},"sourceType":"script"}