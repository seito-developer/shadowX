{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar defaultRaw = {\n  colon: ': ',\n  indent: '    ',\n  beforeDecl: '\\n',\n  beforeRule: '\\n',\n  beforeOpen: ' ',\n  beforeClose: '\\n',\n  beforeComment: '\\n',\n  after: '\\n',\n  emptyBody: '',\n  commentLeft: ' ',\n  commentRight: ' '\n};\n\nfunction capitalize(str) {\n  return str[0].toUpperCase() + str.slice(1);\n}\n\nvar Stringifier = function () {\n  function Stringifier(builder) {\n    _classCallCheck(this, Stringifier);\n\n    this.builder = builder;\n  }\n\n  Stringifier.prototype.stringify = function stringify(node, semicolon) {\n    this[node.type](node, semicolon);\n  };\n\n  Stringifier.prototype.root = function root(node) {\n    this.body(node);\n    if (node.raws.after) this.builder(node.raws.after);\n  };\n\n  Stringifier.prototype.comment = function comment(node) {\n    var left = this.raw(node, 'left', 'commentLeft');\n    var right = this.raw(node, 'right', 'commentRight');\n    this.builder('/*' + left + node.text + right + '*/', node);\n  };\n\n  Stringifier.prototype.decl = function decl(node, semicolon) {\n    var between = this.raw(node, 'between', 'colon');\n    var string = node.prop + between + this.rawValue(node, 'value');\n\n    if (node.important) {\n      string += node.raws.important || ' !important';\n    }\n\n    if (semicolon) string += ';';\n    this.builder(string, node);\n  };\n\n  Stringifier.prototype.rule = function rule(node) {\n    this.block(node, this.rawValue(node, 'selector'));\n\n    if (node.raws.ownSemicolon) {\n      this.builder(node.raws.ownSemicolon, node, 'end');\n    }\n  };\n\n  Stringifier.prototype.atrule = function atrule(node, semicolon) {\n    var name = '@' + node.name;\n    var params = node.params ? this.rawValue(node, 'params') : '';\n\n    if (typeof node.raws.afterName !== 'undefined') {\n      name += node.raws.afterName;\n    } else if (params) {\n      name += ' ';\n    }\n\n    if (node.nodes) {\n      this.block(node, name + params);\n    } else {\n      var end = (node.raws.between || '') + (semicolon ? ';' : '');\n      this.builder(name + params + end, node);\n    }\n  };\n\n  Stringifier.prototype.body = function body(node) {\n    var last = node.nodes.length - 1;\n\n    while (last > 0) {\n      if (node.nodes[last].type !== 'comment') break;\n      last -= 1;\n    }\n\n    var semicolon = this.raw(node, 'semicolon');\n\n    for (var i = 0; i < node.nodes.length; i++) {\n      var child = node.nodes[i];\n      var before = this.raw(child, 'before');\n      if (before) this.builder(before);\n      this.stringify(child, last !== i || semicolon);\n    }\n  };\n\n  Stringifier.prototype.block = function block(node, start) {\n    var between = this.raw(node, 'between', 'beforeOpen');\n    this.builder(start + between + '{', node, 'start');\n    var after = void 0;\n\n    if (node.nodes && node.nodes.length) {\n      this.body(node);\n      after = this.raw(node, 'after');\n    } else {\n      after = this.raw(node, 'after', 'emptyBody');\n    }\n\n    if (after) this.builder(after);\n    this.builder('}', node, 'end');\n  };\n\n  Stringifier.prototype.raw = function raw(node, own, detect) {\n    var value = void 0;\n    if (!detect) detect = own; // Already had\n\n    if (own) {\n      value = node.raws[own];\n      if (typeof value !== 'undefined') return value;\n    }\n\n    var parent = node.parent; // Hack for first rule in CSS\n\n    if (detect === 'before') {\n      if (!parent || parent.type === 'root' && parent.first === node) {\n        return '';\n      }\n    } // Floating child without parent\n\n\n    if (!parent) return defaultRaw[detect]; // Detect style by other nodes\n\n    var root = node.root();\n    if (!root.rawCache) root.rawCache = {};\n\n    if (typeof root.rawCache[detect] !== 'undefined') {\n      return root.rawCache[detect];\n    }\n\n    if (detect === 'before' || detect === 'after') {\n      return this.beforeAfter(node, detect);\n    } else {\n      var method = 'raw' + capitalize(detect);\n\n      if (this[method]) {\n        value = this[method](root, node);\n      } else {\n        root.walk(function (i) {\n          value = i.raws[own];\n          if (typeof value !== 'undefined') return false;\n        });\n      }\n    }\n\n    if (typeof value === 'undefined') value = defaultRaw[detect];\n    root.rawCache[detect] = value;\n    return value;\n  };\n\n  Stringifier.prototype.rawSemicolon = function rawSemicolon(root) {\n    var value = void 0;\n    root.walk(function (i) {\n      if (i.nodes && i.nodes.length && i.last.type === 'decl') {\n        value = i.raws.semicolon;\n        if (typeof value !== 'undefined') return false;\n      }\n    });\n    return value;\n  };\n\n  Stringifier.prototype.rawEmptyBody = function rawEmptyBody(root) {\n    var value = void 0;\n    root.walk(function (i) {\n      if (i.nodes && i.nodes.length === 0) {\n        value = i.raws.after;\n        if (typeof value !== 'undefined') return false;\n      }\n    });\n    return value;\n  };\n\n  Stringifier.prototype.rawIndent = function rawIndent(root) {\n    if (root.raws.indent) return root.raws.indent;\n    var value = void 0;\n    root.walk(function (i) {\n      var p = i.parent;\n\n      if (p && p !== root && p.parent && p.parent === root) {\n        if (typeof i.raws.before !== 'undefined') {\n          var parts = i.raws.before.split('\\n');\n          value = parts[parts.length - 1];\n          value = value.replace(/[^\\s]/g, '');\n          return false;\n        }\n      }\n    });\n    return value;\n  };\n\n  Stringifier.prototype.rawBeforeComment = function rawBeforeComment(root, node) {\n    var value = void 0;\n    root.walkComments(function (i) {\n      if (typeof i.raws.before !== 'undefined') {\n        value = i.raws.before;\n\n        if (value.indexOf('\\n') !== -1) {\n          value = value.replace(/[^\\n]+$/, '');\n        }\n\n        return false;\n      }\n    });\n\n    if (typeof value === 'undefined') {\n      value = this.raw(node, null, 'beforeDecl');\n    } else if (value) {\n      value = value.replace(/[^\\s]/g, '');\n    }\n\n    return value;\n  };\n\n  Stringifier.prototype.rawBeforeDecl = function rawBeforeDecl(root, node) {\n    var value = void 0;\n    root.walkDecls(function (i) {\n      if (typeof i.raws.before !== 'undefined') {\n        value = i.raws.before;\n\n        if (value.indexOf('\\n') !== -1) {\n          value = value.replace(/[^\\n]+$/, '');\n        }\n\n        return false;\n      }\n    });\n\n    if (typeof value === 'undefined') {\n      value = this.raw(node, null, 'beforeRule');\n    } else if (value) {\n      value = value.replace(/[^\\s]/g, '');\n    }\n\n    return value;\n  };\n\n  Stringifier.prototype.rawBeforeRule = function rawBeforeRule(root) {\n    var value = void 0;\n    root.walk(function (i) {\n      if (i.nodes && (i.parent !== root || root.first !== i)) {\n        if (typeof i.raws.before !== 'undefined') {\n          value = i.raws.before;\n\n          if (value.indexOf('\\n') !== -1) {\n            value = value.replace(/[^\\n]+$/, '');\n          }\n\n          return false;\n        }\n      }\n    });\n    if (value) value = value.replace(/[^\\s]/g, '');\n    return value;\n  };\n\n  Stringifier.prototype.rawBeforeClose = function rawBeforeClose(root) {\n    var value = void 0;\n    root.walk(function (i) {\n      if (i.nodes && i.nodes.length > 0) {\n        if (typeof i.raws.after !== 'undefined') {\n          value = i.raws.after;\n\n          if (value.indexOf('\\n') !== -1) {\n            value = value.replace(/[^\\n]+$/, '');\n          }\n\n          return false;\n        }\n      }\n    });\n    if (value) value = value.replace(/[^\\s]/g, '');\n    return value;\n  };\n\n  Stringifier.prototype.rawBeforeOpen = function rawBeforeOpen(root) {\n    var value = void 0;\n    root.walk(function (i) {\n      if (i.type !== 'decl') {\n        value = i.raws.between;\n        if (typeof value !== 'undefined') return false;\n      }\n    });\n    return value;\n  };\n\n  Stringifier.prototype.rawColon = function rawColon(root) {\n    var value = void 0;\n    root.walkDecls(function (i) {\n      if (typeof i.raws.between !== 'undefined') {\n        value = i.raws.between.replace(/[^\\s:]/g, '');\n        return false;\n      }\n    });\n    return value;\n  };\n\n  Stringifier.prototype.beforeAfter = function beforeAfter(node, detect) {\n    var value = void 0;\n\n    if (node.type === 'decl') {\n      value = this.raw(node, null, 'beforeDecl');\n    } else if (node.type === 'comment') {\n      value = this.raw(node, null, 'beforeComment');\n    } else if (detect === 'before') {\n      value = this.raw(node, null, 'beforeRule');\n    } else {\n      value = this.raw(node, null, 'beforeClose');\n    }\n\n    var buf = node.parent;\n    var depth = 0;\n\n    while (buf && buf.type !== 'root') {\n      depth += 1;\n      buf = buf.parent;\n    }\n\n    if (value.indexOf('\\n') !== -1) {\n      var indent = this.raw(node, null, 'indent');\n\n      if (indent.length) {\n        for (var step = 0; step < depth; step++) {\n          value += indent;\n        }\n      }\n    }\n\n    return value;\n  };\n\n  Stringifier.prototype.rawValue = function rawValue(node, prop) {\n    var value = node[prop];\n    var raw = node.raws[prop];\n\n    if (raw && raw.value === value) {\n      return raw.raw;\n    } else {\n      return value;\n    }\n  };\n\n  return Stringifier;\n}();\n\nexports.default = Stringifier;\nmodule.exports = exports['default'];","map":{"version":3,"sources":["stringifier.es6"],"names":["defaultRaw","colon","indent","beforeDecl","beforeRule","beforeOpen","beforeClose","beforeComment","after","emptyBody","commentLeft","commentRight","str","Stringifier","stringify","node","semicolon","root","comment","left","right","decl","between","string","rule","atrule","name","params","end","body","last","i","child","before","block","start","raw","own","detect","value","parent","method","capitalize","rawSemicolon","rawEmptyBody","rawIndent","p","parts","rawBeforeComment","rawBeforeDecl","rawBeforeRule","rawBeforeClose","rawBeforeOpen","rawColon","beforeAfter","buf","depth","step","rawValue","prop"],"mappings":"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","sourcesContent":["const defaultRaw = {\n    colon:         ': ',\n    indent:        '    ',\n    beforeDecl:    '\\n',\n    beforeRule:    '\\n',\n    beforeOpen:    ' ',\n    beforeClose:   '\\n',\n    beforeComment: '\\n',\n    after:         '\\n',\n    emptyBody:     '',\n    commentLeft:   ' ',\n    commentRight:  ' '\n};\n\nfunction capitalize(str) {\n    return str[0].toUpperCase() + str.slice(1);\n}\n\nclass Stringifier {\n\n    constructor(builder) {\n        this.builder = builder;\n    }\n\n    stringify(node, semicolon) {\n        this[node.type](node, semicolon);\n    }\n\n    root(node) {\n        this.body(node);\n        if ( node.raws.after ) this.builder(node.raws.after);\n    }\n\n    comment(node) {\n        let left  = this.raw(node, 'left',  'commentLeft');\n        let right = this.raw(node, 'right', 'commentRight');\n        this.builder('/*' + left + node.text + right + '*/', node);\n    }\n\n    decl(node, semicolon) {\n        let between = this.raw(node, 'between', 'colon');\n        let string  = node.prop + between + this.rawValue(node, 'value');\n\n        if ( node.important ) {\n            string += node.raws.important || ' !important';\n        }\n\n        if ( semicolon ) string += ';';\n        this.builder(string, node);\n    }\n\n    rule(node) {\n        this.block(node, this.rawValue(node, 'selector'));\n        if ( node.raws.ownSemicolon ) {\n            this.builder(node.raws.ownSemicolon, node, 'end');\n        }\n    }\n\n    atrule(node, semicolon) {\n        let name   = '@' + node.name;\n        let params = node.params ? this.rawValue(node, 'params') : '';\n\n        if ( typeof node.raws.afterName !== 'undefined' ) {\n            name += node.raws.afterName;\n        } else if ( params ) {\n            name += ' ';\n        }\n\n        if ( node.nodes ) {\n            this.block(node, name + params);\n        } else {\n            let end = (node.raws.between || '') + (semicolon ? ';' : '');\n            this.builder(name + params + end, node);\n        }\n    }\n\n    body(node) {\n        let last = node.nodes.length - 1;\n        while ( last > 0 ) {\n            if ( node.nodes[last].type !== 'comment' ) break;\n            last -= 1;\n        }\n\n        let semicolon = this.raw(node, 'semicolon');\n        for ( let i = 0; i < node.nodes.length; i++ ) {\n            let child  = node.nodes[i];\n            let before = this.raw(child, 'before');\n            if ( before ) this.builder(before);\n            this.stringify(child, last !== i || semicolon);\n        }\n    }\n\n    block(node, start) {\n        let between = this.raw(node, 'between', 'beforeOpen');\n        this.builder(start + between + '{', node, 'start');\n\n        let after;\n        if ( node.nodes && node.nodes.length ) {\n            this.body(node);\n            after = this.raw(node, 'after');\n        } else {\n            after = this.raw(node, 'after', 'emptyBody');\n        }\n\n        if ( after ) this.builder(after);\n        this.builder('}', node, 'end');\n    }\n\n    raw(node, own, detect) {\n        let value;\n        if ( !detect ) detect = own;\n\n        // Already had\n        if ( own ) {\n            value = node.raws[own];\n            if ( typeof value !== 'undefined' ) return value;\n        }\n\n        let parent = node.parent;\n\n        // Hack for first rule in CSS\n        if ( detect === 'before' ) {\n            if ( !parent || parent.type === 'root' && parent.first === node ) {\n                return '';\n            }\n        }\n\n        // Floating child without parent\n        if ( !parent ) return defaultRaw[detect];\n\n        // Detect style by other nodes\n        let root = node.root();\n        if ( !root.rawCache ) root.rawCache = { };\n        if ( typeof root.rawCache[detect] !== 'undefined' ) {\n            return root.rawCache[detect];\n        }\n\n        if ( detect === 'before' || detect === 'after' ) {\n            return this.beforeAfter(node, detect);\n        } else {\n            let method = 'raw' + capitalize(detect);\n            if ( this[method] ) {\n                value = this[method](root, node);\n            } else {\n                root.walk( i => {\n                    value = i.raws[own];\n                    if ( typeof value !== 'undefined' ) return false;\n                });\n            }\n        }\n\n        if ( typeof value === 'undefined' ) value = defaultRaw[detect];\n\n        root.rawCache[detect] = value;\n        return value;\n    }\n\n    rawSemicolon(root) {\n        let value;\n        root.walk( i => {\n            if ( i.nodes && i.nodes.length && i.last.type === 'decl' ) {\n                value = i.raws.semicolon;\n                if ( typeof value !== 'undefined' ) return false;\n            }\n        });\n        return value;\n    }\n\n    rawEmptyBody(root) {\n        let value;\n        root.walk( i => {\n            if ( i.nodes && i.nodes.length === 0 ) {\n                value = i.raws.after;\n                if ( typeof value !== 'undefined' ) return false;\n            }\n        });\n        return value;\n    }\n\n    rawIndent(root) {\n        if ( root.raws.indent ) return root.raws.indent;\n        let value;\n        root.walk( i => {\n            let p = i.parent;\n            if ( p && p !== root && p.parent && p.parent === root ) {\n                if ( typeof i.raws.before !== 'undefined' ) {\n                    let parts = i.raws.before.split('\\n');\n                    value = parts[parts.length - 1];\n                    value = value.replace(/[^\\s]/g, '');\n                    return false;\n                }\n            }\n        });\n        return value;\n    }\n\n    rawBeforeComment(root, node) {\n        let value;\n        root.walkComments( i => {\n            if ( typeof i.raws.before !== 'undefined' ) {\n                value = i.raws.before;\n                if ( value.indexOf('\\n') !== -1 ) {\n                    value = value.replace(/[^\\n]+$/, '');\n                }\n                return false;\n            }\n        });\n        if ( typeof value === 'undefined' ) {\n            value = this.raw(node, null, 'beforeDecl');\n        } else if ( value ) {\n            value = value.replace(/[^\\s]/g, '');\n        }\n        return value;\n    }\n\n    rawBeforeDecl(root, node) {\n        let value;\n        root.walkDecls( i => {\n            if ( typeof i.raws.before !== 'undefined' ) {\n                value = i.raws.before;\n                if ( value.indexOf('\\n') !== -1 ) {\n                    value = value.replace(/[^\\n]+$/, '');\n                }\n                return false;\n            }\n        });\n        if ( typeof value === 'undefined' ) {\n            value = this.raw(node, null, 'beforeRule');\n        } else if ( value ) {\n            value = value.replace(/[^\\s]/g, '');\n        }\n        return value;\n    }\n\n    rawBeforeRule(root) {\n        let value;\n        root.walk( i => {\n            if ( i.nodes && (i.parent !== root || root.first !== i) ) {\n                if ( typeof i.raws.before !== 'undefined' ) {\n                    value = i.raws.before;\n                    if ( value.indexOf('\\n') !== -1 ) {\n                        value = value.replace(/[^\\n]+$/, '');\n                    }\n                    return false;\n                }\n            }\n        });\n        if ( value ) value = value.replace(/[^\\s]/g, '');\n        return value;\n    }\n\n    rawBeforeClose(root) {\n        let value;\n        root.walk( i => {\n            if ( i.nodes && i.nodes.length > 0 ) {\n                if ( typeof i.raws.after !== 'undefined' ) {\n                    value = i.raws.after;\n                    if ( value.indexOf('\\n') !== -1 ) {\n                        value = value.replace(/[^\\n]+$/, '');\n                    }\n                    return false;\n                }\n            }\n        });\n        if ( value ) value = value.replace(/[^\\s]/g, '');\n        return value;\n    }\n\n    rawBeforeOpen(root) {\n        let value;\n        root.walk( i => {\n            if ( i.type !== 'decl' ) {\n                value = i.raws.between;\n                if ( typeof value !== 'undefined' ) return false;\n            }\n        });\n        return value;\n    }\n\n    rawColon(root) {\n        let value;\n        root.walkDecls( i => {\n            if ( typeof i.raws.between !== 'undefined' ) {\n                value = i.raws.between.replace(/[^\\s:]/g, '');\n                return false;\n            }\n        });\n        return value;\n    }\n\n    beforeAfter(node, detect) {\n        let value;\n        if ( node.type === 'decl' ) {\n            value = this.raw(node, null, 'beforeDecl');\n        } else if ( node.type === 'comment' ) {\n            value = this.raw(node, null, 'beforeComment');\n        } else if ( detect === 'before' ) {\n            value = this.raw(node, null, 'beforeRule');\n        } else {\n            value = this.raw(node, null, 'beforeClose');\n        }\n\n        let buf   = node.parent;\n        let depth = 0;\n        while ( buf && buf.type !== 'root' ) {\n            depth += 1;\n            buf = buf.parent;\n        }\n\n        if ( value.indexOf('\\n') !== -1 ) {\n            let indent = this.raw(node, null, 'indent');\n            if ( indent.length ) {\n                for ( let step = 0; step < depth; step++ ) value += indent;\n            }\n        }\n\n        return value;\n    }\n\n    rawValue(node, prop) {\n        let value = node[prop];\n        let raw   = node.raws[prop];\n        if ( raw && raw.value === value ) {\n            return raw.raw;\n        } else {\n            return value;\n        }\n    }\n\n}\n\nexport default Stringifier;\n"]},"metadata":{},"sourceType":"script"}