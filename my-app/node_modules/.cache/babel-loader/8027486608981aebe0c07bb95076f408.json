{"ast":null,"code":"const postcss = require('postcss');\n\nconst tailwindUtils = {\n  escapeClassName: require('../../lib/util/escapeClassName').default,\n  nameClass: require('../../lib/util/nameClass').default\n}; // Takes our lightweight rule structure and turns it into a PostCSS node.\n// This is likely a hot path and should be as optimized as possible. We\n// use a cache for the actual rules so that we are never recreating them\n// if we've already done the work, but we need to be careful we don't\n// mutate these nodes after we get them because we reuse the same\n// reference.\n\nfunction toPostCssNode(rule, postCssNodeCache) {\n  if (postCssNodeCache.has(rule)) {\n    return postCssNodeCache.get(rule);\n  }\n\n  let [selector, childRule] = rule;\n  let node;\n\n  if (selector[0] === '@') {\n    let name = selector.slice(1, selector.indexOf(' '));\n    let params = selector.slice(selector.indexOf(' ') + 1);\n    node = postcss.atRule({\n      name,\n      params\n    });\n\n    if (Array.isArray(childRule)) {\n      // It's a rule tuple\n      node.append(childRule.map(rule => {\n        return toPostCssNode(rule, postCssNodeCache);\n      }));\n    } else {\n      // It's an object, like pairs in keyframes\n      for (let property in childRule) {\n        node.append(postcss.decl({\n          prop: property,\n          value: childRule[property]\n        }));\n      }\n    }\n  } else {\n    // Regular rule (like a class), children are definitely declarations,\n    // not other rules\n    node = postcss.rule({\n      selector: rule[0],\n      nodes: Object.entries(rule[1]).map(([prop, value]) => {\n        return postcss.decl({\n          prop,\n          value\n        });\n      })\n    });\n  }\n\n  postCssNodeCache.set(rule, node);\n  return node;\n}\n\nfunction bigSign(bigIntValue) {\n  return (bigIntValue > 0n) - (bigIntValue < 0n);\n}\n\nfunction isPlainObject(value) {\n  if (Object.prototype.toString.call(value) !== '[object Object]') {\n    return false;\n  }\n\n  const prototype = Object.getPrototypeOf(value);\n  return prototype === null || prototype === Object.prototype;\n} // workaround for minifier bug which splits selectors by commas,\n// even when they are escaped (e.g. \\,)\n\n\nfunction escapeCommas(className) {\n  return className.replace(/\\\\,/g, '\\\\2c ');\n}\n\nfunction escapeClassName(...args) {\n  return escapeCommas(tailwindUtils.escapeClassName(...args));\n}\n\nfunction nameClass(...args) {\n  return escapeCommas(tailwindUtils.nameClass(...args));\n}\n/**\n * Clone generated and/or cached nodes to ensure no future\n * postcss plugins can mutate the rules and mess up our cache\n *\n * @param {import('postcss').Node[]} nodes\n * */\n\n\nfunction cloneNodes(nodes) {\n  return nodes.map(node => node.clone());\n}\n\nmodule.exports = {\n  toPostCssNode,\n  bigSign,\n  isPlainObject,\n  escapeClassName,\n  escapeCommas,\n  nameClass,\n  cloneNodes\n};","map":{"version":3,"sources":["/Users/seito/Documents/develop/count-jp/my-app/node_modules/tailwindcss/jit/lib/utils.js"],"names":["postcss","require","tailwindUtils","escapeClassName","default","nameClass","toPostCssNode","rule","postCssNodeCache","has","get","selector","childRule","node","name","slice","indexOf","params","atRule","Array","isArray","append","map","property","decl","prop","value","nodes","Object","entries","set","bigSign","bigIntValue","isPlainObject","prototype","toString","call","getPrototypeOf","escapeCommas","className","replace","args","cloneNodes","clone","module","exports"],"mappings":"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","sourcesContent":["const postcss = require('postcss')\nconst tailwindUtils = {\n  escapeClassName: require('../../lib/util/escapeClassName').default,\n  nameClass: require('../../lib/util/nameClass').default,\n}\n\n// Takes our lightweight rule structure and turns it into a PostCSS node.\n// This is likely a hot path and should be as optimized as possible. We\n// use a cache for the actual rules so that we are never recreating them\n// if we've already done the work, but we need to be careful we don't\n// mutate these nodes after we get them because we reuse the same\n// reference.\nfunction toPostCssNode(rule, postCssNodeCache) {\n  if (postCssNodeCache.has(rule)) {\n    return postCssNodeCache.get(rule)\n  }\n\n  let [selector, childRule] = rule\n  let node\n\n  if (selector[0] === '@') {\n    let name = selector.slice(1, selector.indexOf(' '))\n    let params = selector.slice(selector.indexOf(' ') + 1)\n    node = postcss.atRule({ name, params })\n\n    if (Array.isArray(childRule)) {\n      // It's a rule tuple\n      node.append(\n        childRule.map((rule) => {\n          return toPostCssNode(rule, postCssNodeCache)\n        })\n      )\n    } else {\n      // It's an object, like pairs in keyframes\n      for (let property in childRule) {\n        node.append(\n          postcss.decl({\n            prop: property,\n            value: childRule[property],\n          })\n        )\n      }\n    }\n  } else {\n    // Regular rule (like a class), children are definitely declarations,\n    // not other rules\n    node = postcss.rule({\n      selector: rule[0],\n      nodes: Object.entries(rule[1]).map(([prop, value]) => {\n        return postcss.decl({ prop, value })\n      }),\n    })\n  }\n\n  postCssNodeCache.set(rule, node)\n\n  return node\n}\n\nfunction bigSign(bigIntValue) {\n  return (bigIntValue > 0n) - (bigIntValue < 0n)\n}\n\nfunction isPlainObject(value) {\n  if (Object.prototype.toString.call(value) !== '[object Object]') {\n    return false\n  }\n\n  const prototype = Object.getPrototypeOf(value)\n  return prototype === null || prototype === Object.prototype\n}\n\n// workaround for minifier bug which splits selectors by commas,\n// even when they are escaped (e.g. \\,)\nfunction escapeCommas(className) {\n  return className.replace(/\\\\,/g, '\\\\2c ')\n}\n\nfunction escapeClassName(...args) {\n  return escapeCommas(tailwindUtils.escapeClassName(...args))\n}\n\nfunction nameClass(...args) {\n  return escapeCommas(tailwindUtils.nameClass(...args))\n}\n\n/**\n * Clone generated and/or cached nodes to ensure no future\n * postcss plugins can mutate the rules and mess up our cache\n *\n * @param {import('postcss').Node[]} nodes\n * */\nfunction cloneNodes(nodes) {\n  return nodes.map((node) => node.clone())\n}\n\nmodule.exports = {\n  toPostCssNode,\n  bigSign,\n  isPlainObject,\n  escapeClassName,\n  escapeCommas,\n  nameClass,\n  cloneNodes,\n}\n"]},"metadata":{},"sourceType":"script"}