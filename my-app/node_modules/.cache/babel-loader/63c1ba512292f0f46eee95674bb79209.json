{"ast":null,"code":"/* Generated by `npm run build`, do not edit! */\n\"use strict\";\n\nvar acorn = require(\"acorn\");\n\nvar tt = acorn.tokTypes;\n\nvar privateClassElements = require(\"../private-class-elements\");\n\nfunction maybeParseFieldValue(field) {\n  if (this.eat(tt.eq)) {\n    var oldInFieldValue = this._inFieldValue;\n    this._inFieldValue = true;\n    field.value = this.parseExpression();\n    this._inFieldValue = oldInFieldValue;\n  } else {\n    field.value = null;\n  }\n}\n\nmodule.exports = function (Parser) {\n  Parser = privateClassElements(Parser);\n  return /*@__PURE__*/function (Parser) {\n    function anonymous() {\n      Parser.apply(this, arguments);\n    }\n\n    if (Parser) anonymous.__proto__ = Parser;\n    anonymous.prototype = Object.create(Parser && Parser.prototype);\n    anonymous.prototype.constructor = anonymous;\n\n    anonymous.prototype.parseClassElement = function parseClassElement(_constructorAllowsSuper) {\n      if (this.options.ecmaVersion >= 8 && (this.type == tt.name || this.type == this.privateNameToken || this.type == tt.bracketL || this.type == tt.string)) {\n        var branch = this._branch();\n\n        if (branch.type == tt.bracketL) {\n          var count = 0;\n\n          do {\n            if (branch.eat(tt.bracketL)) {\n              ++count;\n            } else if (branch.eat(tt.bracketR)) {\n              --count;\n            } else {\n              branch.next();\n            }\n          } while (count > 0);\n        } else {\n          branch.next();\n        }\n\n        if (branch.type == tt.eq || branch.canInsertSemicolon() || branch.type == tt.semi) {\n          var node = this.startNode();\n\n          if (this.type == this.privateNameToken) {\n            this.parsePrivateClassElementName(node);\n          } else {\n            this.parsePropertyName(node);\n          }\n\n          if (node.key.type === \"Identifier\" && node.key.name === \"constructor\" || node.key.type === \"Literal\" && node.key.value === \"constructor\") {\n            this.raise(node.key.start, \"Classes may not have a field called constructor\");\n          }\n\n          maybeParseFieldValue.call(this, node);\n          this.finishNode(node, \"FieldDefinition\");\n          this.semicolon();\n          return node;\n        }\n      }\n\n      return Parser.prototype.parseClassElement.apply(this, arguments);\n    }; // Prohibit arguments in class field initializers\n\n\n    anonymous.prototype.parseIdent = function parseIdent(liberal, isBinding) {\n      var ident = Parser.prototype.parseIdent.call(this, liberal, isBinding);\n\n      if (this._inFieldValue && ident.name == \"arguments\") {\n        this.raise(ident.start, \"A class field initializer may not contain arguments\");\n      }\n\n      return ident;\n    };\n\n    return anonymous;\n  }(Parser);\n};","map":{"version":3,"sources":["/Users/seito/Documents/develop/count-jp/my-app/node_modules/acorn-node/lib/class-fields/index.js"],"names":["acorn","require","tt","tokTypes","privateClassElements","maybeParseFieldValue","field","eat","eq","oldInFieldValue","_inFieldValue","value","parseExpression","module","exports","Parser","anonymous","apply","arguments","__proto__","prototype","Object","create","constructor","parseClassElement","_constructorAllowsSuper","options","ecmaVersion","type","name","privateNameToken","bracketL","string","branch","_branch","count","bracketR","next","canInsertSemicolon","semi","node","startNode","parsePrivateClassElementName","parsePropertyName","key","raise","start","call","finishNode","semicolon","parseIdent","liberal","isBinding","ident"],"mappings":"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","sourcesContent":["/* Generated by `npm run build`, do not edit! */\n\n\"use strict\"\n\nvar acorn = require(\"acorn\")\nvar tt = acorn.tokTypes\nvar privateClassElements = require(\"../private-class-elements\")\n\nfunction maybeParseFieldValue(field) {\n  if (this.eat(tt.eq)) {\n    var oldInFieldValue = this._inFieldValue\n    this._inFieldValue = true\n    field.value = this.parseExpression()\n    this._inFieldValue = oldInFieldValue\n  } else { field.value = null }\n}\n\nmodule.exports = function(Parser) {\n  Parser = privateClassElements(Parser)\n  return /*@__PURE__*/(function (Parser) {\n    function anonymous () {\n      Parser.apply(this, arguments);\n    }\n\n    if ( Parser ) anonymous.__proto__ = Parser;\n    anonymous.prototype = Object.create( Parser && Parser.prototype );\n    anonymous.prototype.constructor = anonymous;\n\n    anonymous.prototype.parseClassElement = function parseClassElement (_constructorAllowsSuper) {\n      if (this.options.ecmaVersion >= 8 && (this.type == tt.name || this.type == this.privateNameToken || this.type == tt.bracketL || this.type == tt.string)) {\n        var branch = this._branch()\n        if (branch.type == tt.bracketL) {\n          var count = 0\n          do {\n            if (branch.eat(tt.bracketL)) { ++count }\n            else if (branch.eat(tt.bracketR)) { --count }\n            else { branch.next() }\n          } while (count > 0)\n        } else { branch.next() }\n        if (branch.type == tt.eq || branch.canInsertSemicolon() || branch.type == tt.semi) {\n          var node = this.startNode()\n          if (this.type == this.privateNameToken) {\n            this.parsePrivateClassElementName(node)\n          } else {\n            this.parsePropertyName(node)\n          }\n          if ((node.key.type === \"Identifier\" && node.key.name === \"constructor\") ||\n              (node.key.type === \"Literal\" && node.key.value === \"constructor\")) {\n            this.raise(node.key.start, \"Classes may not have a field called constructor\")\n          }\n          maybeParseFieldValue.call(this, node)\n          this.finishNode(node, \"FieldDefinition\")\n          this.semicolon()\n          return node\n        }\n      }\n\n      return Parser.prototype.parseClassElement.apply(this, arguments)\n    };\n\n    // Prohibit arguments in class field initializers\n    anonymous.prototype.parseIdent = function parseIdent (liberal, isBinding) {\n      var ident = Parser.prototype.parseIdent.call(this, liberal, isBinding)\n      if (this._inFieldValue && ident.name == \"arguments\") { this.raise(ident.start, \"A class field initializer may not contain arguments\") }\n      return ident\n    };\n\n    return anonymous;\n  }(Parser))\n}\n"]},"metadata":{},"sourceType":"script"}