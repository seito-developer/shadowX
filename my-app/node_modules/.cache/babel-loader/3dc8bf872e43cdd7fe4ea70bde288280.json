{"ast":null,"code":"/* Generated by `npm run build`, do not edit! */\n\"use strict\";\n\nvar skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\n\nvar tt = require(\"acorn\").tokTypes;\n\nmodule.exports = function (Parser) {\n  return /*@__PURE__*/function (Parser) {\n    function anonymous() {\n      Parser.apply(this, arguments);\n    }\n\n    if (Parser) anonymous.__proto__ = Parser;\n    anonymous.prototype = Object.create(Parser && Parser.prototype);\n    anonymous.prototype.constructor = anonymous;\n\n    anonymous.prototype.parseExport = function parseExport(node, exports) {\n      skipWhiteSpace.lastIndex = this.pos;\n      var skip = skipWhiteSpace.exec(this.input);\n      var next = this.input.charAt(this.pos + skip[0].length);\n\n      if (next !== \"*\") {\n        return Parser.prototype.parseExport.call(this, node, exports);\n      }\n\n      this.next();\n      var specifier = this.startNode();\n      this.expect(tt.star);\n\n      if (this.eatContextual(\"as\")) {\n        node.declaration = null;\n        specifier.exported = this.parseIdent(true);\n        this.checkExport(exports, specifier.exported.name, this.lastTokStart);\n        node.specifiers = [this.finishNode(specifier, \"ExportNamespaceSpecifier\")];\n      }\n\n      this.expectContextual(\"from\");\n\n      if (this.type !== tt.string) {\n        this.unexpected();\n      }\n\n      node.source = this.parseExprAtom();\n      this.semicolon();\n      return this.finishNode(node, node.specifiers ? \"ExportNamedDeclaration\" : \"ExportAllDeclaration\");\n    };\n\n    return anonymous;\n  }(Parser);\n};","map":{"version":3,"sources":["/Users/seito/Documents/develop/count-jp/my-app/node_modules/acorn-node/lib/export-ns-from/index.js"],"names":["skipWhiteSpace","tt","require","tokTypes","module","exports","Parser","anonymous","apply","arguments","__proto__","prototype","Object","create","constructor","parseExport","node","lastIndex","pos","skip","exec","input","next","charAt","length","call","specifier","startNode","expect","star","eatContextual","declaration","exported","parseIdent","checkExport","name","lastTokStart","specifiers","finishNode","expectContextual","type","string","unexpected","source","parseExprAtom","semicolon"],"mappings":"AAAA;AAEA;;AAEA,IAAIA,cAAc,GAAG,+BAArB;;AAEA,IAAIC,EAAE,GAAGC,OAAO,CAAC,OAAD,CAAP,CAAiBC,QAA1B;;AAEAC,MAAM,CAACC,OAAP,GAAiB,UAASC,MAAT,EAAiB;AAChC,SAAO,aAAc,UAAUA,MAAV,EAAkB;AACrC,aAASC,SAAT,GAAsB;AACpBD,MAAAA,MAAM,CAACE,KAAP,CAAa,IAAb,EAAmBC,SAAnB;AACD;;AAED,QAAKH,MAAL,EAAcC,SAAS,CAACG,SAAV,GAAsBJ,MAAtB;AACdC,IAAAA,SAAS,CAACI,SAAV,GAAsBC,MAAM,CAACC,MAAP,CAAeP,MAAM,IAAIA,MAAM,CAACK,SAAhC,CAAtB;AACAJ,IAAAA,SAAS,CAACI,SAAV,CAAoBG,WAApB,GAAkCP,SAAlC;;AAEAA,IAAAA,SAAS,CAACI,SAAV,CAAoBI,WAApB,GAAkC,SAASA,WAAT,CAAsBC,IAAtB,EAA4BX,OAA5B,EAAqC;AACrEL,MAAAA,cAAc,CAACiB,SAAf,GAA2B,KAAKC,GAAhC;AACA,UAAIC,IAAI,GAAGnB,cAAc,CAACoB,IAAf,CAAoB,KAAKC,KAAzB,CAAX;AACA,UAAIC,IAAI,GAAG,KAAKD,KAAL,CAAWE,MAAX,CAAkB,KAAKL,GAAL,GAAWC,IAAI,CAAC,CAAD,CAAJ,CAAQK,MAArC,CAAX;;AACA,UAAIF,IAAI,KAAK,GAAb,EAAkB;AAAE,eAAOhB,MAAM,CAACK,SAAP,CAAiBI,WAAjB,CAA6BU,IAA7B,CAAkC,IAAlC,EAAwCT,IAAxC,EAA8CX,OAA9C,CAAP;AAA+D;;AAEnF,WAAKiB,IAAL;AACA,UAAII,SAAS,GAAG,KAAKC,SAAL,EAAhB;AACA,WAAKC,MAAL,CAAY3B,EAAE,CAAC4B,IAAf;;AACA,UAAI,KAAKC,aAAL,CAAmB,IAAnB,CAAJ,EAA8B;AAC5Bd,QAAAA,IAAI,CAACe,WAAL,GAAmB,IAAnB;AACAL,QAAAA,SAAS,CAACM,QAAV,GAAqB,KAAKC,UAAL,CAAgB,IAAhB,CAArB;AACA,aAAKC,WAAL,CAAiB7B,OAAjB,EAA0BqB,SAAS,CAACM,QAAV,CAAmBG,IAA7C,EAAmD,KAAKC,YAAxD;AACApB,QAAAA,IAAI,CAACqB,UAAL,GAAkB,CAAC,KAAKC,UAAL,CAAgBZ,SAAhB,EAA2B,0BAA3B,CAAD,CAAlB;AACD;;AACD,WAAKa,gBAAL,CAAsB,MAAtB;;AACA,UAAI,KAAKC,IAAL,KAAcvC,EAAE,CAACwC,MAArB,EAA6B;AAAE,aAAKC,UAAL;AAAmB;;AAClD1B,MAAAA,IAAI,CAAC2B,MAAL,GAAc,KAAKC,aAAL,EAAd;AACA,WAAKC,SAAL;AACA,aAAO,KAAKP,UAAL,CAAgBtB,IAAhB,EAAsBA,IAAI,CAACqB,UAAL,GAAkB,wBAAlB,GAA6C,sBAAnE,CAAP;AACD,KApBD;;AAsBA,WAAO9B,SAAP;AACD,GAhCoB,CAgCnBD,MAhCmB,CAArB;AAiCD,CAlCD","sourcesContent":["/* Generated by `npm run build`, do not edit! */\n\n\"use strict\"\n\nvar skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g\n\nvar tt = require(\"acorn\").tokTypes\n\nmodule.exports = function(Parser) {\n  return /*@__PURE__*/(function (Parser) {\n    function anonymous () {\n      Parser.apply(this, arguments);\n    }\n\n    if ( Parser ) anonymous.__proto__ = Parser;\n    anonymous.prototype = Object.create( Parser && Parser.prototype );\n    anonymous.prototype.constructor = anonymous;\n\n    anonymous.prototype.parseExport = function parseExport (node, exports) {\n      skipWhiteSpace.lastIndex = this.pos\n      var skip = skipWhiteSpace.exec(this.input)\n      var next = this.input.charAt(this.pos + skip[0].length)\n      if (next !== \"*\") { return Parser.prototype.parseExport.call(this, node, exports) }\n\n      this.next()\n      var specifier = this.startNode()\n      this.expect(tt.star)\n      if (this.eatContextual(\"as\")) {\n        node.declaration = null\n        specifier.exported = this.parseIdent(true)\n        this.checkExport(exports, specifier.exported.name, this.lastTokStart)\n        node.specifiers = [this.finishNode(specifier, \"ExportNamespaceSpecifier\")]\n      }\n      this.expectContextual(\"from\")\n      if (this.type !== tt.string) { this.unexpected() }\n      node.source = this.parseExprAtom()\n      this.semicolon()\n      return this.finishNode(node, node.specifiers ? \"ExportNamedDeclaration\" : \"ExportAllDeclaration\")\n    };\n\n    return anonymous;\n  }(Parser))\n}\n"]},"metadata":{},"sourceType":"script"}