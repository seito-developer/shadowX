{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n/* global window */\n// We import the files used inside the Node environment which are rewritten\n// for browsers using the rules defined in the package.json\n\n\nvar _error = require(\"./error\");\n\nvar _error2 = _interopRequireDefault(_error);\n\nvar _extend = require(\"extend\");\n\nvar _extend2 = _interopRequireDefault(_extend);\n\nvar _jsBase = require(\"js-base64\");\n\nvar _request = require(\"./node/request\");\n\nvar _source = require(\"./node/source\");\n\nvar _storage = require(\"./node/storage\");\n\nvar _fingerprint = require(\"./node/fingerprint\");\n\nvar _fingerprint2 = _interopRequireDefault(_fingerprint);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar defaultOptions = {\n  endpoint: null,\n  fingerprint: _fingerprint2.default,\n  resume: true,\n  onProgress: null,\n  onChunkComplete: null,\n  onSuccess: null,\n  onError: null,\n  headers: {},\n  chunkSize: Infinity,\n  withCredentials: false,\n  uploadUrl: null,\n  uploadSize: null,\n  overridePatchMethod: false,\n  retryDelays: null,\n  removeFingerprintOnSuccess: false,\n  uploadLengthDeferred: false,\n  urlStorage: null,\n  fileReader: null,\n  uploadDataDuringCreation: false\n};\n\nvar Upload = function () {\n  function Upload(file, options) {\n    _classCallCheck(this, Upload);\n\n    this.options = (0, _extend2.default)(true, {}, defaultOptions, options); // The storage module used to store URLs\n\n    this._storage = this.options.urlStorage; // The underlying File/Blob object\n\n    this.file = file; // The URL against which the file will be uploaded\n\n    this.url = null; // The underlying XHR object for the current PATCH request\n\n    this._xhr = null; // The fingerpinrt for the current file (set after start())\n\n    this._fingerprint = null; // The offset used in the current PATCH request\n\n    this._offset = null; // True if the current PATCH request has been aborted\n\n    this._aborted = false; // The file's size in bytes\n\n    this._size = null; // The Source object which will wrap around the given file and provides us\n    // with a unified interface for getting its size and slice chunks from its\n    // content allowing us to easily handle Files, Blobs, Buffers and Streams.\n\n    this._source = null; // The current count of attempts which have been made. Null indicates none.\n\n    this._retryAttempt = 0; // The timeout's ID which is used to delay the next retry\n\n    this._retryTimeout = null; // The offset of the remote upload before the latest attempt was started.\n\n    this._offsetBeforeRetry = 0;\n  }\n\n  _createClass(Upload, [{\n    key: \"start\",\n    value: function start() {\n      var _this = this;\n\n      var file = this.file;\n\n      if (!file) {\n        this._emitError(new Error(\"tus: no file or stream to upload provided\"));\n\n        return;\n      }\n\n      if (!this.options.endpoint && !this.options.uploadUrl) {\n        this._emitError(new Error(\"tus: neither an endpoint or an upload URL is provided\"));\n\n        return;\n      }\n\n      if (this.options.resume && this._storage == null) {\n        this._storage = (0, _storage.getStorage)();\n      }\n\n      if (this._source) {\n        this._start(this._source);\n      } else {\n        var fileReader = this.options.fileReader || _source.getSource;\n        fileReader(file, this.options.chunkSize, function (err, source) {\n          if (err) {\n            _this._emitError(err);\n\n            return;\n          }\n\n          _this._source = source;\n\n          _this._start(source);\n        });\n      }\n    }\n  }, {\n    key: \"_start\",\n    value: function _start(source) {\n      var _this2 = this;\n\n      var file = this.file; // First, we look at the uploadLengthDeferred option.\n      // Next, we check if the caller has supplied a manual upload size.\n      // Finally, we try to use the calculated size from the source object.\n\n      if (this.options.uploadLengthDeferred) {\n        this._size = null;\n      } else if (this.options.uploadSize != null) {\n        this._size = +this.options.uploadSize;\n\n        if (isNaN(this._size)) {\n          this._emitError(new Error(\"tus: cannot convert `uploadSize` option into a number\"));\n\n          return;\n        }\n      } else {\n        this._size = source.size;\n\n        if (this._size == null) {\n          this._emitError(new Error(\"tus: cannot automatically derive upload's size from input and must be specified manually using the `uploadSize` option\"));\n\n          return;\n        }\n      }\n\n      var retryDelays = this.options.retryDelays;\n\n      if (retryDelays != null) {\n        if (Object.prototype.toString.call(retryDelays) !== \"[object Array]\") {\n          this._emitError(new Error(\"tus: the `retryDelays` option must either be an array or null\"));\n\n          return;\n        } else {\n          var errorCallback = this.options.onError;\n\n          this.options.onError = function (err) {\n            // Restore the original error callback which may have been set.\n            _this2.options.onError = errorCallback; // We will reset the attempt counter if\n            // - we were already able to connect to the server (offset != null) and\n            // - we were able to upload a small chunk of data to the server\n\n            var shouldResetDelays = _this2._offset != null && _this2._offset > _this2._offsetBeforeRetry;\n\n            if (shouldResetDelays) {\n              _this2._retryAttempt = 0;\n            }\n\n            var isOnline = true;\n\n            if (typeof window !== \"undefined\" && \"navigator\" in window && window.navigator.onLine === false) {\n              isOnline = false;\n            } // We only attempt a retry if\n            // - we didn't exceed the maxium number of retries, yet, and\n            // - this error was caused by a request or it's response and\n            // - the error is server error (i.e. no a status 4xx or a 409 or 423) and\n            // - the browser does not indicate that we are offline\n\n\n            var status = err.originalRequest ? err.originalRequest.status : 0;\n            var isServerError = !inStatusCategory(status, 400) || status === 409 || status === 423;\n            var shouldRetry = _this2._retryAttempt < retryDelays.length && err.originalRequest != null && isServerError && isOnline;\n\n            if (!shouldRetry) {\n              _this2._emitError(err);\n\n              return;\n            }\n\n            var delay = retryDelays[_this2._retryAttempt++];\n            _this2._offsetBeforeRetry = _this2._offset;\n            _this2.options.uploadUrl = _this2.url;\n            _this2._retryTimeout = setTimeout(function () {\n              _this2.start();\n            }, delay);\n          };\n        }\n      } // Reset the aborted flag when the upload is started or else the\n      // _startUpload will stop before sending a request if the upload has been\n      // aborted previously.\n\n\n      this._aborted = false; // The upload had been started previously and we should reuse this URL.\n\n      if (this.url != null) {\n        this._resumeUpload();\n\n        return;\n      } // A URL has manually been specified, so we try to resume\n\n\n      if (this.options.uploadUrl != null) {\n        this.url = this.options.uploadUrl;\n\n        this._resumeUpload();\n\n        return;\n      } // Try to find the endpoint for the file in the storage\n\n\n      if (this._hasStorage()) {\n        this.options.fingerprint(file, this.options, function (err, fingerprintValue) {\n          if (err) {\n            _this2._emitError(err);\n\n            return;\n          }\n\n          _this2._fingerprint = fingerprintValue;\n\n          _this2._storage.getItem(_this2._fingerprint, function (err, resumedUrl) {\n            if (err) {\n              _this2._emitError(err);\n\n              return;\n            }\n\n            if (resumedUrl != null) {\n              _this2.url = resumedUrl;\n\n              _this2._resumeUpload();\n            } else {\n              _this2._createUpload();\n            }\n          });\n        });\n      } else {\n        // An upload has not started for the file yet, so we start a new one\n        this._createUpload();\n      }\n    }\n  }, {\n    key: \"abort\",\n    value: function abort(shouldTerminate, cb) {\n      var _this3 = this;\n\n      if (this._xhr !== null) {\n        this._xhr.abort();\n\n        this._source.close();\n      }\n\n      this._aborted = true;\n\n      if (this._retryTimeout != null) {\n        clearTimeout(this._retryTimeout);\n        this._retryTimeout = null;\n      }\n\n      cb = cb || function () {};\n\n      if (shouldTerminate) {\n        Upload.terminate(this.url, this.options, function (err, xhr) {\n          if (err) {\n            return cb(err, xhr);\n          }\n\n          _this3._hasStorage() ? _this3._storage.removeItem(_this3._fingerprint, cb) : cb();\n        });\n      } else {\n        cb();\n      }\n    }\n  }, {\n    key: \"_hasStorage\",\n    value: function _hasStorage() {\n      return this.options.resume && this._storage;\n    }\n  }, {\n    key: \"_emitXhrError\",\n    value: function _emitXhrError(xhr, err, causingErr) {\n      this._emitError(new _error2.default(err, causingErr, xhr));\n    }\n  }, {\n    key: \"_emitError\",\n    value: function _emitError(err) {\n      if (typeof this.options.onError === \"function\") {\n        this.options.onError(err);\n      } else {\n        throw err;\n      }\n    }\n  }, {\n    key: \"_emitSuccess\",\n    value: function _emitSuccess() {\n      if (typeof this.options.onSuccess === \"function\") {\n        this.options.onSuccess();\n      }\n    }\n    /**\n     * Publishes notification when data has been sent to the server. This\n     * data may not have been accepted by the server yet.\n     * @param  {number} bytesSent  Number of bytes sent to the server.\n     * @param  {number} bytesTotal Total number of bytes to be sent to the server.\n     */\n\n  }, {\n    key: \"_emitProgress\",\n    value: function _emitProgress(bytesSent, bytesTotal) {\n      if (typeof this.options.onProgress === \"function\") {\n        this.options.onProgress(bytesSent, bytesTotal);\n      }\n    }\n    /**\n     * Publishes notification when a chunk of data has been sent to the server\n     * and accepted by the server.\n     * @param  {number} chunkSize  Size of the chunk that was accepted by the\n     *                             server.\n     * @param  {number} bytesAccepted Total number of bytes that have been\n     *                                accepted by the server.\n     * @param  {number} bytesTotal Total number of bytes to be sent to the server.\n     */\n\n  }, {\n    key: \"_emitChunkComplete\",\n    value: function _emitChunkComplete(chunkSize, bytesAccepted, bytesTotal) {\n      if (typeof this.options.onChunkComplete === \"function\") {\n        this.options.onChunkComplete(chunkSize, bytesAccepted, bytesTotal);\n      }\n    }\n    /**\n     * Set the headers used in the request and the withCredentials property\n     * as defined in the options\n     *\n     * @param {XMLHttpRequest} xhr\n     */\n\n  }, {\n    key: \"_setupXHR\",\n    value: function _setupXHR(xhr) {\n      this._xhr = xhr;\n      setupXHR(xhr, this.options);\n    }\n    /**\n     * Create a new upload using the creation extension by sending a POST\n     * request to the endpoint. After successful creation the file will be\n     * uploaded\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_createUpload\",\n    value: function _createUpload() {\n      var _this4 = this;\n\n      if (!this.options.endpoint) {\n        this._emitError(new Error(\"tus: unable to create upload because no endpoint is provided\"));\n\n        return;\n      }\n\n      var xhr = (0, _request.newRequest)();\n      xhr.open(\"POST\", this.options.endpoint, true);\n\n      xhr.onload = function () {\n        if (!inStatusCategory(xhr.status, 200)) {\n          _this4._emitXhrError(xhr, new Error(\"tus: unexpected response while creating upload\"));\n\n          return;\n        }\n\n        var location = xhr.getResponseHeader(\"Location\");\n\n        if (location == null) {\n          _this4._emitXhrError(xhr, new Error(\"tus: invalid or missing Location header\"));\n\n          return;\n        }\n\n        _this4.url = (0, _request.resolveUrl)(_this4.options.endpoint, location);\n\n        if (_this4._size === 0) {\n          // Nothing to upload and file was successfully created\n          _this4._emitSuccess();\n\n          _this4._source.close();\n\n          return;\n        }\n\n        if (_this4._hasStorage()) {\n          _this4._storage.setItem(_this4._fingerprint, _this4.url, function (err) {\n            if (err) {\n              _this4._emitError(err);\n            }\n          });\n        }\n\n        if (_this4.options.uploadDataDuringCreation) {\n          _this4._handleUploadResponse(xhr);\n        } else {\n          _this4._offset = 0;\n\n          _this4._startUpload();\n        }\n      };\n\n      xhr.onerror = function (err) {\n        _this4._emitXhrError(xhr, new Error(\"tus: failed to create upload\"), err);\n      };\n\n      this._setupXHR(xhr);\n\n      if (this.options.uploadLengthDeferred) {\n        xhr.setRequestHeader(\"Upload-Defer-Length\", 1);\n      } else {\n        xhr.setRequestHeader(\"Upload-Length\", this._size);\n      } // Add metadata if values have been added\n\n\n      var metadata = encodeMetadata(this.options.metadata);\n\n      if (metadata !== \"\") {\n        xhr.setRequestHeader(\"Upload-Metadata\", metadata);\n      }\n\n      if (this.options.uploadDataDuringCreation && !this.options.uploadLengthDeferred) {\n        this._offset = 0;\n\n        this._addChunkToRequest(xhr);\n      } else {\n        xhr.send(null);\n      }\n    }\n    /*\n     * Try to resume an existing upload. First a HEAD request will be sent\n     * to retrieve the offset. If the request fails a new upload will be\n     * created. In the case of a successful response the file will be uploaded.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_resumeUpload\",\n    value: function _resumeUpload() {\n      var _this5 = this;\n\n      var xhr = (0, _request.newRequest)();\n      xhr.open(\"HEAD\", this.url, true);\n\n      xhr.onload = function () {\n        if (!inStatusCategory(xhr.status, 200)) {\n          if (_this5._hasStorage() && inStatusCategory(xhr.status, 400)) {\n            // Remove stored fingerprint and corresponding endpoint,\n            // on client errors since the file can not be found\n            _this5._storage.removeItem(_this5._fingerprint, function (err) {\n              if (err) {\n                _this5._emitError(err);\n              }\n            });\n          } // If the upload is locked (indicated by the 423 Locked status code), we\n          // emit an error instead of directly starting a new upload. This way the\n          // retry logic can catch the error and will retry the upload. An upload\n          // is usually locked for a short period of time and will be available\n          // afterwards.\n\n\n          if (xhr.status === 423) {\n            _this5._emitXhrError(xhr, new Error(\"tus: upload is currently locked; retry later\"));\n\n            return;\n          }\n\n          if (!_this5.options.endpoint) {\n            // Don't attempt to create a new upload if no endpoint is provided.\n            _this5._emitXhrError(xhr, new Error(\"tus: unable to resume upload (new upload cannot be created without an endpoint)\"));\n\n            return;\n          } // Try to create a new upload\n\n\n          _this5.url = null;\n\n          _this5._createUpload();\n\n          return;\n        }\n\n        var offset = parseInt(xhr.getResponseHeader(\"Upload-Offset\"), 10);\n\n        if (isNaN(offset)) {\n          _this5._emitXhrError(xhr, new Error(\"tus: invalid or missing offset value\"));\n\n          return;\n        }\n\n        var length = parseInt(xhr.getResponseHeader(\"Upload-Length\"), 10);\n\n        if (isNaN(length) && !_this5.options.uploadLengthDeferred) {\n          _this5._emitXhrError(xhr, new Error(\"tus: invalid or missing length value\"));\n\n          return;\n        } // Upload has already been completed and we do not need to send additional\n        // data to the server\n\n\n        if (offset === length) {\n          _this5._emitProgress(length, length);\n\n          _this5._emitSuccess();\n\n          return;\n        }\n\n        _this5._offset = offset;\n\n        _this5._startUpload();\n      };\n\n      xhr.onerror = function (err) {\n        _this5._emitXhrError(xhr, new Error(\"tus: failed to resume upload\"), err);\n      };\n\n      this._setupXHR(xhr);\n\n      xhr.send(null);\n    }\n    /**\n     * Start uploading the file using PATCH requests. The file will be divided\n     * into chunks as specified in the chunkSize option. During the upload\n     * the onProgress event handler may be invoked multiple times.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_startUpload\",\n    value: function _startUpload() {\n      var _this6 = this; // If the upload has been aborted, we will not send the next PATCH request.\n      // This is important if the abort method was called during a callback, such\n      // as onChunkComplete or onProgress.\n\n\n      if (this._aborted) {\n        return;\n      }\n\n      var xhr = (0, _request.newRequest)(); // Some browser and servers may not support the PATCH method. For those\n      // cases, you can tell tus-js-client to use a POST request with the\n      // X-HTTP-Method-Override header for simulating a PATCH request.\n\n      if (this.options.overridePatchMethod) {\n        xhr.open(\"POST\", this.url, true);\n        xhr.setRequestHeader(\"X-HTTP-Method-Override\", \"PATCH\");\n      } else {\n        xhr.open(\"PATCH\", this.url, true);\n      }\n\n      xhr.onload = function () {\n        if (!inStatusCategory(xhr.status, 200)) {\n          _this6._emitXhrError(xhr, new Error(\"tus: unexpected response while uploading chunk\"));\n\n          return;\n        }\n\n        _this6._handleUploadResponse(xhr);\n      };\n\n      xhr.onerror = function (err) {\n        // Don't emit an error if the upload was aborted manually\n        if (_this6._aborted) {\n          return;\n        }\n\n        _this6._emitXhrError(xhr, new Error(\"tus: failed to upload chunk at offset \" + _this6._offset), err);\n      };\n\n      this._setupXHR(xhr);\n\n      xhr.setRequestHeader(\"Upload-Offset\", this._offset);\n\n      this._addChunkToRequest(xhr);\n    }\n    /**\n     * _addChunktoRequest reads a chunk from the source and sends it using the\n     * supplied XHR object. It will not handle the response.\n     */\n\n  }, {\n    key: \"_addChunkToRequest\",\n    value: function _addChunkToRequest(xhr) {\n      var _this7 = this; // Test support for progress events before attaching an event listener\n\n\n      if (\"upload\" in xhr) {\n        xhr.upload.onprogress = function (e) {\n          if (!e.lengthComputable) {\n            return;\n          }\n\n          _this7._emitProgress(start + e.loaded, _this7._size);\n        };\n      }\n\n      xhr.setRequestHeader(\"Content-Type\", \"application/offset+octet-stream\");\n      var start = this._offset;\n      var end = this._offset + this.options.chunkSize; // The specified chunkSize may be Infinity or the calcluated end position\n      // may exceed the file's size. In both cases, we limit the end position to\n      // the input's total size for simpler calculations and correctness.\n\n      if ((end === Infinity || end > this._size) && !this.options.uploadLengthDeferred) {\n        end = this._size;\n      }\n\n      this._source.slice(start, end, function (err, value, complete) {\n        if (err) {\n          _this7._emitError(err);\n\n          return;\n        }\n\n        if (_this7.options.uploadLengthDeferred) {\n          if (complete) {\n            _this7._size = _this7._offset + (value && value.size ? value.size : 0);\n            xhr.setRequestHeader(\"Upload-Length\", _this7._size);\n          }\n        }\n\n        if (value === null) {\n          xhr.send();\n        } else {\n          xhr.send(value);\n\n          _this7._emitProgress(_this7._offset, _this7._size);\n        }\n      });\n    }\n    /**\n     * _handleUploadResponse is used by requests that haven been sent using _addChunkToRequest\n     * and already have received a response.\n     */\n\n  }, {\n    key: \"_handleUploadResponse\",\n    value: function _handleUploadResponse(xhr) {\n      var _this8 = this;\n\n      var offset = parseInt(xhr.getResponseHeader(\"Upload-Offset\"), 10);\n\n      if (isNaN(offset)) {\n        this._emitXhrError(xhr, new Error(\"tus: invalid or missing offset value\"));\n\n        return;\n      }\n\n      this._emitProgress(offset, this._size);\n\n      this._emitChunkComplete(offset - this._offset, offset, this._size);\n\n      this._offset = offset;\n\n      if (offset == this._size) {\n        if (this.options.removeFingerprintOnSuccess && this.options.resume) {\n          // Remove stored fingerprint and corresponding endpoint. This causes\n          // new upload of the same file must be treated as a different file.\n          this._storage.removeItem(this._fingerprint, function (err) {\n            if (err) {\n              _this8._emitError(err);\n            }\n          });\n        } // Yay, finally done :)\n\n\n        this._emitSuccess();\n\n        this._source.close();\n\n        return;\n      }\n\n      this._startUpload();\n    }\n  }], [{\n    key: \"terminate\",\n    value: function terminate(url, options, cb) {\n      if (typeof options !== \"function\" && typeof cb !== \"function\") {\n        throw new Error(\"tus: a callback function must be specified\");\n      }\n\n      if (typeof options === \"function\") {\n        cb = options;\n        options = {};\n      }\n\n      var xhr = (0, _request.newRequest)();\n      xhr.open(\"DELETE\", url, true);\n\n      xhr.onload = function () {\n        if (xhr.status !== 204) {\n          cb(new _error2.default(new Error(\"tus: unexpected response while terminating upload\"), null, xhr));\n          return;\n        }\n\n        cb();\n      };\n\n      xhr.onerror = function (err) {\n        cb(new _error2.default(err, new Error(\"tus: failed to terminate upload\"), xhr));\n      };\n\n      setupXHR(xhr, options);\n      xhr.send(null);\n    }\n  }]);\n\n  return Upload;\n}();\n\nfunction encodeMetadata(metadata) {\n  var encoded = [];\n\n  for (var key in metadata) {\n    encoded.push(key + \" \" + _jsBase.Base64.encode(metadata[key]));\n  }\n\n  return encoded.join(\",\");\n}\n/**\n * Checks whether a given status is in the range of the expected category.\n * For example, only a status between 200 and 299 will satisfy the category 200.\n *\n * @api private\n */\n\n\nfunction inStatusCategory(status, category) {\n  return status >= category && status < category + 100;\n}\n\nfunction setupXHR(xhr, options) {\n  xhr.setRequestHeader(\"Tus-Resumable\", \"1.0.0\");\n  var headers = options.headers || {};\n\n  for (var name in headers) {\n    xhr.setRequestHeader(name, headers[name]);\n  }\n\n  xhr.withCredentials = options.withCredentials;\n}\n\nUpload.defaultOptions = defaultOptions;\nexports.default = Upload;","map":{"version":3,"sources":["/Users/seito/Documents/develop/shadowX/node_modules/tus-js-client/lib.es5/upload.js"],"names":["Object","defineProperty","exports","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","Constructor","protoProps","staticProps","prototype","_error","require","_error2","_interopRequireDefault","_extend","_extend2","_jsBase","_request","_source","_storage","_fingerprint","_fingerprint2","obj","__esModule","default","_classCallCheck","instance","TypeError","defaultOptions","endpoint","fingerprint","resume","onProgress","onChunkComplete","onSuccess","onError","headers","chunkSize","Infinity","withCredentials","uploadUrl","uploadSize","overridePatchMethod","retryDelays","removeFingerprintOnSuccess","uploadLengthDeferred","urlStorage","fileReader","uploadDataDuringCreation","Upload","file","options","url","_xhr","_offset","_aborted","_size","_retryAttempt","_retryTimeout","_offsetBeforeRetry","start","_this","_emitError","Error","getStorage","_start","getSource","err","source","_this2","isNaN","size","toString","call","errorCallback","shouldResetDelays","isOnline","window","navigator","onLine","status","originalRequest","isServerError","inStatusCategory","shouldRetry","delay","setTimeout","_resumeUpload","_hasStorage","fingerprintValue","getItem","resumedUrl","_createUpload","abort","shouldTerminate","cb","_this3","close","clearTimeout","terminate","xhr","removeItem","_emitXhrError","causingErr","_emitSuccess","_emitProgress","bytesSent","bytesTotal","_emitChunkComplete","bytesAccepted","_setupXHR","setupXHR","_this4","newRequest","open","onload","location","getResponseHeader","resolveUrl","setItem","_handleUploadResponse","_startUpload","onerror","setRequestHeader","metadata","encodeMetadata","_addChunkToRequest","send","_this5","offset","parseInt","_this6","_this7","upload","onprogress","e","lengthComputable","loaded","end","slice","complete","_this8","encoded","push","Base64","encode","join","category","name"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* global window */\n\n\n// We import the files used inside the Node environment which are rewritten\n// for browsers using the rules defined in the package.json\n\n\nvar _error = require(\"./error\");\n\nvar _error2 = _interopRequireDefault(_error);\n\nvar _extend = require(\"extend\");\n\nvar _extend2 = _interopRequireDefault(_extend);\n\nvar _jsBase = require(\"js-base64\");\n\nvar _request = require(\"./node/request\");\n\nvar _source = require(\"./node/source\");\n\nvar _storage = require(\"./node/storage\");\n\nvar _fingerprint = require(\"./node/fingerprint\");\n\nvar _fingerprint2 = _interopRequireDefault(_fingerprint);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar defaultOptions = {\n  endpoint: null,\n  fingerprint: _fingerprint2.default,\n  resume: true,\n  onProgress: null,\n  onChunkComplete: null,\n  onSuccess: null,\n  onError: null,\n  headers: {},\n  chunkSize: Infinity,\n  withCredentials: false,\n  uploadUrl: null,\n  uploadSize: null,\n  overridePatchMethod: false,\n  retryDelays: null,\n  removeFingerprintOnSuccess: false,\n  uploadLengthDeferred: false,\n  urlStorage: null,\n  fileReader: null,\n  uploadDataDuringCreation: false\n};\n\nvar Upload = function () {\n  function Upload(file, options) {\n    _classCallCheck(this, Upload);\n\n    this.options = (0, _extend2.default)(true, {}, defaultOptions, options);\n\n    // The storage module used to store URLs\n    this._storage = this.options.urlStorage;\n\n    // The underlying File/Blob object\n    this.file = file;\n\n    // The URL against which the file will be uploaded\n    this.url = null;\n\n    // The underlying XHR object for the current PATCH request\n    this._xhr = null;\n\n    // The fingerpinrt for the current file (set after start())\n    this._fingerprint = null;\n\n    // The offset used in the current PATCH request\n    this._offset = null;\n\n    // True if the current PATCH request has been aborted\n    this._aborted = false;\n\n    // The file's size in bytes\n    this._size = null;\n\n    // The Source object which will wrap around the given file and provides us\n    // with a unified interface for getting its size and slice chunks from its\n    // content allowing us to easily handle Files, Blobs, Buffers and Streams.\n    this._source = null;\n\n    // The current count of attempts which have been made. Null indicates none.\n    this._retryAttempt = 0;\n\n    // The timeout's ID which is used to delay the next retry\n    this._retryTimeout = null;\n\n    // The offset of the remote upload before the latest attempt was started.\n    this._offsetBeforeRetry = 0;\n  }\n\n  _createClass(Upload, [{\n    key: \"start\",\n    value: function start() {\n      var _this = this;\n\n      var file = this.file;\n\n      if (!file) {\n        this._emitError(new Error(\"tus: no file or stream to upload provided\"));\n        return;\n      }\n\n      if (!this.options.endpoint && !this.options.uploadUrl) {\n        this._emitError(new Error(\"tus: neither an endpoint or an upload URL is provided\"));\n        return;\n      }\n\n      if (this.options.resume && this._storage == null) {\n        this._storage = (0, _storage.getStorage)();\n      }\n\n      if (this._source) {\n        this._start(this._source);\n      } else {\n        var fileReader = this.options.fileReader || _source.getSource;\n        fileReader(file, this.options.chunkSize, function (err, source) {\n          if (err) {\n            _this._emitError(err);\n            return;\n          }\n\n          _this._source = source;\n          _this._start(source);\n        });\n      }\n    }\n  }, {\n    key: \"_start\",\n    value: function _start(source) {\n      var _this2 = this;\n\n      var file = this.file;\n\n      // First, we look at the uploadLengthDeferred option.\n      // Next, we check if the caller has supplied a manual upload size.\n      // Finally, we try to use the calculated size from the source object.\n      if (this.options.uploadLengthDeferred) {\n        this._size = null;\n      } else if (this.options.uploadSize != null) {\n        this._size = +this.options.uploadSize;\n        if (isNaN(this._size)) {\n          this._emitError(new Error(\"tus: cannot convert `uploadSize` option into a number\"));\n          return;\n        }\n      } else {\n        this._size = source.size;\n        if (this._size == null) {\n          this._emitError(new Error(\"tus: cannot automatically derive upload's size from input and must be specified manually using the `uploadSize` option\"));\n          return;\n        }\n      }\n\n      var retryDelays = this.options.retryDelays;\n      if (retryDelays != null) {\n        if (Object.prototype.toString.call(retryDelays) !== \"[object Array]\") {\n          this._emitError(new Error(\"tus: the `retryDelays` option must either be an array or null\"));\n          return;\n        } else {\n          var errorCallback = this.options.onError;\n          this.options.onError = function (err) {\n            // Restore the original error callback which may have been set.\n            _this2.options.onError = errorCallback;\n\n            // We will reset the attempt counter if\n            // - we were already able to connect to the server (offset != null) and\n            // - we were able to upload a small chunk of data to the server\n            var shouldResetDelays = _this2._offset != null && _this2._offset > _this2._offsetBeforeRetry;\n            if (shouldResetDelays) {\n              _this2._retryAttempt = 0;\n            }\n\n            var isOnline = true;\n            if (typeof window !== \"undefined\" && \"navigator\" in window && window.navigator.onLine === false) {\n              isOnline = false;\n            }\n\n            // We only attempt a retry if\n            // - we didn't exceed the maxium number of retries, yet, and\n            // - this error was caused by a request or it's response and\n            // - the error is server error (i.e. no a status 4xx or a 409 or 423) and\n            // - the browser does not indicate that we are offline\n            var status = err.originalRequest ? err.originalRequest.status : 0;\n            var isServerError = !inStatusCategory(status, 400) || status === 409 || status === 423;\n            var shouldRetry = _this2._retryAttempt < retryDelays.length && err.originalRequest != null && isServerError && isOnline;\n\n            if (!shouldRetry) {\n              _this2._emitError(err);\n              return;\n            }\n\n            var delay = retryDelays[_this2._retryAttempt++];\n\n            _this2._offsetBeforeRetry = _this2._offset;\n            _this2.options.uploadUrl = _this2.url;\n\n            _this2._retryTimeout = setTimeout(function () {\n              _this2.start();\n            }, delay);\n          };\n        }\n      }\n\n      // Reset the aborted flag when the upload is started or else the\n      // _startUpload will stop before sending a request if the upload has been\n      // aborted previously.\n      this._aborted = false;\n\n      // The upload had been started previously and we should reuse this URL.\n      if (this.url != null) {\n        this._resumeUpload();\n        return;\n      }\n\n      // A URL has manually been specified, so we try to resume\n      if (this.options.uploadUrl != null) {\n        this.url = this.options.uploadUrl;\n        this._resumeUpload();\n        return;\n      }\n\n      // Try to find the endpoint for the file in the storage\n      if (this._hasStorage()) {\n        this.options.fingerprint(file, this.options, function (err, fingerprintValue) {\n          if (err) {\n            _this2._emitError(err);\n            return;\n          }\n\n          _this2._fingerprint = fingerprintValue;\n          _this2._storage.getItem(_this2._fingerprint, function (err, resumedUrl) {\n            if (err) {\n              _this2._emitError(err);\n              return;\n            }\n\n            if (resumedUrl != null) {\n              _this2.url = resumedUrl;\n              _this2._resumeUpload();\n            } else {\n              _this2._createUpload();\n            }\n          });\n        });\n      } else {\n        // An upload has not started for the file yet, so we start a new one\n        this._createUpload();\n      }\n    }\n  }, {\n    key: \"abort\",\n    value: function abort(shouldTerminate, cb) {\n      var _this3 = this;\n\n      if (this._xhr !== null) {\n        this._xhr.abort();\n        this._source.close();\n      }\n      this._aborted = true;\n\n      if (this._retryTimeout != null) {\n        clearTimeout(this._retryTimeout);\n        this._retryTimeout = null;\n      }\n\n      cb = cb || function () {};\n      if (shouldTerminate) {\n        Upload.terminate(this.url, this.options, function (err, xhr) {\n          if (err) {\n            return cb(err, xhr);\n          }\n\n          _this3._hasStorage() ? _this3._storage.removeItem(_this3._fingerprint, cb) : cb();\n        });\n      } else {\n        cb();\n      }\n    }\n  }, {\n    key: \"_hasStorage\",\n    value: function _hasStorage() {\n      return this.options.resume && this._storage;\n    }\n  }, {\n    key: \"_emitXhrError\",\n    value: function _emitXhrError(xhr, err, causingErr) {\n      this._emitError(new _error2.default(err, causingErr, xhr));\n    }\n  }, {\n    key: \"_emitError\",\n    value: function _emitError(err) {\n      if (typeof this.options.onError === \"function\") {\n        this.options.onError(err);\n      } else {\n        throw err;\n      }\n    }\n  }, {\n    key: \"_emitSuccess\",\n    value: function _emitSuccess() {\n      if (typeof this.options.onSuccess === \"function\") {\n        this.options.onSuccess();\n      }\n    }\n\n    /**\n     * Publishes notification when data has been sent to the server. This\n     * data may not have been accepted by the server yet.\n     * @param  {number} bytesSent  Number of bytes sent to the server.\n     * @param  {number} bytesTotal Total number of bytes to be sent to the server.\n     */\n\n  }, {\n    key: \"_emitProgress\",\n    value: function _emitProgress(bytesSent, bytesTotal) {\n      if (typeof this.options.onProgress === \"function\") {\n        this.options.onProgress(bytesSent, bytesTotal);\n      }\n    }\n\n    /**\n     * Publishes notification when a chunk of data has been sent to the server\n     * and accepted by the server.\n     * @param  {number} chunkSize  Size of the chunk that was accepted by the\n     *                             server.\n     * @param  {number} bytesAccepted Total number of bytes that have been\n     *                                accepted by the server.\n     * @param  {number} bytesTotal Total number of bytes to be sent to the server.\n     */\n\n  }, {\n    key: \"_emitChunkComplete\",\n    value: function _emitChunkComplete(chunkSize, bytesAccepted, bytesTotal) {\n      if (typeof this.options.onChunkComplete === \"function\") {\n        this.options.onChunkComplete(chunkSize, bytesAccepted, bytesTotal);\n      }\n    }\n\n    /**\n     * Set the headers used in the request and the withCredentials property\n     * as defined in the options\n     *\n     * @param {XMLHttpRequest} xhr\n     */\n\n  }, {\n    key: \"_setupXHR\",\n    value: function _setupXHR(xhr) {\n      this._xhr = xhr;\n      setupXHR(xhr, this.options);\n    }\n\n    /**\n     * Create a new upload using the creation extension by sending a POST\n     * request to the endpoint. After successful creation the file will be\n     * uploaded\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_createUpload\",\n    value: function _createUpload() {\n      var _this4 = this;\n\n      if (!this.options.endpoint) {\n        this._emitError(new Error(\"tus: unable to create upload because no endpoint is provided\"));\n        return;\n      }\n\n      var xhr = (0, _request.newRequest)();\n      xhr.open(\"POST\", this.options.endpoint, true);\n\n      xhr.onload = function () {\n        if (!inStatusCategory(xhr.status, 200)) {\n          _this4._emitXhrError(xhr, new Error(\"tus: unexpected response while creating upload\"));\n          return;\n        }\n\n        var location = xhr.getResponseHeader(\"Location\");\n        if (location == null) {\n          _this4._emitXhrError(xhr, new Error(\"tus: invalid or missing Location header\"));\n          return;\n        }\n\n        _this4.url = (0, _request.resolveUrl)(_this4.options.endpoint, location);\n\n        if (_this4._size === 0) {\n          // Nothing to upload and file was successfully created\n          _this4._emitSuccess();\n          _this4._source.close();\n          return;\n        }\n\n        if (_this4._hasStorage()) {\n          _this4._storage.setItem(_this4._fingerprint, _this4.url, function (err) {\n            if (err) {\n              _this4._emitError(err);\n            }\n          });\n        }\n\n        if (_this4.options.uploadDataDuringCreation) {\n          _this4._handleUploadResponse(xhr);\n        } else {\n          _this4._offset = 0;\n          _this4._startUpload();\n        }\n      };\n\n      xhr.onerror = function (err) {\n        _this4._emitXhrError(xhr, new Error(\"tus: failed to create upload\"), err);\n      };\n\n      this._setupXHR(xhr);\n      if (this.options.uploadLengthDeferred) {\n        xhr.setRequestHeader(\"Upload-Defer-Length\", 1);\n      } else {\n        xhr.setRequestHeader(\"Upload-Length\", this._size);\n      }\n\n      // Add metadata if values have been added\n      var metadata = encodeMetadata(this.options.metadata);\n      if (metadata !== \"\") {\n        xhr.setRequestHeader(\"Upload-Metadata\", metadata);\n      }\n\n      if (this.options.uploadDataDuringCreation && !this.options.uploadLengthDeferred) {\n        this._offset = 0;\n        this._addChunkToRequest(xhr);\n      } else {\n        xhr.send(null);\n      }\n    }\n\n    /*\n     * Try to resume an existing upload. First a HEAD request will be sent\n     * to retrieve the offset. If the request fails a new upload will be\n     * created. In the case of a successful response the file will be uploaded.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_resumeUpload\",\n    value: function _resumeUpload() {\n      var _this5 = this;\n\n      var xhr = (0, _request.newRequest)();\n      xhr.open(\"HEAD\", this.url, true);\n\n      xhr.onload = function () {\n        if (!inStatusCategory(xhr.status, 200)) {\n          if (_this5._hasStorage() && inStatusCategory(xhr.status, 400)) {\n            // Remove stored fingerprint and corresponding endpoint,\n            // on client errors since the file can not be found\n            _this5._storage.removeItem(_this5._fingerprint, function (err) {\n              if (err) {\n                _this5._emitError(err);\n              }\n            });\n          }\n\n          // If the upload is locked (indicated by the 423 Locked status code), we\n          // emit an error instead of directly starting a new upload. This way the\n          // retry logic can catch the error and will retry the upload. An upload\n          // is usually locked for a short period of time and will be available\n          // afterwards.\n          if (xhr.status === 423) {\n            _this5._emitXhrError(xhr, new Error(\"tus: upload is currently locked; retry later\"));\n            return;\n          }\n\n          if (!_this5.options.endpoint) {\n            // Don't attempt to create a new upload if no endpoint is provided.\n            _this5._emitXhrError(xhr, new Error(\"tus: unable to resume upload (new upload cannot be created without an endpoint)\"));\n            return;\n          }\n\n          // Try to create a new upload\n          _this5.url = null;\n          _this5._createUpload();\n          return;\n        }\n\n        var offset = parseInt(xhr.getResponseHeader(\"Upload-Offset\"), 10);\n        if (isNaN(offset)) {\n          _this5._emitXhrError(xhr, new Error(\"tus: invalid or missing offset value\"));\n          return;\n        }\n\n        var length = parseInt(xhr.getResponseHeader(\"Upload-Length\"), 10);\n        if (isNaN(length) && !_this5.options.uploadLengthDeferred) {\n          _this5._emitXhrError(xhr, new Error(\"tus: invalid or missing length value\"));\n          return;\n        }\n\n        // Upload has already been completed and we do not need to send additional\n        // data to the server\n        if (offset === length) {\n          _this5._emitProgress(length, length);\n          _this5._emitSuccess();\n          return;\n        }\n\n        _this5._offset = offset;\n        _this5._startUpload();\n      };\n\n      xhr.onerror = function (err) {\n        _this5._emitXhrError(xhr, new Error(\"tus: failed to resume upload\"), err);\n      };\n\n      this._setupXHR(xhr);\n      xhr.send(null);\n    }\n\n    /**\n     * Start uploading the file using PATCH requests. The file will be divided\n     * into chunks as specified in the chunkSize option. During the upload\n     * the onProgress event handler may be invoked multiple times.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_startUpload\",\n    value: function _startUpload() {\n      var _this6 = this;\n\n      // If the upload has been aborted, we will not send the next PATCH request.\n      // This is important if the abort method was called during a callback, such\n      // as onChunkComplete or onProgress.\n      if (this._aborted) {\n        return;\n      }\n\n      var xhr = (0, _request.newRequest)();\n\n      // Some browser and servers may not support the PATCH method. For those\n      // cases, you can tell tus-js-client to use a POST request with the\n      // X-HTTP-Method-Override header for simulating a PATCH request.\n      if (this.options.overridePatchMethod) {\n        xhr.open(\"POST\", this.url, true);\n        xhr.setRequestHeader(\"X-HTTP-Method-Override\", \"PATCH\");\n      } else {\n        xhr.open(\"PATCH\", this.url, true);\n      }\n\n      xhr.onload = function () {\n        if (!inStatusCategory(xhr.status, 200)) {\n          _this6._emitXhrError(xhr, new Error(\"tus: unexpected response while uploading chunk\"));\n          return;\n        }\n\n        _this6._handleUploadResponse(xhr);\n      };\n\n      xhr.onerror = function (err) {\n        // Don't emit an error if the upload was aborted manually\n        if (_this6._aborted) {\n          return;\n        }\n\n        _this6._emitXhrError(xhr, new Error(\"tus: failed to upload chunk at offset \" + _this6._offset), err);\n      };\n\n      this._setupXHR(xhr);\n\n      xhr.setRequestHeader(\"Upload-Offset\", this._offset);\n      this._addChunkToRequest(xhr);\n    }\n\n    /**\n     * _addChunktoRequest reads a chunk from the source and sends it using the\n     * supplied XHR object. It will not handle the response.\n     */\n\n  }, {\n    key: \"_addChunkToRequest\",\n    value: function _addChunkToRequest(xhr) {\n      var _this7 = this;\n\n      // Test support for progress events before attaching an event listener\n      if (\"upload\" in xhr) {\n        xhr.upload.onprogress = function (e) {\n          if (!e.lengthComputable) {\n            return;\n          }\n\n          _this7._emitProgress(start + e.loaded, _this7._size);\n        };\n      }\n\n      xhr.setRequestHeader(\"Content-Type\", \"application/offset+octet-stream\");\n\n      var start = this._offset;\n      var end = this._offset + this.options.chunkSize;\n\n      // The specified chunkSize may be Infinity or the calcluated end position\n      // may exceed the file's size. In both cases, we limit the end position to\n      // the input's total size for simpler calculations and correctness.\n      if ((end === Infinity || end > this._size) && !this.options.uploadLengthDeferred) {\n        end = this._size;\n      }\n\n      this._source.slice(start, end, function (err, value, complete) {\n        if (err) {\n          _this7._emitError(err);\n          return;\n        }\n\n        if (_this7.options.uploadLengthDeferred) {\n          if (complete) {\n            _this7._size = _this7._offset + (value && value.size ? value.size : 0);\n            xhr.setRequestHeader(\"Upload-Length\", _this7._size);\n          }\n        }\n\n        if (value === null) {\n          xhr.send();\n        } else {\n          xhr.send(value);\n          _this7._emitProgress(_this7._offset, _this7._size);\n        }\n      });\n    }\n\n    /**\n     * _handleUploadResponse is used by requests that haven been sent using _addChunkToRequest\n     * and already have received a response.\n     */\n\n  }, {\n    key: \"_handleUploadResponse\",\n    value: function _handleUploadResponse(xhr) {\n      var _this8 = this;\n\n      var offset = parseInt(xhr.getResponseHeader(\"Upload-Offset\"), 10);\n      if (isNaN(offset)) {\n        this._emitXhrError(xhr, new Error(\"tus: invalid or missing offset value\"));\n        return;\n      }\n\n      this._emitProgress(offset, this._size);\n      this._emitChunkComplete(offset - this._offset, offset, this._size);\n\n      this._offset = offset;\n\n      if (offset == this._size) {\n        if (this.options.removeFingerprintOnSuccess && this.options.resume) {\n          // Remove stored fingerprint and corresponding endpoint. This causes\n          // new upload of the same file must be treated as a different file.\n          this._storage.removeItem(this._fingerprint, function (err) {\n            if (err) {\n              _this8._emitError(err);\n            }\n          });\n        }\n\n        // Yay, finally done :)\n        this._emitSuccess();\n        this._source.close();\n        return;\n      }\n\n      this._startUpload();\n    }\n  }], [{\n    key: \"terminate\",\n    value: function terminate(url, options, cb) {\n      if (typeof options !== \"function\" && typeof cb !== \"function\") {\n        throw new Error(\"tus: a callback function must be specified\");\n      }\n\n      if (typeof options === \"function\") {\n        cb = options;\n        options = {};\n      }\n\n      var xhr = (0, _request.newRequest)();\n      xhr.open(\"DELETE\", url, true);\n\n      xhr.onload = function () {\n        if (xhr.status !== 204) {\n          cb(new _error2.default(new Error(\"tus: unexpected response while terminating upload\"), null, xhr));\n          return;\n        }\n\n        cb();\n      };\n\n      xhr.onerror = function (err) {\n        cb(new _error2.default(err, new Error(\"tus: failed to terminate upload\"), xhr));\n      };\n\n      setupXHR(xhr, options);\n      xhr.send(null);\n    }\n  }]);\n\n  return Upload;\n}();\n\nfunction encodeMetadata(metadata) {\n  var encoded = [];\n\n  for (var key in metadata) {\n    encoded.push(key + \" \" + _jsBase.Base64.encode(metadata[key]));\n  }\n\n  return encoded.join(\",\");\n}\n\n/**\n * Checks whether a given status is in the range of the expected category.\n * For example, only a status between 200 and 299 will satisfy the category 200.\n *\n * @api private\n */\nfunction inStatusCategory(status, category) {\n  return status >= category && status < category + 100;\n}\n\nfunction setupXHR(xhr, options) {\n  xhr.setRequestHeader(\"Tus-Resumable\", \"1.0.0\");\n  var headers = options.headers || {};\n\n  for (var name in headers) {\n    xhr.setRequestHeader(name, headers[name]);\n  }\n\n  xhr.withCredentials = options.withCredentials;\n}\n\nUpload.defaultOptions = defaultOptions;\n\nexports.default = Upload;"]},"metadata":{},"sourceType":"script"}