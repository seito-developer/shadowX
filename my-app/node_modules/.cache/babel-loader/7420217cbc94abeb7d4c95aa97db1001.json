{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _sourceMap = require('source-map');\n\nvar _sourceMap2 = _interopRequireDefault(_sourceMap);\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar MapGenerator = function () {\n  function MapGenerator(stringify, root, opts) {\n    _classCallCheck(this, MapGenerator);\n\n    this.stringify = stringify;\n    this.mapOpts = opts.map || {};\n    this.root = root;\n    this.opts = opts;\n  }\n\n  MapGenerator.prototype.isMap = function isMap() {\n    if (typeof this.opts.map !== 'undefined') {\n      return !!this.opts.map;\n    } else {\n      return this.previous().length > 0;\n    }\n  };\n\n  MapGenerator.prototype.previous = function previous() {\n    var _this = this;\n\n    if (!this.previousMaps) {\n      this.previousMaps = [];\n      this.root.walk(function (node) {\n        if (node.source && node.source.input.map) {\n          var map = node.source.input.map;\n\n          if (_this.previousMaps.indexOf(map) === -1) {\n            _this.previousMaps.push(map);\n          }\n        }\n      });\n    }\n\n    return this.previousMaps;\n  };\n\n  MapGenerator.prototype.isInline = function isInline() {\n    if (typeof this.mapOpts.inline !== 'undefined') {\n      return this.mapOpts.inline;\n    }\n\n    var annotation = this.mapOpts.annotation;\n\n    if (typeof annotation !== 'undefined' && annotation !== true) {\n      return false;\n    }\n\n    if (this.previous().length) {\n      return this.previous().some(function (i) {\n        return i.inline;\n      });\n    } else {\n      return true;\n    }\n  };\n\n  MapGenerator.prototype.isSourcesContent = function isSourcesContent() {\n    if (typeof this.mapOpts.sourcesContent !== 'undefined') {\n      return this.mapOpts.sourcesContent;\n    }\n\n    if (this.previous().length) {\n      return this.previous().some(function (i) {\n        return i.withContent();\n      });\n    } else {\n      return true;\n    }\n  };\n\n  MapGenerator.prototype.clearAnnotation = function clearAnnotation() {\n    if (this.mapOpts.annotation === false) return;\n    var node = void 0;\n\n    for (var i = this.root.nodes.length - 1; i >= 0; i--) {\n      node = this.root.nodes[i];\n      if (node.type !== 'comment') continue;\n\n      if (node.text.indexOf('# sourceMappingURL=') === 0) {\n        this.root.removeChild(i);\n      }\n    }\n  };\n\n  MapGenerator.prototype.setSourcesContent = function setSourcesContent() {\n    var _this2 = this;\n\n    var already = {};\n    this.root.walk(function (node) {\n      if (node.source) {\n        var from = node.source.input.from;\n\n        if (from && !already[from]) {\n          already[from] = true;\n\n          var relative = _this2.relative(from);\n\n          _this2.map.setSourceContent(relative, node.source.input.css);\n        }\n      }\n    });\n  };\n\n  MapGenerator.prototype.applyPrevMaps = function applyPrevMaps() {\n    for (var _iterator = this.previous(), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var prev = _ref;\n      var from = this.relative(prev.file);\n\n      var root = prev.root || _path2.default.dirname(prev.file);\n\n      var map = void 0;\n\n      if (this.mapOpts.sourcesContent === false) {\n        map = new _sourceMap2.default.SourceMapConsumer(prev.text);\n\n        if (map.sourcesContent) {\n          map.sourcesContent = map.sourcesContent.map(function () {\n            return null;\n          });\n        }\n      } else {\n        map = prev.consumer();\n      }\n\n      this.map.applySourceMap(map, from, this.relative(root));\n    }\n  };\n\n  MapGenerator.prototype.isAnnotation = function isAnnotation() {\n    if (this.isInline()) {\n      return true;\n    } else if (typeof this.mapOpts.annotation !== 'undefined') {\n      return this.mapOpts.annotation;\n    } else if (this.previous().length) {\n      return this.previous().some(function (i) {\n        return i.annotation;\n      });\n    } else {\n      return true;\n    }\n  };\n\n  MapGenerator.prototype.toBase64 = function toBase64(str) {\n    if (Buffer) {\n      if (Buffer.from && Buffer.from !== Uint8Array.from) {\n        return Buffer.from(str).toString('base64');\n      } else {\n        return new Buffer(str).toString('base64');\n      }\n    } else {\n      return window.btoa(unescape(encodeURIComponent(str)));\n    }\n  };\n\n  MapGenerator.prototype.addAnnotation = function addAnnotation() {\n    var content = void 0;\n\n    if (this.isInline()) {\n      content = 'data:application/json;base64,' + this.toBase64(this.map.toString());\n    } else if (typeof this.mapOpts.annotation === 'string') {\n      content = this.mapOpts.annotation;\n    } else {\n      content = this.outputFile() + '.map';\n    }\n\n    var eol = '\\n';\n    if (this.css.indexOf('\\r\\n') !== -1) eol = '\\r\\n';\n    this.css += eol + '/*# sourceMappingURL=' + content + ' */';\n  };\n\n  MapGenerator.prototype.outputFile = function outputFile() {\n    if (this.opts.to) {\n      return this.relative(this.opts.to);\n    } else if (this.opts.from) {\n      return this.relative(this.opts.from);\n    } else {\n      return 'to.css';\n    }\n  };\n\n  MapGenerator.prototype.generateMap = function generateMap() {\n    this.generateString();\n    if (this.isSourcesContent()) this.setSourcesContent();\n    if (this.previous().length > 0) this.applyPrevMaps();\n    if (this.isAnnotation()) this.addAnnotation();\n\n    if (this.isInline()) {\n      return [this.css];\n    } else {\n      return [this.css, this.map];\n    }\n  };\n\n  MapGenerator.prototype.relative = function relative(file) {\n    if (file.indexOf('<') === 0) return file;\n    if (/^\\w+:\\/\\//.test(file)) return file;\n    var from = this.opts.to ? _path2.default.dirname(this.opts.to) : '.';\n\n    if (typeof this.mapOpts.annotation === 'string') {\n      from = _path2.default.dirname(_path2.default.resolve(from, this.mapOpts.annotation));\n    }\n\n    file = _path2.default.relative(from, file);\n\n    if (_path2.default.sep === '\\\\') {\n      return file.replace(/\\\\/g, '/');\n    } else {\n      return file;\n    }\n  };\n\n  MapGenerator.prototype.sourcePath = function sourcePath(node) {\n    if (this.mapOpts.from) {\n      return this.mapOpts.from;\n    } else {\n      return this.relative(node.source.input.from);\n    }\n  };\n\n  MapGenerator.prototype.generateString = function generateString() {\n    var _this3 = this;\n\n    this.css = '';\n    this.map = new _sourceMap2.default.SourceMapGenerator({\n      file: this.outputFile()\n    });\n    var line = 1;\n    var column = 1;\n    var lines = void 0,\n        last = void 0;\n    this.stringify(this.root, function (str, node, type) {\n      _this3.css += str;\n\n      if (node && type !== 'end') {\n        if (node.source && node.source.start) {\n          _this3.map.addMapping({\n            source: _this3.sourcePath(node),\n            generated: {\n              line: line,\n              column: column - 1\n            },\n            original: {\n              line: node.source.start.line,\n              column: node.source.start.column - 1\n            }\n          });\n        } else {\n          _this3.map.addMapping({\n            source: '<no source>',\n            original: {\n              line: 1,\n              column: 0\n            },\n            generated: {\n              line: line,\n              column: column - 1\n            }\n          });\n        }\n      }\n\n      lines = str.match(/\\n/g);\n\n      if (lines) {\n        line += lines.length;\n        last = str.lastIndexOf('\\n');\n        column = str.length - last;\n      } else {\n        column += str.length;\n      }\n\n      if (node && type !== 'start') {\n        if (node.source && node.source.end) {\n          _this3.map.addMapping({\n            source: _this3.sourcePath(node),\n            generated: {\n              line: line,\n              column: column - 1\n            },\n            original: {\n              line: node.source.end.line,\n              column: node.source.end.column\n            }\n          });\n        } else {\n          _this3.map.addMapping({\n            source: '<no source>',\n            original: {\n              line: 1,\n              column: 0\n            },\n            generated: {\n              line: line,\n              column: column - 1\n            }\n          });\n        }\n      }\n    });\n  };\n\n  MapGenerator.prototype.generate = function generate() {\n    this.clearAnnotation();\n\n    if (this.isMap()) {\n      return this.generateMap();\n    } else {\n      var result = '';\n      this.stringify(this.root, function (i) {\n        result += i;\n      });\n      return [result];\n    }\n  };\n\n  return MapGenerator;\n}();\n\nexports.default = MapGenerator;\nmodule.exports = exports['default'];","map":{"version":3,"sources":["map-generator.es6"],"names":["MapGenerator","opts","isMap","previous","node","map","isInline","annotation","i","isSourcesContent","clearAnnotation","setSourcesContent","already","from","relative","applyPrevMaps","prev","root","path","mozilla","isAnnotation","toBase64","str","Buffer","Uint8Array","window","unescape","encodeURIComponent","addAnnotation","content","eol","outputFile","generateMap","file","sourcePath","generateString","line","column","lines","last","type","source","generated","original","generate","result"],"mappings":"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","sourcesContent":["import mozilla from 'source-map';\nimport path    from 'path';\n\nexport default class MapGenerator {\n\n    constructor(stringify, root, opts) {\n        this.stringify = stringify;\n        this.mapOpts   = opts.map || { };\n        this.root      = root;\n        this.opts      = opts;\n    }\n\n    isMap() {\n        if ( typeof this.opts.map !== 'undefined' ) {\n            return !!this.opts.map;\n        } else {\n            return this.previous().length > 0;\n        }\n    }\n\n    previous() {\n        if ( !this.previousMaps ) {\n            this.previousMaps = [];\n            this.root.walk( node => {\n                if ( node.source && node.source.input.map ) {\n                    let map = node.source.input.map;\n                    if ( this.previousMaps.indexOf(map) === -1 ) {\n                        this.previousMaps.push(map);\n                    }\n                }\n            });\n        }\n\n        return this.previousMaps;\n    }\n\n    isInline() {\n        if ( typeof this.mapOpts.inline !== 'undefined' ) {\n            return this.mapOpts.inline;\n        }\n\n        let annotation = this.mapOpts.annotation;\n        if ( typeof annotation !== 'undefined' && annotation !== true ) {\n            return false;\n        }\n\n        if ( this.previous().length ) {\n            return this.previous().some( i => i.inline );\n        } else {\n            return true;\n        }\n    }\n\n    isSourcesContent() {\n        if ( typeof this.mapOpts.sourcesContent !== 'undefined' ) {\n            return this.mapOpts.sourcesContent;\n        }\n        if ( this.previous().length ) {\n            return this.previous().some( i => i.withContent() );\n        } else {\n            return true;\n        }\n    }\n\n    clearAnnotation() {\n        if ( this.mapOpts.annotation === false ) return;\n\n        let node;\n        for ( let i = this.root.nodes.length - 1; i >= 0; i-- ) {\n            node = this.root.nodes[i];\n            if ( node.type !== 'comment' ) continue;\n            if ( node.text.indexOf('# sourceMappingURL=') === 0 ) {\n                this.root.removeChild(i);\n            }\n        }\n    }\n\n    setSourcesContent() {\n        let already = { };\n        this.root.walk( node => {\n            if ( node.source ) {\n                let from = node.source.input.from;\n                if ( from && !already[from] ) {\n                    already[from] = true;\n                    let relative = this.relative(from);\n                    this.map.setSourceContent(relative, node.source.input.css);\n                }\n            }\n        });\n    }\n\n    applyPrevMaps() {\n        for ( let prev of this.previous() ) {\n            let from = this.relative(prev.file);\n            let root = prev.root || path.dirname(prev.file);\n            let map;\n\n            if ( this.mapOpts.sourcesContent === false ) {\n                map = new mozilla.SourceMapConsumer(prev.text);\n                if ( map.sourcesContent ) {\n                    map.sourcesContent = map.sourcesContent.map( () => null );\n                }\n            } else {\n                map = prev.consumer();\n            }\n\n            this.map.applySourceMap(map, from, this.relative(root));\n        }\n    }\n\n    isAnnotation() {\n        if ( this.isInline() ) {\n            return true;\n        } else if ( typeof this.mapOpts.annotation !== 'undefined' ) {\n            return this.mapOpts.annotation;\n        } else if ( this.previous().length ) {\n            return this.previous().some( i => i.annotation );\n        } else {\n            return true;\n        }\n    }\n\n    toBase64(str) {\n        if ( Buffer ) {\n            if ( Buffer.from && Buffer.from !== Uint8Array.from ) {\n                return Buffer.from(str).toString('base64');\n            } else {\n                return new Buffer(str).toString('base64');\n            }\n        } else {\n            return window.btoa(unescape(encodeURIComponent(str)));\n        }\n    }\n\n    addAnnotation() {\n        let content;\n\n        if ( this.isInline() ) {\n\n            content = 'data:application/json;base64,' +\n                this.toBase64(this.map.toString());\n\n        } else if ( typeof this.mapOpts.annotation === 'string' ) {\n            content = this.mapOpts.annotation;\n\n        } else {\n            content = this.outputFile() + '.map';\n        }\n\n        let eol   = '\\n';\n        if ( this.css.indexOf('\\r\\n') !== -1 ) eol = '\\r\\n';\n\n        this.css += eol + '/*# sourceMappingURL=' + content + ' */';\n    }\n\n    outputFile() {\n        if ( this.opts.to ) {\n            return this.relative(this.opts.to);\n        } else if ( this.opts.from ) {\n            return this.relative(this.opts.from);\n        } else {\n            return 'to.css';\n        }\n    }\n\n    generateMap() {\n        this.generateString();\n        if ( this.isSourcesContent() )    this.setSourcesContent();\n        if ( this.previous().length > 0 ) this.applyPrevMaps();\n        if ( this.isAnnotation() )        this.addAnnotation();\n\n        if ( this.isInline() ) {\n            return [this.css];\n        } else {\n            return [this.css, this.map];\n        }\n    }\n\n    relative(file) {\n        if ( file.indexOf('<') === 0 ) return file;\n        if ( /^\\w+:\\/\\//.test(file) ) return file;\n\n        let from = this.opts.to ? path.dirname(this.opts.to) : '.';\n\n        if ( typeof this.mapOpts.annotation === 'string' ) {\n            from = path.dirname( path.resolve(from, this.mapOpts.annotation) );\n        }\n\n        file = path.relative(from, file);\n        if ( path.sep === '\\\\' ) {\n            return file.replace(/\\\\/g, '/');\n        } else {\n            return file;\n        }\n    }\n\n    sourcePath(node) {\n        if ( this.mapOpts.from ) {\n            return this.mapOpts.from;\n        } else {\n            return this.relative(node.source.input.from);\n        }\n    }\n\n    generateString() {\n        this.css = '';\n        this.map = new mozilla.SourceMapGenerator({ file: this.outputFile() });\n\n        let line   = 1;\n        let column = 1;\n\n        let lines, last;\n        this.stringify(this.root, (str, node, type) => {\n            this.css += str;\n\n            if ( node && type !== 'end' ) {\n                if ( node.source && node.source.start ) {\n                    this.map.addMapping({\n                        source:    this.sourcePath(node),\n                        generated: { line, column: column - 1 },\n                        original:  {\n                            line:   node.source.start.line,\n                            column: node.source.start.column - 1\n                        }\n                    });\n                } else {\n                    this.map.addMapping({\n                        source:    '<no source>',\n                        original:  { line: 1, column: 0 },\n                        generated: { line, column: column - 1 }\n                    });\n                }\n            }\n\n            lines = str.match(/\\n/g);\n            if ( lines ) {\n                line  += lines.length;\n                last   = str.lastIndexOf('\\n');\n                column = str.length - last;\n            } else {\n                column += str.length;\n            }\n\n            if ( node && type !== 'start' ) {\n                if ( node.source && node.source.end ) {\n                    this.map.addMapping({\n                        source:    this.sourcePath(node),\n                        generated: { line, column: column - 1 },\n                        original:  {\n                            line:   node.source.end.line,\n                            column: node.source.end.column\n                        }\n                    });\n                } else {\n                    this.map.addMapping({\n                        source:    '<no source>',\n                        original:  { line: 1, column: 0 },\n                        generated: { line, column: column - 1 }\n                    });\n                }\n            }\n        });\n    }\n\n    generate() {\n        this.clearAnnotation();\n\n        if ( this.isMap() ) {\n            return this.generateMap();\n        } else {\n            let result = '';\n            this.stringify(this.root, i => {\n                result += i;\n            });\n            return [result];\n        }\n    }\n\n}\n"]},"metadata":{},"sourceType":"script"}